{"./":{"url":"./","title":"GitBook配置","keywords":"","body":"配置 npm install gitbook-cli -g 全局下载 node 版本 切到 合适的 (利用node版本管理 ) mac:n ;window:暂时没用 plugins[https://www.cnblogs.com/mingyue5826/p/10307051.html] chapter-fold expandable-chapters-small expandable-chapters search-pro Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-20 10:32:34 "},"Docker/基础篇.html":{"url":"Docker/基础篇.html","title":"基础篇","keywords":"","body":" 本文由 简悦 SimpRead 转码， 原文地址 zhuanlan.zhihu.com 创建镜像 #1.基于已有容器创建（docker commit） docker commit 从一个容器的修改中创建一个新的镜像 docker commit -m=\"提交的信息\" -a=\"作者\" 容器id 镜像名:tag docker commit -m=\"add webapps\" -a=\"tobabm\" 容器id tomcat01:1.0 #2.基于本地模板导入 docker import test.tar test:1.0 #基于dockerfile创建 使用 tag 命令添加镜像标签 docker tag 原来的名字:标签 新的名字:标签 #docker tag添加标签实际上起到类似链接的作用 使用 history 命令查看镜像历史 docker history 镜像名:标签 存出和载入镜像 存出镜像 docker save -o test.tar ubuntu:18.04 载入镜像 docker load -i test.tar #或者 docker load 清理镜像 docker image prune -f #-f强制删除 创建容器 #创建一个Ubuntu:latest容器 docker create -it ubuntu 后台启动容器 docker run -d centos #上述命令执行后，使用docker ps查看发现并没有后台运行 #docker容器后台运行必须有前台进程 #使用Ctrl+P+Q退出时容器会保持后台运行 暂停容器 docker pause 容器 #处于paused状态的容器可以使用下面指令恢复运行状态 docker unpause 容器 终止容器 #docker stop命令会先向容器发送SIGTERM信号，等待一段时间（默认10s），再发送SIGKILL信号来终止容器 docker stop [-t|--time [=10]] 容器 #停止后可以使用docker container prune命令，会自动清除掉所有处于停止状态的容器 #也可以通过下面命令直接发送SIGKILL信号来强行终止容器 查看日志 docker run -d centos /bin/sh -c \"while true;do echo helloworld;sleep 1;done\" docker logs [参数] 容器 -tf #显示日志 --tail number #要显示的日志条数 查看容器中进程信息 docker top 容器id 查看镜像的元数据 docker inspect 容器id 进入当前正在运行的容器 #方法1 #进入容器后开启一个新终端，可以在容器中操作 docker exec -it 容器id /bin/bash #方法2 #进入容器中正在执行的终端，不会启动新的终端 docker attach 容器id 导入和导出容器 导出容器 #导出容器是指导出一个已经创建好的容器到一个文件，不管此时这个容器是否处于运行状态 docker export [-o|--output[=\"\"]] 容器 #可以通过-o指定导出的tar文件，也可以直接通过重定向实现 docker export -o test.tar 容器 docker export 容器 > test.tar 导入容器 #导出的文件可以使用docker import导入变为镜像 docker import [-c|--change[=[]]] [-m|--message[=MESSAGE]] file|url|- #容器快照文件将丢失所有历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积更大 #从容器快照文件导入时可以重新指定标签等元数据信息 从容器内拷贝文件到主机 docker cp 容器id:容器内路径 目标主机路径 #拷贝是一个主动的过程，可以通过-v卷的技术实习同步 查看容器变更 docker diff 容器 查看端口映射 docker port 容器 更新配置 docker update docker 安装 nginx #1.搜索镜像，可以去dockerhub搜索，有关于镜像的详细信息 docker search nginx #2.拉取镜像 docker pull nginx #3.启动nginx,以后台形式运行nginx并将容器80端口映射到本机3340端口（命名为nginx01） docker run -d --name nginx01 -p 3340:80 nginx docker 安装 tomcat #官方 --rm表示用完就删，常用来测试 docker run -it --rm tomcat:9.0 #拉取镜像 docker pull tomcat #运行tomcat docker run -d -p 3355:8080 --name tomcat01 tomcat #测试访问没问题，但显示404 #进入容器 docker exec -it tomcat01 /bin/bash #发现问题:1.linux命令不全 2.webapps为空 #其实webapps所需要的在webapps.dist中，复制过去即可 cp -r webapps.dist/* webapps/ docker 数据卷 #路径挂载 docker run -it -v 主机目录:容器目录 镜像 #将本地/home/test目录映射到容器/home目录 docker run -d -v /home/test:/home -p 3340:80 nginx #匿名挂载和具名挂载产生的数据卷都放在/var/lib/docker/volumes #匿名挂载,在-v后只写容器内路径 docker run -d -P -v /home --name nginx01 nginx #具名挂载,通过-v 卷名:容器路径 docker run -d -P -v test:/home --name nginx02 nginx #查看匿名/具名挂载的数据卷 docker volume ls #通过-v 容器路径:ro/rw来改变读写权限(默认为rw) docker run -d -P -v test01:/home:ro --name nginx03 nginx #如果设置了ro，则只能在宿主机操作，容器内不能操作 数据卷容器 \"关于 Docker volume 挂载时文件或文件夹不存在的问题\" #创建一个数据卷容器 docker run -it --name t1 -v test:/home centos #在/home下创建test.txt touch test.txt #创建另一个容器挂载数据卷容器 docker run -it --name t2 --volumes-from t1 centos #发现在该容器/home下有test.txt #删除数据卷容器，数据依旧存在 #容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止 #如果删除本地的数据卷则数据会清空 docker 安装 mysql #官方 docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag #获取镜像 docker pull mysql #创建容器并数据挂载 docker run -d -p 3306:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql dockerfile dockerfile 是用来构建 docker 镜像的文件 #dockerfile中指令大写 FROM centos VOLUME [\"volume1\",\"volume2\"] CMD echo \"---end---\" CMD /bin/bash docker build 创建镜像 docker build -f dockerfile文件 -t 镜像名:[tag] . dockerfile 的指令 #指定基础镜像 FROM #指定维护者信息,姓名+邮箱 MAINTAINER #镜像构建时需要执行的指令 RUN #添加内容到镜像 ADD #复制内容到镜像 #配置工作目录 WORKDIR #设置卷，挂载主机目录 VOLUME #指定对外的端口 EXPOSE #CMD指令的主要用意是设置容器的默认执行的命令。CMD设定的命令会在entrypoint之后执行，只有最后一个可以被执行，可被替代 CMD #Entrypoint指令用于设定容器启动时第一个运行的命令及其参数，可以追加命令。任何使用docker run 命令传入的参数都会附加在entrypoint指令之后，并且用此命令传入的参数会覆盖在Dockerfile中使用CMD指令设定的值。比如docker run bash命令会将bash命令附加在entrypoint指令设定的值的后面 ENTRYPOINT #创建子镜像时指定自动执行的操作指令 ONBUILD #设置环境变量 ENV CMD 与 ENTRYPOINT 的区别 镜像 test1 FROM centos CMD [\"ls\",\"-a\"] 镜像 test2 FROM centos ENTRYPOINT [\"ls\",\"-a\"] 分别运行两个镜像 #test1报错 docker run test1 -l #test2以列表形式输出 docker run test2 -l scratch 是 dockerfile 中的基础镜像 dockerfile 实战之 centos FROM centos MAINTAINER tobabm ENV MYPATH /usr/local WORKDIR $MYPATH #增加vim RUN yum -y install vim #增加ifconfig RUN yum -y install net-tools EXPOSE 80 CMD echo $MYPATH CMD echo \"---end---\" CMD /bin/bash dockerfile 实战之 ubuntu FROM ubuntu MAINTAINER tobabm ENV MYPATH /usr/local WORKDIR $MYPATH #增加vim RUN apt-get update RUN apt-get -y install vim #安装w3m命令行浏览器 RUN apt-get -y install w3m w3m-img EXPOSE 80 CMD echo $MYPATH CMD echo \"---end---\" CMD /bin/bash docker 网络 #只要安装了docker，就会有一个网卡docker0（桥接模式），使用evth-pair技术 #每启动一个容器，docker就会给容器分配一个ip #启动一个tomcat docker run -d -P --name tomcat01 tomcat #本机可以ping通容器，容器之间也可以ping通 #docker0起到类似路由器的作用，所有容器不指定网络的情况下，默认docker0路由，docker会给容器分配一个默认的容器ip #docker中的网络接口都是虚拟的，虚拟的转发效率高 #当容器停止或删除，对应网卡自动消失 #可以使用docker network命令查看网络信息 Usage: docker network COMMAND Manage networks Commands: connect Connect a container to a network create Create a network disconnect Disconnect a container from a network inspect Display detailed information on one or more networks ls List networks prune Remove all unused networks rm Remove one or more networks #查看网络列表 docker network ls #查看网络详细信息 docker network 网络id inspect 容器互联 #容器互联是一种让多个容器中的应用进行快速交互的方式。它会在源和接收容器之间创建连接关系，接收容器可以通过容器名快速访问到源容器，而不用指定具体的ip地址。 docker run -it --name t1 ubuntu docker run -it --name t2 --link t1:test ubuntu #--link参数的格式为--link name:alias,其中name是要链接的容器的名称，alias是别名 #接下来在t2中可以直接ping通t1或test，而在t1中则不能ping通t2 #查看t2的/etc/hosts发现t1相关信息被写入 #--link其实就是在t2的/etc/hosts写入t1的映射（容器名，id，别名） #真实开发不建议使用--link，docker0不适用自定义网络，不支持容器名连接访问 自定义网络 网络模式 #桥接,docker默认 bridge #不配置网络 none #主机模式，和宿主机共享网络 host #容器内网络连通，局限较大，使用较少 container 自定义网络 #我们直接启动的命令，默认添加了--net bridge,也就是docker0 docker run -d -P --name tomcat 01 tomcat docker run -d -P --name tomcat 01 --net bridge tomcat #docker0特点：默认模式，域名不能访问，--link可以连接 #使用docker network create创建网络 Usage: docker network create [OPTIONS] NETWORK Create a network Options: --attachable Enable manual container attachment --aux-address map Auxiliary IPv4 or IPv6 addresses used by Network driver (default map[]) --config-from string The network from which to copy the configuration --config-only Create a configuration only network -d, --driver string Driver to manage the Network (default \"bridge\") --gateway strings IPv4 or IPv6 Gateway for the master subnet --ingress Create swarm routing-mesh network --internal Restrict external access to the network --ip-range strings Allocate container ip from a sub-range --ipam-driver string IP Address Management Driver (default \"default\") --ipam-opt map Set IPAM driver specific options (default map[]) --ipv6 Enable IPv6 networking --label list Set metadata on a network -o, --opt map Set driver specific options (default map[]) --scope string Control the network's scope --subnet strings Subnet in CIDR format that represents a network segment #--subnet子网掩码，--gateway网关 #例 docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet #使用刚才创建的网络 docker run -d -P --name t1 --net mynet ubuntu docker run -d -P --name t2 --net mynet ubuntu #再次查看自定义的网络 docker network inspect mynet 使用 t1 ping t2, 现在不使用 --link，也可以直接 ping 名字（推荐使用自定义网络） #不同的集群使用不同的网络可以保证集群是安全和健康的 网络连通 #现有两个网络，默认的docker0（里面有容器d1和d2）和自定义网络mynet（里面有容器t1和t2），现在想要d1能ping通t1 #首先docker0与mynet不能想通，而d1想要ping通t1就要先与mynet连接，再与t1连接 $ docker network connect --help Usage: docker network connect [OPTIONS] NETWORK CONTAINER Connect a container to a network Options: --alias strings Add network-scoped alias for the container --driver-opt strings driver options for the network --ip string IPv4 address (e.g., 172.30.100.104) --ip6 string IPv6 address (e.g., 2001:db8::33) --link list Add link to another container --link-local-ip strings Add a link-local address for the container #使用docker network connect连接d1到mynet docker network connect mynet d1 #查看mynet，d1被直接加在mynet中 docker network inspect mynet 使用 d1 ping t1 使用 d1 ping t2 注意：d2 未与 mynet 连通，故 d2 不能 ping 通 t1 和 t2 Redis 集群部署实战 #创建Redis网络 docker network create --subnet 172.38.0.0/16 redis #通过脚本创建6个Redis配置 for port in $(seq 1 6);\\ do \\ mkdir -p /mydata/redis/node-${port}/conf touch /mydata/redis/node-${port}/conf/redis.conf cat /mydata/redis/node-${port}/conf/redis.conf port 6379 bind 0.0.0.0 cluster-enabled yes cluster-config-file nodes.conf cluster-node-timeout 5000 cluster-announce-ip 172.38.0.1${port} cluster-announce-port 6379 cluster-announce-bus-port 16379 appendonly yes EOF done # 通过脚本运行六个redis for port in $(seq 1 6);\\ do \\ docker run -p 6371${port}:6379 -p 1667${port}:16379 --name redis-${port} \\ -v /mydata/redis/node-${port}/data:/data \\ -v /mydata/redis/node-${port}/conf/redis.conf:/etc/redis/redis.conf \\ -d --net redis --ip 172.38.0.1${port} redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf docker run -p 6371:6379 -p 16671:16379 --name redis-1 \\ -v /mydata/redis/node-1/data:/data \\ -v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \\ -d --net redis --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf done 使用 docker ps 查看 进去其中一个 docker exec -it redis-1 /bin/sh #创建集群 redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1 #测试,不加-c是单机，加上是集群 redis-cli -c #查看集群信息 cluster info #查看节点 cluster nodes #设置a的值为\"b\" set a b #被172.38.0.13:6379处理 #停止172.38.0.13:6379 docker stop redis-3 #获取a的值 get a #发现虽然redis-3挂了，它的替补机补了上去 #查看节点 cluster nodes #发现redis-3确实挂了 发布镜像到 dockerhub #登录dockerhub docker login --help #push到dockerhub docker push 发布镜像到阿里云容器服务 #登录阿里云 #找到容器服务 #创建命名空间 #创建镜像仓库，选择本地仓库 #push到仓库 1. 登录阿里云Docker Registry $ docker login --username=df**** registry.cn-beijing.aliyuncs.com 用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。 您可以在访问凭证页面修改凭证密码。 2. 从Registry中拉取镜像 $ docker pull registry.cn-beijing.aliyuncs.com/tobabm/tobabm:[镜像版本号] 3. 将镜像推送到Registry $ docker login --username=df**** registry.cn-beijing.aliyuncs.com $ docker tag [ImageId] registry.cn-beijing.aliyuncs.com/tobabm/tobabm:[镜像版本号] $ docker push registry.cn-beijing.aliyuncs.com/tobabm/tobabm:[镜像版本号] 请根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。 4. 选择合适的镜像仓库地址 从ECS推送镜像时，可以选择使用镜像仓库内网地址。推送速度将得到提升并且将不会损耗您的公网流量。 如果您使用的机器位于VPC网络，请使用 registry-vpc.cn-beijing.aliyuncs.com 作为Registry的域名登录。 5. 示例 使用\"docker tag\"命令重命名镜像，并将它通过专有网络地址推送至Registry。 $ docker images REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE registry.aliyuncs.com/acs/agent 0.7-dfb6816 37bb9c63c8b2 7 days ago 37.89 MB $ docker tag 37bb9c63c8b2 registry-vpc.cn-beijing.aliyuncs.com/acs/agent:0.7-dfb6816 使用 \"docker push\" 命令将该镜像推送至远程。 $ docker push registry-vpc.cn-beijing.aliyuncs.com/acs/agent:0.7-dfb6816 操作系统 实战之 BusyBox busybox 是一个集成一百多个最常用 linux 命令的精简工具箱，不到 2MB 大小。 docker pull busybox docker run -it busybox 实战之 Alpine Alpine 操作系统是一个面向安全的轻型操作系统，在保持瘦身的同时，提供了包管理工具 apk。仅 5MB 左右，docker 官方推荐使用 Alpine 作为默认的基础镜像环境。 #在本地没有pull镜像的情况下，直接执行echo命令，仅需要3秒左右 time docker run alpine echo '123' Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-20 17:02:52 "},"Docker/基本.html":{"url":"Docker/基本.html","title":"基本","keywords":"","body":"基本 Docker 学习 docker ps -a // 所有容器 container docker stop/kill id(name) // 停止容器 docker run -d -p portA:portB --name YourName ImageName -d container 在后台进行 -p portA:portB 本机端口PortA 映射container端口PortB --name YourName 运行的容器名 可以不命名 ImageName 镜像名 Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-19 15:26:53 "},"Flutter/学习.html":{"url":"Flutter/学习.html","title":"学习","keywords":"","body":"Flutter 学习 类似于vue 和 react的学习方法 1 注意 dom层（简单理解 组件层 或者 是widget）flutter中所有的都是widget 2 路由信息管理 MaterialApp( initialRoute: '/', onGenerateRoute: onGenerateRoute, ); 版本 管理 fvm fvm list fvm flutter --version fvm install fvm use fvm remove Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-19 15:29:34 "},"Git/stash.html":{"url":"Git/stash.html","title":"stash","keywords":"","body":"git stash 操作 （1）git stash save \"save message\" : 执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别。 （2）git stash list ：查看stash了哪些存储 （3）git stash show ：显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@{$num}，比如第二个 git stash show stash@{1} （4）git stash show -p : 显示第一个存储的改动，如果想显示其他存存储，命令：git stash show stash@{$num} -p ，比如第二个：git stash show stash@{1} -p （5）git stash apply :应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@{0}，如果要使用其他个，git stash apply stash@{$num} ， 比如第二个：git stash apply stash@{1} （6）git stash pop ：命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@{0}，如果要应用并删除其他stash，命令：git stash pop stash@{$num} ，比如应用并删除第二个：git stash pop stash@{1} （7）git stash drop stash@{$num} ：丢弃stash@{$num}存储，从列表中删除这个存储 （8） git stash clear 删除所有缓存的stash Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-19 15:33:06 "},"Git/命令.html":{"url":"Git/命令.html","title":"命令","keywords":"","body":" 本文由 简悦 SimpRead 转码， 原文地址 www.ruanyifeng.com 我每天使用 Git ，但是很多命令记不住。 一般来说，日常使用只要记住下图 6 个命令，就可以了。但是熟练使用，恐怕要记住 60～100 个命令。 下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 一、新建代码库 # 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] # 下载一个项目和它的整个代码历史 $ git clone [url] 二、配置 Git 的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 # 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.name \"[name]\" $ git config [--global] user.email \"[email address]\" 三、增加 / 删除文件 # 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] 四、代码提交 # 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ... 五、分支 # 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] 六、标签 # 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] 七、查看信息 # 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat \"@{0 day ago}\" # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog 八、远程同步 # 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all 九、撤销 # 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop 十、其他 # 生成一个可供发布的压缩包 $ git archive Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-19 15:32:27 "},"Gulp/demo.html":{"url":"Gulp/demo.html","title":"示例","keywords":"","body":"使用 node npm 使用 查看当前目录下安装的模块 npm ls 查看所有全局安装的模块 npm ls -g npm install package 安装到当前目录下的node_modules npm install -g package 全局安装 会安装到C:\\Users\\LEO(电脑名)\\AppData\\Roaming\\npm\\node_modules 注意: windows 平台 安装时会自动生成node_modules文件夹 Mac及Linux平台 需要手动创建node_modules文件夹 否则模块会安装到磁盘根节点 因为相关包都在国外服务器，安装速度一般比较慢 所以可以考虑使用淘宝镜像,使用方法:在正常安装命令后面加上--registry=https://registry.npm.taobao.org 例如:npm install jquery --registry=https://registry.npm.taobao.org gulp 使用 gulp: 一种构建工具 安装: 先全局安装 gulp npm install -g gulp 局部安装 相关依赖 npm install gulp --save-dev 使用: 在当前目录下创建一个gulpfile.js文件 gulp 只是一个载体，只实现需要处理什么文件，保存到哪个地方等功能，具体的处理方法需要其他包或插件去完成 使用gulp需要在gulpfile文件中引入gulp,类似如在html文件中使用js文件一样需要引入js文件 var gulp = require('gulp'); // 创建任务，在gulpfile文件中书写代码 gulp.task('任务名',function(){ // 需要处理的任务 }) //在当前目录下打开命令行窗口 使用 gulp 任务名执行任务，例如任务名是test gulp test gulp 本身是一个平台，完成任务需要安装其他插件，插件搜索平台:gulpjs.com/plugins 或者 npmjs.com/package/plugins 使用gulp合并代码 安装代码合并插件 gulp-concat npm install gulp-concat --registry=https://registry.npm.taobao.org 在gulpfile中引入gulp-concat var concat = require('gulp-concat'); 创建合并任务 合并src目录下所有js文件 gulp.task('cat',function(){ 确定合并哪些文件 需要合并文件的目录 gulp.src('./src/*.js') 使用gulp-concat合并 指定合并后文件的名字 .pipe(concat('bundle.js')) // 将处理好的文件保存在dist文件夹中 .pipe(gulp.dest('./dist')); }) // 合并src下指定js文件而且可以指定合并顺序 gulp.task('cat',function(){ // 确定合并哪些文件 需要合并文件的目录 gulp.src([ './src/3.js', './src/2.js', './src/1.js' ]) // 使用gulp-concat合并 指定合并后文件的名字 .pipe(concat('bundle.js')) // 将处理好的文件保存在dist文件夹中 .pipe(gulp.dest('./dist')); }) 使用gulp压缩代码 安装代码压缩插件 gulp-uglify npm install gulp-uglify --registry=https://registry.npm.taobao.org 在gulpfile中引入gulp-concat var press = require('gulp-uglify'); //创建压缩任务 gulp.task('press',function(){ // 需要压缩的文件目录 *代表当前目录下所有js文件 也可以指定文件名 gulp.src('./dist/*.js') // 压缩函数press .pipe(press()) // 输出至output目录 .pipe(gulp.dest('./output')); }) Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-19 16:18:01 "},"JavaScript学习图谱/picture.html":{"url":"JavaScript学习图谱/picture.html","title":"图","keywords":"","body":"图谱 Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-19 16:31:50 "},"Node/Koa.js，离不开这十个中间件.html":{"url":"Node/Koa.js，离不开这十个中间件.html","title":"koa","keywords":"","body":" 本文由 简悦 SimpRead 转码， 原文地址 www.jianshu.com koa_2.png 随着ES6的普及，async/await的语法受到更多JS开发者的青睐，Koa.js作为比较早支持使用该语法的Node框架越来越受到大家的喜爱，虽然Koa.js本身支持的功能很有限，但官方和社区提供了很多各种功能的中间件，本文精选了其中的十个，对于我们开发应用程序或者框架将会特别有用。 No.1 koa-router 路由是Web框架必不可少的基础功能，koa.js为了保持自身的精简，并没有像Express.js自带了路由功能，因此koa-router做了很好的补充，作为koa星数最多的中间件，koa-router提供了全面的路由功能，比如类似Express的app.get/post/put的写法，URL命名参数、路由命名、支持加载多个中间件、嵌套路由等。其他可选路由中间件：koa-route, koa-joi-router, koa-trie-router No.2 koa-bodyparser koa.js并没有内置Request Body的解析器，当我们需要解析请求体时需要加载额外的中间件，官方提供的koa-bodyparser是个很不错的选择，支持x-www-form-urlencoded, application/json等格式的请求体，但不支持form-data的请求体，需要借助 formidable 这个库，也可以直接使用 koa-body 或 koa-better-body No.3 koa-views koa-views对需要进行视图模板渲染的应用是个不可缺少的中间件，支持ejs, nunjucks等众多模板引擎。 No.4 koa-static Node.js除了处理动态请求，也可以用作类似Nginx的静态文件服务，在本地开发时特别方便，可用于加载前端文件或后端Fake数据，可结合 koa-compress 和 koa-mount 使用。 No.5 koa-session HTTP是无状态协议，为了保持用户状态，我们一般使用Session会话，koa-session提供了这样的功能，既支持将会话信息存储在本地Cookie，也支持存储在如Redis, MongoDB这样的外部存储设备。 No.6 koa-jwt 随着网站前后端分离方案的流行，越来越多的网站从Session Base转为使用Token Base，JWT(Json Web Tokens)作为一个开放的标准被很多网站采用，koa-jwt这个中间件使用JWT认证HTTP请求。 No.7 koa-helmet 网络安全得到越来越多的重视，helmet 通过增加如Strict-Transport-Security, X-Frame-Options, X-Frame-Options等HTTP头提高Express应用程序的安全性，koa-helmet为koa程序提供了类似的功能，参考Node.js安全清单。 No.8 koa-compress 当响应体比较大时，我们一般会启用类似Gzip的压缩技术减少传输内容，koa-compress提供了这样的功能，可根据需要进行灵活的配置。 No.9 koa-logger koa-logger提供了输出请求日志的功能，包括请求的url、状态码、响应时间、响应体大小等信息，对于调试和跟踪应用程序特别有帮助，koa-bunyan-logger 提供了更丰富的功能。 No.10 koa-convert 对于比较老的使用Generate函数的koa中间件( Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-19 18:22:47 "},"Node/koa添加日志管理模块.html":{"url":"Node/koa添加日志管理模块.html","title":"日志","keywords":"","body":" 本文由 简悦 SimpRead 转码， 原文地址 www.cnblogs.com 安装log4js npm install --save log4js 新增配置文件 根目录下新建config目录 conifg目录下全为配置文件 config目录下 新建文件 logs.js var path = require('path'); //日志根目录 var baseLogPath = path.resolve(__dirname, '../logs') /*报错输出日志*/ //错误日志目录、文件名、输出完整路径 var errorPath = \"/error\"; var errorFileName = \"error\"; var errorLogPath = baseLogPath + errorPath + \"/\" + errorFileName; /*请求数据得到响应时输出响应日志*/ //响应日志目录、文件名、输出完整路径 var responsePath = \"/response\"; var responseFileName = \"response\"; var responseLogPath = baseLogPath + responsePath + \"/\" + responseFileName; /*操作数据库进行增删改等敏感操作记录日志*/ //操作日志目录、文件名、输出完整路径 var handlePath = \"/handle\"; var handleFileName = \"handle\"; var handleLogPath = baseLogPath + handlePath + \"/\" + handleFileName; module.exports = { //日志格式等设置 appenders: { \"rule-console\": {\"type\": \"console\"}, \"errorLogger\": { \"type\": \"dateFile\", \"filename\": errorLogPath, \"pattern\": \"-yyyy-MM-dd-hh.log\", \"alwaysIncludePattern\": true, \"encoding\": \"utf-8\", \"maxLogSize\": 1000, \"numBackups\": 3, \"path\": errorPath }, \"resLogger\": { \"type\": \"dateFile\", \"filename\": responseLogPath, \"pattern\": \"-yyyy-MM-dd-hh.log\", \"alwaysIncludePattern\": true, \"encoding\": \"utf-8\", \"maxLogSize\": 1000, \"numBackups\": 3, \"path\": responsePath }, \"handleLogger\": { \"type\": \"dateFile\", \"filename\": handleLogPath, \"pattern\": \"-yyyy-MM-dd-hh.log\", \"alwaysIncludePattern\": true, \"encoding\": \"utf-8\", \"maxLogSize\": 1000, \"numBackups\": 3, \"path\": responsePath }, }, //供外部调用的名称和对应设置定义 categories: { \"default\": {\"appenders\": [\"rule-console\"], \"level\": \"all\"}, \"resLogger\": {\"appenders\": [\"resLogger\"], \"level\": \"info\"}, \"errorLogger\": {\"appenders\": [\"errorLogger\"], \"level\": \"error\"}, \"handleLogger\": {\"appenders\": [\"handleLogger\"], \"level\": \"all\"}, \"http\": {\"appenders\": [\"resLogger\"], \"level\": \"info\"} }, \"baseLogPath\": baseLogPath } 增加工具方法 新建 utils 目录， utils 目录下放置工具类方法 utils 下新建 logs.js 放置输出日志的工具方法 var log4js = require('log4js'); var logsConfig = require('../config/logs.js'); //加载配置文件 log4js.configure(logsConfig); //调用预先定义的日志名称 var resLogger = log4js.getLogger(\"resLogger\"); var errorLogger = log4js.getLogger(\"errorLogger\"); var handleLogger = log4js.getLogger(\"handleLogger\"); var consoleLogger = log4js.getLogger(); // 格式化日志文本 加上日志头尾和换行方便查看 ==> 普通日志、请求日志、响应日志、操作日志、错误日志 var formatText = { info: function(info) { var logText = new String(); //响应日志头信息 logText += \"\\n\" + \"***************info log start ***************\" + \"\\n\"; //响应内容 logText += \"info detail: \" + \"\\n\" + JSON.stringify(info) + \"\\n\"; //响应日志结束信息 logText += \"*************** info log end ***************\" + \"\\n\"; return logText; }, request: function(req, resTime) { var logText = new String(); var method = req.method; //访问方法 logText += \"request method: \" + method + \"\\n\"; //请求原始地址 logText += \"request originalUrl: \" + req.originalUrl + \"\\n\"; //客户端ip logText += \"request client ip: \" + req.ip + \"\\n\"; //开始时间 var startTime; //请求参数 if (method === 'GET') { logText += \"request query: \" + JSON.stringify(req.query) + \"\\n\"; // startTime = req.query.requestStartTime; } else { logText += \"request body: \" + \"\\n\" + JSON.stringify(req.body) + \"\\n\"; // startTime = req.body.requestStartTime; } //服务器响应时间 logText += \"response time: \" + resTime + \"\\n\"; return logText; }, response: function(ctx, resTime) { var logText = new String(); //响应日志开始 logText += \"\\n\" + \"*************** response log start ***************\" + \"\\n\"; //添加请求日志 logText += formatText.request(ctx.request, resTime); //响应状态码 logText += \"response status: \" + ctx.status + \"\\n\"; //响应内容 logText += \"response body: \" + \"\\n\" + JSON.stringify(ctx.body) + \"\\n\"; //响应日志结束 logText += \"*************** response log end ***************\" + \"\\n\"; return logText; }, handle: function(info) { var logText = new String(); //响应日志开始 logText += \"\\n\" + \"***************info log start ***************\" + \"\\n\"; //响应内容 logText += \"handle info detail: \" + \"\\n\" + JSON.stringify(info).replace(/\\\\n/g, \"\\n\") + \"\\n\"; //响应日志结束 logText += \"*************** info log end ***************\" + \"\\n\"; return logText; }, error: function(ctx, err, resTime) { var logText = new String(); //错误信息开始 logText += \"\\n\" + \"*************** error log start ***************\" + \"\\n\"; //添加请求日志 logText += formatText.request(ctx.request, resTime); //错误名称 logText += \"err name: \" + err.name + \"\\n\"; //错误信息 logText += \"err message: \" + err.message + \"\\n\"; //错误详情 logText += \"err stack: \" + err.stack + \"\\n\"; //错误信息结束 logText += \"*************** error log end ***************\" + \"\\n\"; return logText; } } module.exports = { //封装普通日志 logInfo: function(info) { if (info) { consoleLogger.info(formatText.info(info)); } }, //封装响应日志 logResponse: function(ctx, resTime) { if (ctx) { resLogger.info(formatText.response(ctx, resTime)); } }, //封装操作日志 logHandle: function(res) { if (res) { handleLogger.info(formatText.handle(res)); } }, //封装错误日志 logError: function(ctx, error, resTime) { if (ctx && error) { errorLogger.error(formatText.error(ctx, error, resTime)); } } }; 改造app.js // logger const logsUtil = require('./utils/logs.js'); app.use(async (ctx, next) => { const start = new Date(); // 响应开始时间 let intervals; // 响应间隔时间 try { await next(); intervals = new Date() - start; logsUtil.logResponse(ctx, intervals); //记录响应日志 } catch (error) { intervals = new Date() - start; logsUtil.logError(ctx, error, intervals);//记录异常日志 } }) 参考资源：koa添加日志管理模块 Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-19 18:23:04 "},"Node/nodejs n 管理模块.html":{"url":"Node/nodejs n 管理模块.html","title":"n","keywords":"","body":"MAC nodejs n 管理模块 下载 npm install -g n 指令 n help n ls 列出所有版本 n xx.xx.x 安装版本 n latest 安装最新版 n stable 安装最新稳定版 n 选取已安装的版本 n rm xx.xx.x 删除某个版本 n use xx.xx.x a.js 用某个版本来运行脚本 Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-19 18:19:16 "},"Node/PM2 常用命令.html":{"url":"Node/PM2 常用命令.html","title":"koa","keywords":"","body":" 本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net 一、PM2 常用命令 假设你现在已经写好了一个 app.js 的文件，需要启动，你可以使用 pm2 进行管理 启动 pm2 start app.js pm2 start app.js --name my-api #my-api 为 PM2 进程名称 pm2 start app.js -i 0 # 根据 CPU 核数启动进程个数 pm2 start app.js --watch # 实时监控 app.js 的方式启动，当 app.js 文件有变动时，pm2 会自动 reload 查看进程 pm2 list pm2 show 0 或者 # pm2 info 0 # 查看进程详细信息，0 为 PM2 进程 id 监控 pm2 monit 停止 pm2 stop all # 停止 PM2 列表中所有的进程 pm2 stop 0 # 停止 PM2 列表中进程为 0 的进程 重载 pm2 reload all # 重载 PM2 列表中所有的进程 pm2 reload 0 # 重载 PM2 列表中进程为 0 的进程 重启 pm2 restart all # 重启 PM2 列表中所有的进程 pm2 restart 0 # 重启 PM2 列表中进程为 0 的进程 删除 PM2 进程 pm2 delete 0 # 删除 PM2 列表中进程为 0 的进程 pm2 delete all # 删除 PM2 列表中所有的进程 日志操作 pm2 logs [--raw] #Display all processes logs in streaming pm2 flush #Empty all log file pm2 reloadLogs #Reload all logs 升级 PM2 npm install pm2@lastest -g # 安装最新的 PM2 版本 pm2 updatePM2 # 升级 pm2 更多命令参数请查看帮助 pm2 --help 二、PM2 目录结构 默认的目录是：当前用于的家目录下的. pm2 目录（此目录可以自定义，请参考：五、自定义启动文件），详细信息如下： $HOME/.pm2 #will contain all PM2 related files $HOME/.pm2/logs #will contain all applications logs $HOME/.pm2/pids #will contain all applications pids $HOME/.pm2/pm2.log #PM2 logs $HOME/.pm2/pm2.pid #PM2 pid $HOME/.pm2/rpc.sock #Socket file for remote commands $HOME/.pm2/pub.sock #Socket file for publishable events $HOME/.pm2/conf.js #PM2 Configuration 三、自定义启动文件 创建一个 test.json 的示例文件，格式如下： { \"name\": \"test\", \"cwd\": \"/data/wwwroot/nodejs\", \"script\": \"./test.sh\", \"exec_interpreter\": \"bash\", \"min_uptime\": \"60s\", \"max_restarts\": 30, \"exec_mode\" : \"cluster_mode\", \"error_file\" : \"./test-err.log\", \"out_file\": \"./test-out.log\", \"pid_file\": \"./test.pid\" \"watch\": false } } 说明： apps：json 结构，apps 是一个数组，每一个数组成员就是对应一个 pm2 中运行的应用 name：应用程序的名称 cwd：应用程序所在的目录 script：应用程序的脚本路径 exec_interpreter：应用程序的脚本类型，这里使用的 shell，默认是 nodejs min_uptime：最小运行时间，这里设置的是 60s 即如果应用程序在 60s 内退出，pm2 会认为程序异常退出，此时触发重启 max_restarts 设置数量 max_restarts：设置应用程序异常退出重启的次数，默认 15 次（从 0 开始计数） exec_mode：应用程序启动模式，这里设置的是 cluster_mode（集群），默认是 fork error_file：自定义应用程序的错误日志文件 out_file：自定义应用程序日志文件 pid_file：自定义应用程序的 pid 文件 watch：是否启用监控模式，默认是 false。如果设置成 true，当应用程序变动时，pm2 会自动重载。这里也可以设置你要监控的文件。 详细参数列表：见附件八 四、实例 已上面的 test.json 为例 cat > /data/wwwroot/nodejs/test.sh !/bin/bash while : do echo \"Test\" >> 1.log sleep 5 done EOF chmod +x test.sh # 添加执行权限 pm2 start test.json # 启动，如下图： pm2 list # 查看 pm2 进程，如下图： 五、备注 其他可参数见官网：http://pm2.keymetrics.io 六、附件 FieldTypeExampleDescriptionnamestring\"myAPI\"name your app will have in PM2scriptstring\"bin/app.js\"path of your appargslist[\"--enable-logs\", \"-n\", \"15\"]arguments given to your app when it is launchednode_argslist[\"--harmony\", \"--max-stack-size=1024\"]arguments given to node when it is launchedcwdstring\"/var/www/app/prod\"the directory from which your app will be launchedexec_modestring\"cluster\"\"fork\" mode is used by default, \"cluster\" mode can be configured with instances fieldinstancesnumber4number of instances for your clustered app, 0 means as much instances as you have CPU cores. a negative value means CPU cores - value (e.g -1 on a 4 cores machine will spawn 3 instances)exec_interpreterstring\"node\"defaults to \"node\". can be \"python\", \"ruby\", \"bash\" or whatever interpreter you wish to use. \"none\" will execute your app as a binary executablelog_date_formatstring\"YYYY-MM-DD HH:mm Z\"format in which timestamps will be displayed in the logserror_filestring\"/var/log/node-app/node-app.stderr.log\"path to the specified error log file. PM2 generates one by default if not specified and you can find it by typing pm2 desc out_filestring\"/var/log/node-app/node-app.stdout.log\"path to the specified output log file. PM2 generates one by default if not specified and you can find it by typing pm2 desc pid_filestring\"pids/node-geo-api.pid\"path to the specified pid file. PM2 generates one by default if not specified and you can find it by typing pm2 desc merge_logsbooleanfalsedefaults to false. if true, it will merge logs from all instances of the same app into the same filecron_restartstring\"1 0 * * *\"a cron pattern to restart your app. only works in \"cluster\" mode for now. soon to be avaible in \"fork\" mode as wellwatchbooleantrueenables the watch feature, defaults to \"false\". if true, it will restart your app everytime a file change is detected on the folder or subfolder of your app.ignore_watchlist[\"[\\/\\\\]\\./\", \"node_modules\"]list of regex to ignore some file or folder names by the watch featuremin_uptimenumber1000min uptime of the app to be considered started (i.e. if the app crashes in this time frame, the app will only be restarted the number set in max_restarts (default 15), after that it's errored)max_restartsnumber10number of consecutive unstable restarts (less than 1sec interval or custom time via min_uptime) before your app is considered errored and stop beingmax_memory_restartstring\"150M\"your app will be restarted by PM2 if it exceeds the amount of memory specified. human-friendly format : it can be \"10M\", \"100K\", \"2G\" and so on...envobject{\"NODE_ENV\": \"production\", \"ID\": \"42\"}env variables which will appear in your appautorestartbooleanfalsetrue by default. if false, PM2 will not restart your app if it crashes or ends peacefullyvizionbooleanfalsetrue by default. if false, PM2 will start without vizion features (versioning control metadatas)post_updatelist[\"npm install\", \"echo launching the app\"]a list of commands which will be executed after you perform a Pull/Upgrade operation from Keymetrics dashboardforcebooleantruedefaults to false. if true, you can start the same script several times which is usually not allowed by PM2next_gen_jsbooleantruedefaults to false. if true, PM2 will launch your app using embedded BabelJS features which means you can run ES6/ES7 javascript coderestart_delaynumber4000time to wait before restarting a crashed app (in milliseconds). defaults to 0. Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-19 18:19:16 "},"Node/Redis 配置 _ 菜鸟教程.html":{"url":"Node/Redis 配置 _ 菜鸟教程.html","title":"redis","keywords":"","body":" 本文由 简悦 SimpRead 转码， 原文地址 www.runoob.com Redis 配置 Redis 的配置文件位于 Redis 安装目录下，文件名为 redis.conf(Windows 名为 redis.windows.conf)。 你可以通过 CONFIG 命令查看或设置配置项。 语法 Redis CONFIG 命令格式如下： redis 127.0.0.1:6379> CONFIG GET CONFIG_SETTING_NAME 实例 redis 127.0.0.1:6379> CONFIG GET loglevel 1) \"loglevel\" 2) \"notice\" 使用 * 号获取所有配置项： 实例 redis 127.0.0.1:6379> CONFIG GET * 1) \"dbfilename\" 2) \"dump.rdb\" 3) \"requirepass\" 4) \"\" 5) \"masterauth\" 6) \"\" 7) \"unixsocket\" 8) \"\" 9) \"logfile\" 10) \"\" 11) \"pidfile\" 12) \"/var/run/redis.pid\" 13) \"maxmemory\" 14) \"0\" 15) \"maxmemory-samples\" 16) \"3\" 17) \"timeout\" 18) \"0\" 19) \"tcp-keepalive\" 20) \"0\" 21) \"auto-aof-rewrite-percentage\" 22) \"100\" 23) \"auto-aof-rewrite-min-size\" 24) \"67108864\" 25) \"hash-max-ziplist-entries\" 26) \"512\" 27) \"hash-max-ziplist-value\" 28) \"64\" 29) \"list-max-ziplist-entries\" 30) \"512\" 31) \"list-max-ziplist-value\" 32) \"64\" 33) \"set-max-intset-entries\" 34) \"512\" 35) \"zset-max-ziplist-entries\" 36) \"128\" 37) \"zset-max-ziplist-value\" 38) \"64\" 39) \"hll-sparse-max-bytes\" 40) \"3000\" 41) \"lua-time-limit\" 42) \"5000\" 43) \"slowlog-log-slower-than\" 44) \"10000\" 45) \"latency-monitor-threshold\" 46) \"0\" 47) \"slowlog-max-len\" 48) \"128\" 49) \"port\" 50) \"6379\" 51) \"tcp-backlog\" 52) \"511\" 53) \"databases\" 54) \"16\" 55) \"repl-ping-slave-period\" 56) \"10\" 57) \"repl-timeout\" 58) \"60\" 59) \"repl-backlog-size\" 60) \"1048576\" 61) \"repl-backlog-ttl\" 62) \"3600\" 63) \"maxclients\" 64) \"4064\" 65) \"watchdog-period\" 66) \"0\" 67) \"slave-priority\" 68) \"100\" 69) \"min-slaves-to-write\" 70) \"0\" 71) \"min-slaves-max-lag\" 72) \"10\" 73) \"hz\" 74) \"10\" 75) \"no-appendfsync-on-rewrite\" 76) \"no\" 77) \"slave-serve-stale-data\" 78) \"yes\" 79) \"slave-read-only\" 80) \"yes\" 81) \"stop-writes-on-bgsave-error\" 82) \"yes\" 83) \"daemonize\" 84) \"no\" 85) \"rdbcompression\" 86) \"yes\" 87) \"rdbchecksum\" 88) \"yes\" 89) \"activerehashing\" 90) \"yes\" 91) \"repl-disable-tcp-nodelay\" 92) \"no\" 93) \"aof-rewrite-incremental-fsync\" 94) \"yes\" 95) \"appendonly\" 96) \"no\" 97) \"dir\" 98) \"/home/deepak/Downloads/redis-2.8.13/src\" 99) \"maxmemory-policy\" 100) \"volatile-lru\" 101) \"appendfsync\" 102) \"everysec\" 103) \"save\" 104) \"3600 1 300 100 60 10000\" 105) \"loglevel\" 106) \"notice\" 107) \"client-output-buffer-limit\" 108) \"normal 0 0 0 slave 268435456 67108864 60 pubsub 33554432 8388608 60\" 109) \"unixsocketperm\" 110) \"0\" 111) \"slaveof\" 112) \"\" 113) \"notify-keyspace-events\" 114) \"\" 115) \"bind\" 116) \"\" 编辑配置 你可以通过修改 redis.conf 文件或使用 CONFIG set 命令来修改配置。 语法 CONFIG SET 命令基本语法： redis 127.0.0.1:6379> CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE 实例 redis 127.0.0.1:6379> CONFIG SET loglevel \"notice\" OK redis 127.0.0.1:6379> CONFIG GET loglevel 1) \"loglevel\" 2) \"notice\" 参数说明 redis.conf 配置项说明如下： 序号配置项说明1daemonize noRedis 默认不是以守护进程的方式运行，可以通过该配置项修改，使用 yes 启用守护进程（Windows 不支持守护线程的配置为 no ）2pidfile /var/run/redis.pid当 Redis 以守护进程方式运行时，Redis 默认会把 pid 写入 /var/run/redis.pid 文件，可以通过 pidfile 指定3port 6379指定 Redis 监听端口，默认端口为 6379，作者在自己的一篇博文中解释了为什么选用 6379 作为默认端口，因为 6379 在手机按键上 MERZ 对应的号码，而 MERZ 取自意大利歌女 Alessia Merz 的名字4bind 127.0.0.1绑定的主机地址5timeout 300当客户端闲置多长秒后关闭连接，如果指定为 0 ，表示关闭该功能6loglevel notice指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice7logfile stdout日志记录方式，默认为标准输出，如果配置 Redis 为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给 /dev/null8databases 16设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id9save Redis 默认配置文件中提供了三个条件：save 900 1save 300 10save 60 10000分别表示 900 秒（15 分钟）内有 1 个更改，300 秒（5 分钟）内有 10 个更改以及 60 秒内有 10000 个更改。指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合10rdbcompression yes指定存储至本地数据库时是否压缩数据，默认为 yes，Redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大11dbfilename dump.rdb指定本地数据库文件名，默认值为 dump.rdb12dir ./指定本地数据库存放目录13slaveof 设置当本机为 slave 服务时，设置 master 服务的 IP 地址及端口，在 Redis 启动时，它会自动从 master 进行数据同步14masterauth 当 master 服务设置了密码保护时，slav 服务连接 master 的密码15requirepass foobared设置 Redis 连接密码，如果配置了连接密码，客户端在连接 Redis 时需要通过 AUTH 命令提供密码，默认关闭16 maxclients 128设置同一时间最大客户端连接数，默认无限制，Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息17maxmemory 指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试清除已到期或即将到期的 Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区18appendonly no指定是否在每次更新操作后进行日志记录，Redis 在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis 本身同步数据文件是按上面 save 条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为 no19appendfilename appendonly.aof指定更新日志文件名，默认为 appendonly.aof20appendfsync everysec指定更新日志条件，共有 3 个可选值：no：表示等操作系统进行数据缓存同步到磁盘（快）always：表示每次更新操作后手动调用 fsync() 将数据写到磁盘（慢，安全）everysec：表示每秒同步一次（折中，默认值）21vm-enabled no指定是否启用虚拟内存机制，默认值为 no，简单的介绍一下，VM 机制将数据分页存放，由 Redis 将访问量较少的页即冷数据 swap 到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析 Redis 的 VM 机制）22vm-swap-file /tmp/redis.swap虚拟内存文件路径，默认值为 /tmp/redis.swap，不可多个 Redis 实例共享23vm-max-memory 0将所有大于 vm-max-memory 的数据存入虚拟内存，无论 vm-max-memory 设置多小，所有索引数据都是内存存储的(Redis 的索引数据 就是 keys)，也就是说，当 vm-max-memory 设置为 0 的时候，其实是所有 value 都存在于磁盘。默认值为 024vm-page-size 32Redis swap 文件分成了很多的 page，一个对象可以保存在多个 page 上面，但一个 page 上不能被多个对象共享，vm-page-size 是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page 大小最好设置为 32 或者 64bytes；如果存储很大大对象，则可以使用更大的 page，如果不确定，就使用默认值25vm-pages 134217728设置 swap 文件中的 page 数量，由于页表（一种表示页面空闲或使用的 bitmap）是在放在内存中的，，在磁盘上每 8 个 pages 将消耗 1byte 的内存。26vm-max-threads 4设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为427glueoutputbuf yes设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启28hash-max-zipmap-entries 64 hash-max-zipmap-value 512指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法29activerehashing yes指定是否激活重置哈希，默认为开启（后面在介绍 Redis 的哈希算法时具体介绍）30include /path/to/local.conf指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件 Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-19 18:19:16 "},"其他/Wi-Fi 破解.html":{"url":"其他/Wi-Fi 破解.html","title":"wifi","keywords":"","body":"MAC 破解wifi 确保有安装macports 没有先去装macports airport airport -s 查看附近wifi 源 截取要获取的wifi CHANNEL 嗅探 airport en0 sniff channel 监听你要获取wifi 频道 需要sudo ​ Aircrack-ng 安装 sudo port selfupdate (twice) sudo port install aircrack-ng 1,2不行的情况下 可以。brew install aircrack-ng 如果有问题 看brew link aircrack-ng。此时 如果报sbin 不存在。手动创建一个存在的 sbin 目录 。 查看 查看文件 aircrack-ng *.cp 文件 找到 有handshake的 序列 破解 aircrack-ng -w .txt(字典文件).cp enter后输入序列 如果找不到 多找几个字典 继续爆破 https://blog.csdn.net/qq_39498701/article/details/104262468?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control https://blog.csdn.net/Neo_Lost/article/details/91890103 https://www.jianshu.com/p/67c0277fd5bc https://www.cnblogs.com/djjv/p/10837542.html Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-19 18:31:19 "},"前端杂项/移动端/postcss-px-to-vw.html":{"url":"前端杂项/移动端/postcss-px-to-vw.html","title":"postcss-px-vw","keywords":"","body":"移动端前端适配 postcss-px-to-viewport（px 转 vw） 概述 配置及实例 概述 前端适配困扰了很多开发人员，在 PC 端和移动端的适配，我个人认为最好的方法是开发两个界面，一个用于 PC 端，一个用于移动端，想要只开发一个界面又适用于 PC 端又适用与移动端有点太难了（个人想法，前端小白）。 然而，就算是移动端也分很多不同尺寸的移动设备啊，这时候有个很厉害的玩意东西出现了，就是 postcss-px-to-viewport，可以将单位 px 转换为 vw，vw 不是太了解，大概是根据尺寸大小会进行自动适配。话不多说直接干。 配置及实例 第一步：npm i https://github.com/evrone/postcss-px-to-viewport --save-dev，注意这里有个陷阱，下面会提到；第二步：在. postcssrc.js 中加入配置语句，.postcssrc.js 全部内容如下： module.exports = { \"plugins\": { \"postcss-import\": {}, \"postcss-url\": {}, // to edit target browsers: use \"browserslist\" field in package.json \"autoprefixer\":{}, \"postcss-px-to-viewport\": { unitToConvert: 'px', //需要转换的单位，默认为\"px\" viewportWidth: 375, //设计稿的视口宽度，一般是375左右，iphone和很多安卓机等机型都差不多，ipad除外。如果是viewportWidth是375，font-size：14，那么font-size会转换为3.73333vm，计算过程：14÷375×100=3.73333 unitPrecision: 5, //单位转换后保留的精度 propList: ['*'], //能转化为vw的属性列表 viewportUnit: 'vw', //希望使用的视口单位 fontViewportUnit: 'vw', //字体使用的视口单位 selectorBlackList: [], //需要忽略的CSS选择器，不会转为视口单位，使用原有的px等单位。 minPixelValue: 1, //设置最小的转换数值，如果为1的话，只有大于1的值会被转换 mediaQuery: false, //媒体查询里的单位是否需要转换单位 replace: true, //是否直接更换属性值，而不添加备用属性 exclude: undefined, //忽略某些文件夹下的文件或特定文件 include: /Test.vue/, //如果设置了include，那将只有匹配到的文件才会被转换 landscape: false, //是否添加根据 landscapeWidth 生成的媒体查询条件 @media (orientation: landscape) landscapeUnit: 'vw', //横屏时使用的单位 landscapeWidth: 568 //横屏时使用的视口宽度 } } } 这里可以参考官方文档：英文：https://github.com/evrone/postcss-px-to-viewport中文：https://github.com/evrone/postcss-px-to-viewport/blob/master/README_CN.md我直接把官方的配置贴出来： unitToConvert (String) 需要转换的单位，默认为 \"px\" viewportWidth (Number) 设计稿的视口宽度 unitPrecision (Number) 单位转换后保留的精度 propList (Array) 能转化为 vw 的属性列表①传入特定的 CSS 属性；②可以传入通配符 \"“去匹配所有属性，例如：[’’]；③在属性的前或后添加”\", 可以匹配特定的属性. (例如 [‘position’] 会匹配 background-position-y)④在特定属性前加 “!”，将不转换该属性的单位 . 例如: [’’,’!letter-spacing’]，将不转换 letter-spacing⑤\"!\" 和 \"\" 可以组合使用， 例如:[’’, ‘!font*’]，将不转换 font-size 以及 font-weight 等属性 viewportUnit (String) 希望使用的视口单位 fontViewportUnit (String) 字体使用的视口单位 selectorBlackList (Array) 需要忽略的 CSS 选择器，不会转为视口单位，使用原有的 px 等单位。①如果传入的值为字符串的话，只要选择器中含有传入值就会被匹配：例如 selectorBlackList 为 [‘body’] 的话， 那么. body-class 就会被忽略②如果传入的值为正则表达式的话，那么就会依据 CSS 选择器是否匹配该正则：例如 selectorBlackList 为 [/^body$/] , 那么 body 会被忽略，而 .body 不会 minPixelValue (Number) 设置最小的转换数值，如果为 1 的话，只有大于 1 的值会被转换 mediaQuery (Boolean) 媒体查询里的单位是否需要转换单位 replace (Boolean) 是否直接更换属性值，而不添加备用属性 exclude (Array or Regexp) 忽略某些文件夹下的文件或特定文件，例如’node_modules’下的文件①如果值是一个正则表达式，那么匹配这个正则的文件会被忽略；②如果传入的值是一个数组，那么数组里的值必须为正则 include (Array or Regexp) 如果设置了 include，那将只有匹配到的文件才会被转换，例如只转换’src/mobile’下的文件 (include://src/mobile//)①如果值是一个正则表达式，将包含匹配的文件，否则将排除该文件；②如果传入的值是一个数组，那么数组里的值必须为正则 landscape (Boolean) 是否添加根据 landscapeWidth 生成的媒体查询条件 @media(orientation: landscape) landscapeUnit (String) 横屏时使用的单位 landscapeWidth (Number) 横屏时使用的视口宽度 注意：①exclude 和 include 是可以一起设置的，将取两者规则的交集；②陷阱：如果你需要用到 include，那一定要用第一步中的npm i https://github.com/evrone/postcss-px-to-viewport --save-dev，而不是npm install postcss-px-to-viewport --save-dev，为什么呢？答案：include 是上个月才做的，还没有 release，但是文档已经提前更新了，所以可以先使用 github 仓库的代码，说白了用 github 仓库的可以用 include，否则 include 无效。我发布这篇文章的时间是 2020-6-28。（太坑了，我花了一天时间在找这个 bug 上）解答地址：https://github.com/evrone/postcss-px-to-viewport/issues/53③如果是 viewportWidth 是 375，且 font-size=14，那么 font-size 会转换为 3.73333vm，计算过程：14÷375×100=3.73333vm；④style 标签内嵌 CSS 样式是不会发生转换的，如：style：“font-size: 14px”，它不会转换为 style：“font-size: 3.73333vm” 的。 第三步：写前端代码。 我是Test export default { name: 'Test', } .test{ height: 40px; background: #87CEFA; font-size: 14px; } css 变化:宽度是 375 时：宽度是 578 时：可以看到 font-size 由 14px 转变为 3.73333vm 了（怎么算的呢？14÷375×100=3.73333）。变化缩放宽度，会发现字体大小会随着宽度自适应变化（图片效果不明显，看不太出来，自己动手丰衣足食）。 参考网址：https://github.com/evrone/postcss-px-to-viewporthttps://github.com/evrone/postcss-px-to-viewport/blob/master/README_CN.mdhttps://github.com/evrone/postcss-px-to-viewport/issues/53 Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-19 18:37:33 "},"前端杂项/Error.html":{"url":"前端杂项/Error.html","title":"Error","keywords":"","body":"Error 一般处理 Window.onerror= ()=>{} 处理 一般类型错误 windonw.addEventlister('error',()=>{}) 由于一些资源类型请求出错 如 image 回给自己的onerror事件。并且不回冒泡 这个时候 可以用这个 原生Fetch 请求错误 ​ 监听不为200 的错误 可以去做拦截处理 axios请求错误 promise 为处理catch的方法 window.addEventlistener（\"unhandledrejection\",()=>{}） React 项目错误处理 ErrorBundary处理 要包裹子组件 componentDidCatch (err) {} 不同域名下js错误 客户端 设置额 服务端 静态资源设置响应头 Access-Control-Allow-Origin: * Fed-monitor-sdk Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-19 18:32:39 "},"前端杂项/JSON.parse实现深拷贝的弊端.html":{"url":"前端杂项/JSON.parse实现深拷贝的弊端.html","title":"JSON拷贝","keywords":"","body":"> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [blog.csdn.net](https://blog.csdn.net/u013565133/article/details/102819929) 这句话待严谨：javaScript 存储对象都是存地址的，所以浅拷贝会导致 obj1 和 obj2 指向同一块内存地址。改变了其中一方的内容，都是在原来的内存上做修改会导致拷贝对象和源对象都发生改变，而深拷贝是开辟一块新的内存地址，将原对象的各个属性逐个复制进去。对拷贝对象和源对象各自的操作互不影响。 JSON.parse(JSON.stringify(obj))我们一般用来深拷贝，其过程说白了 就是利用JSON.stringify 将 js 对象序列化（JSON字符串），再使用JSON.parse来反序列化 (还原)js 对象；序列化的作用是存储(对象本身存储的只是一个地址映射，如果断电，对象将不复存在，因此需将对象的内容转换成字符串的形式再保存在磁盘上 ) 和传输（例如 如果请求的Content-Type是 application/x-www-form-urlencoded，则前端这边需要使用qs.stringify(data)来序列化参数再传给后端，否则后端接受不到； ps: Content-Type 为 application/json;charset=UTF-8或者 multipart/form-data 则可以不需要 ）。 我们在使用 JSON.parse(JSON.stringify(xxx)) 时应该注意一下几点： 1、如果 obj 里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式。而不是时间对象； var test = { name: 'a', date: \\[new Date(1536627600000), new Date(1540047600000)\\], }; let b; b = JSON.parse(JSON.stringify(test)) 2、如果 obj 里有RegExp、Error对象，则序列化的结果将只得到空对象； const test = { name: 'a', date: new RegExp('\\\\\\\\w+'), }; // debugger const copyed = JSON.parse(JSON.stringify(test)); test.name = 'test' console.error('ddd', test, copyed) 3、如果 obj 里有函数，undefined，则序列化的结果会把函数或 undefined 丢失； const test = { name: 'a', date: function hehe() { console.log('fff') }, }; // debugger const copyed = JSON.parse(JSON.stringify(test)); test.name = 'test' console.error('ddd', test, copyed) 4、如果 obj 里有 NaN、Infinity 和 - Infinity，则序列化的结果会变成 null 5、JSON.stringify()只能序列化对象的可枚举的自有属性，例如 如果 obj 中的对象是有构造函数生成的， 则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的constructor； function Person(name) { this.name = name; console.log(name) } const liai = new Person('liai'); const test = { name: 'a', date: liai, }; // debugger const copyed = JSON.parse(JSON.stringify(test)); test.name = 'test' console.error('ddd', test, copyed) 6、如果对象中存在循环引用的情况也无法正确实现深拷贝； 以上，如果拷贝的对象不涉及上面讲的情况，可以使用JSON.parse(JSON.stringify(obj))实现深拷贝，但是涉及到上面的情况，可以考虑使用如下方法实现深拷贝： //实现深拷贝函数 function deepClone(data) { const type = this.judgeType(data); let obj = null; if (type == 'array') { obj = \\[\\]; for (let i = 0; i Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-19 18:40:59 "},"前端杂项/MIME.html":{"url":"前端杂项/MIME.html","title":"MIME","keywords":"","body":"MIME 格式前面为后辍名，后面为对应的MIME型（例如：rar application/x-rar-compressed 表示。RAR对应的是application/x-rar-compressed ） { \".323\", \"text/h323\" }, { \".3gp\", \"video/3gpp\" }, { \".aab\", \"application/x-authoware-bin\" }, { \".aam\", \"application/x-authoware-map\" }, { \".aas\", \"application/x-authoware-seg\" }, { \".acx\", \"application/internet-property-stream\" }, { \".ai\", \"application/postscript\" }, { \".aif\", \"audio/x-aiff\" }, { \".aifc\", \"audio/x-aiff\" }, { \".aiff\", \"audio/x-aiff\" }, { \".als\", \"audio/X-Alpha5\" }, { \".amc\", \"application/x-mpeg\" }, { \".ani\", \"application/octet-stream\" }, { \".apk\", \"application/vnd.android.package-archive\" }, { \".asc\", \"text/plain\" }, { \".asd\", \"application/astound\" }, { \".asf\", \"video/x-ms-asf\" }, { \".asn\", \"application/astound\" }, { \".asp\", \"application/x-asap\" }, { \".asr\", \"video/x-ms-asf\" }, { \".asx\", \"video/x-ms-asf\" }, { \".au\", \"audio/basic\" }, { \".avb\", \"application/octet-stream\" }, { \".avi\", \"video/x-msvideo\" }, { \".awb\", \"audio/amr-wb\" }, { \".axs\", \"application/olescript\" }, { \".bas\", \"text/plain\" }, { \".bcpio\", \"application/x-bcpio\" }, { \".bin \", \"application/octet-stream\" }, { \".bld\", \"application/bld\" }, { \".bld2\", \"application/bld2\" }, { \".bmp\", \"image/bmp\" }, { \".bpk\", \"application/octet-stream\" }, { \".bz2\", \"application/x-bzip2\" }, { \".c\", \"text/plain\" }, { \".cal\", \"image/x-cals\" }, { \".cat\", \"application/vnd.ms-pkiseccat\" }, { \".ccn\", \"application/x-cnc\" }, { \".cco\", \"application/x-cocoa\" }, { \".cdf\", \"application/x-cdf\" }, { \".cer\", \"application/x-x509-ca-cert\" }, { \".cgi\", \"magnus-internal/cgi\" }, { \".chat\", \"application/x-chat\" }, { \".class\", \"application/octet-stream\" }, { \".clp\", \"application/x-msclip\" }, { \".cmx\", \"image/x-cmx\" }, { \".co\", \"application/x-cult3d-object\" }, { \".cod\", \"image/cis-cod\" }, { \".conf\", \"text/plain\" }, { \".cpio\", \"application/x-cpio\" }, { \".cpp\", \"text/plain\" }, { \".cpt\", \"application/mac-compactpro\" }, { \".crd\", \"application/x-mscardfile\" }, { \".crl\", \"application/pkix-crl\" }, { \".crt\", \"application/x-x509-ca-cert\" }, { \".csh\", \"application/x-csh\" }, { \".csm\", \"chemical/x-csml\" }, { \".csml\", \"chemical/x-csml\" }, { \".css\", \"text/css\" }, { \".cur\", \"application/octet-stream\" }, { \".dcm\", \"x-lml/x-evm\" }, { \".dcr\", \"application/x-director\" }, { \".dcx\", \"image/x-dcx\" }, { \".der\", \"application/x-x509-ca-cert\" }, { \".dhtml\", \"text/html\" }, { \".dir\", \"application/x-director\" }, { \".dll\", \"application/x-msdownload\" }, { \".dmg\", \"application/octet-stream\" }, { \".dms\", \"application/octet-stream\" }, { \".doc\", \"application/msword\" }, { \".docx\", \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\" }, { \".dot\", \"application/msword\" }, { \".dvi\", \"application/x-dvi\" }, { \".dwf\", \"drawing/x-dwf\" }, { \".dwg\", \"application/x-autocad\" }, { \".dxf\", \"application/x-autocad\" }, { \".dxr\", \"application/x-director\" }, { \".ebk\", \"application/x-expandedbook\" }, { \".emb\", \"chemical/x-embl-dl-nucleotide\" }, { \".embl\", \"chemical/x-embl-dl-nucleotide\" }, { \".eps\", \"application/postscript\" }, { \".epub\", \"application/epub+zip\" }, { \".eri\", \"image/x-eri\" }, { \".es\", \"audio/echospeech\" }, { \".esl\", \"audio/echospeech\" }, { \".etc\", \"application/x-earthtime\" }, { \".etx\", \"text/x-setext\" }, { \".evm\", \"x-lml/x-evm\" }, { \".evy\", \"application/envoy\" }, { \".exe\", \"application/octet-stream\" }, { \".fh4\", \"image/x-freehand\" }, { \".fh5\", \"image/x-freehand\" }, { \".fhc\", \"image/x-freehand\" }, { \".fif\", \"application/fractals\" }, { \".flr\", \"x-world/x-vrml\" }, { \".flv\", \"flv-application/octet-stream\" }, { \".fm\", \"application/x-maker\" }, { \".fpx\", \"image/x-fpx\" }, { \".fvi\", \"video/isivideo\" }, { \".gau\", \"chemical/x-gaussian-input\" }, { \".gca\", \"application/x-gca-compressed\" }, { \".gdb\", \"x-lml/x-gdb\" }, { \".gif\", \"image/gif\" }, { \".gps\", \"application/x-gps\" }, { \".gtar\", \"application/x-gtar\" }, { \".gz\", \"application/x-gzip\" }, { \".h\", \"text/plain\" }, { \".hdf\", \"application/x-hdf\" }, { \".hdm\", \"text/x-hdml\" }, { \".hdml\", \"text/x-hdml\" }, { \".hlp\", \"application/winhlp\" }, { \".hqx\", \"application/mac-binhex40\" }, { \".hta\", \"application/hta\" }, { \".htc\", \"text/x-component\" }, { \".htm\", \"text/html\" }, { \".html\", \"text/html\" }, { \".hts\", \"text/html\" }, { \".htt\", \"text/webviewhtml\" }, { \".ice\", \"x-conference/x-cooltalk\" }, { \".ico\", \"image/x-icon\" }, { \".ief\", \"image/ief\" }, { \".ifm\", \"image/gif\" }, { \".ifs\", \"image/ifs\" }, { \".iii\", \"application/x-iphone\" }, { \".imy\", \"audio/melody\" }, { \".ins\", \"application/x-internet-signup\" }, { \".ips\", \"application/x-ipscript\" }, { \".ipx\", \"application/x-ipix\" }, { \".isp\", \"application/x-internet-signup\" }, { \".it\", \"audio/x-mod\" }, { \".itz\", \"audio/x-mod\" }, { \".ivr\", \"i-world/i-vrml\" }, { \".j2k\", \"image/j2k\" }, { \".jad\", \"text/vnd.sun.j2me.app-descriptor\" }, { \".jam\", \"application/x-jam\" }, { \".jar\", \"application/java-archive\" }, { \".java\", \"text/plain\" }, { \".jfif\", \"image/pipeg\" }, { \".jnlp\", \"application/x-java-jnlp-file\" }, { \".jpe\", \"image/jpeg\" }, { \".jpeg\", \"image/jpeg\" }, { \".jpg\", \"image/jpeg\" }, { \".jpz\", \"image/jpeg\" }, { \".js\", \"application/x-javascript\" }, { \".jwc\", \"application/jwc\" }, { \".kjx\", \"application/x-kjx\" }, { \".lak\", \"x-lml/x-lak\" }, { \".latex\", \"application/x-latex\" }, { \".lcc\", \"application/fastman\" }, { \".lcl\", \"application/x-digitalloca\" }, { \".lcr\", \"application/x-digitalloca\" }, { \".lgh\", \"application/lgh\" }, { \".lha\", \"application/octet-stream\" }, { \".lml\", \"x-lml/x-lml\" }, { \".lmlpack\", \"x-lml/x-lmlpack\" }, { \".log\", \"text/plain\" }, { \".lsf\", \"video/x-la-asf\" }, { \".lsx\", \"video/x-la-asf\" }, { \".lzh\", \"application/octet-stream\" }, { \".m13\", \"application/x-msmediaview\" }, { \".m14\", \"application/x-msmediaview\" }, { \".m15\", \"audio/x-mod\" }, { \".m3u\", \"audio/x-mpegurl\" }, { \".m3url\", \"audio/x-mpegurl\" }, { \".m4a\", \"audio/mp4a-latm\" }, { \".m4b\", \"audio/mp4a-latm\" }, { \".m4p\", \"audio/mp4a-latm\" }, { \".m4u\", \"video/vnd.mpegurl\" }, { \".m4v\", \"video/x-m4v\" }, { \".ma1\", \"audio/ma1\" }, { \".ma2\", \"audio/ma2\" }, { \".ma3\", \"audio/ma3\" }, { \".ma5\", \"audio/ma5\" }, { \".man\", \"application/x-troff-man\" }, { \".map\", \"magnus-internal/imagemap\" }, { \".mbd\", \"application/mbedlet\" }, { \".mct\", \"application/x-mascot\" }, { \".mdb\", \"application/x-msaccess\" }, { \".mdz\", \"audio/x-mod\" }, { \".me\", \"application/x-troff-me\" }, { \".mel\", \"text/x-vmel\" }, { \".mht\", \"message/rfc822\" }, { \".mhtml\", \"message/rfc822\" }, { \".mi\", \"application/x-mif\" }, { \".mid\", \"audio/mid\" }, { \".midi\", \"audio/midi\" }, { \".mif\", \"application/x-mif\" }, { \".mil\", \"image/x-cals\" }, { \".mio\", \"audio/x-mio\" }, { \".mmf\", \"application/x-skt-lbs\" }, { \".mng\", \"video/x-mng\" }, { \".mny\", \"application/x-msmoney\" }, { \".moc\", \"application/x-mocha\" }, { \".mocha\", \"application/x-mocha\" }, { \".mod\", \"audio/x-mod\" }, { \".mof\", \"application/x-yumekara\" }, { \".mol\", \"chemical/x-mdl-molfile\" }, { \".mop\", \"chemical/x-mopac-input\" }, { \".mov\", \"video/quicktime\" }, { \".movie\", \"video/x-sgi-movie\" }, { \".mp2\", \"video/mpeg\" }, { \".mp3\", \"audio/mpeg\" }, { \".mp4\", \"video/mp4\" }, { \".mpa\", \"video/mpeg\" }, { \".mpc\", \"application/vnd.mpohun.certificate\" }, { \".mpe\", \"video/mpeg\" }, { \".mpeg\", \"video/mpeg\" }, { \".mpg\", \"video/mpeg\" }, { \".mpg4\", \"video/mp4\" }, { \".mpga\", \"audio/mpeg\" }, { \".mpn\", \"application/vnd.mophun.application\" }, { \".mpp\", \"application/vnd.ms-project\" }, { \".mps\", \"application/x-mapserver\" }, { \".mpv2\", \"video/mpeg\" }, { \".mrl\", \"text/x-mrml\" }, { \".mrm\", \"application/x-mrm\" }, { \".ms\", \"application/x-troff-ms\" }, { \".msg\", \"application/vnd.ms-outlook\" }, { \".mts\", \"application/metastream\" }, { \".mtx\", \"application/metastream\" }, { \".mtz\", \"application/metastream\" }, { \".mvb\", \"application/x-msmediaview\" }, { \".mzv\", \"application/metastream\" }, { \".nar\", \"application/zip\" }, { \".nbmp\", \"image/nbmp\" }, { \".nc\", \"application/x-netcdf\" }, { \".ndb\", \"x-lml/x-ndb\" }, { \".ndwn\", \"application/ndwn\" }, { \".nif\", \"application/x-nif\" }, { \".nmz\", \"application/x-scream\" }, { \".nokia-op-logo\", \"image/vnd.nok-oplogo-color\" }, { \".npx\", \"application/x-netfpx\" }, { \".nsnd\", \"audio/nsnd\" }, { \".nva\", \"application/x-neva1\" }, { \".nws\", \"message/rfc822\" }, { \".oda\", \"application/oda\" }, { \".ogg\", \"audio/ogg\" }, { \".oom\", \"application/x-AtlasMate-Plugin\" }, { \".p10\", \"application/pkcs10\" }, { \".p12\", \"application/x-pkcs12\" }, { \".p7b\", \"application/x-pkcs7-certificates\" }, { \".p7c\", \"application/x-pkcs7-mime\" }, { \".p7m\", \"application/x-pkcs7-mime\" }, { \".p7r\", \"application/x-pkcs7-certreqresp\" }, { \".p7s\", \"application/x-pkcs7-signature\" }, { \".pac\", \"audio/x-pac\" }, { \".pae\", \"audio/x-epac\" }, { \".pan\", \"application/x-pan\" }, { \".pbm\", \"image/x-portable-bitmap\" }, { \".pcx\", \"image/x-pcx\" }, { \".pda\", \"image/x-pda\" }, { \".pdb\", \"chemical/x-pdb\" }, { \".pdf\", \"application/pdf\" }, { \".pfr\", \"application/font-tdpfr\" }, { \".pfx\", \"application/x-pkcs12\" }, { \".pgm\", \"image/x-portable-graymap\" }, { \".pict\", \"image/x-pict\" }, { \".pko\", \"application/ynd.ms-pkipko\" }, { \".pm\", \"application/x-perl\" }, { \".pma\", \"application/x-perfmon\" }, { \".pmc\", \"application/x-perfmon\" }, { \".pmd\", \"application/x-pmd\" }, { \".pml\", \"application/x-perfmon\" }, { \".pmr\", \"application/x-perfmon\" }, { \".pmw\", \"application/x-perfmon\" }, { \".png\", \"image/png\" }, { \".pnm\", \"image/x-portable-anymap\" }, { \".pnz\", \"image/png\" }, { \".pot,\", \"application/vnd.ms-powerpoint\" }, { \".ppm\", \"image/x-portable-pixmap\" }, { \".pps\", \"application/vnd.ms-powerpoint\" }, { \".ppt\", \"application/vnd.ms-powerpoint\" }, { \".pptx\", \"application/vnd.openxmlformats-officedocument.presentationml.presentation\" }, { \".pqf\", \"application/x-cprplayer\" }, { \".pqi\", \"application/cprplayer\" }, { \".prc\", \"application/x-prc\" }, { \".prf\", \"application/pics-rules\" }, { \".prop\", \"text/plain\" }, { \".proxy\", \"application/x-ns-proxy-autoconfig\" }, { \".ps\", \"application/postscript\" }, { \".ptlk\", \"application/listenup\" }, { \".pub\", \"application/x-mspublisher\" }, { \".pvx\", \"video/x-pv-pvx\" }, { \".qcp\", \"audio/vnd.qcelp\" }, { \".qt\", \"video/quicktime\" }, { \".qti\", \"image/x-quicktime\" }, { \".qtif\", \"image/x-quicktime\" }, { \".r3t\", \"text/vnd.rn-realtext3d\" }, { \".ra\", \"audio/x-pn-realaudio\" }, { \".ram\", \"audio/x-pn-realaudio\" }, { \".rar\", \"application/octet-stream\" }, { \".ras\", \"image/x-cmu-raster\" }, { \".rc\", \"text/plain\" }, { \".rdf\", \"application/rdf+xml\" }, { \".rf\", \"image/vnd.rn-realflash\" }, { \".rgb\", \"image/x-rgb\" }, { \".rlf\", \"application/x-richlink\" }, { \".rm\", \"audio/x-pn-realaudio\" }, { \".rmf\", \"audio/x-rmf\" }, { \".rmi\", \"audio/mid\" }, { \".rmm\", \"audio/x-pn-realaudio\" }, { \".rmvb\", \"audio/x-pn-realaudio\" }, { \".rnx\", \"application/vnd.rn-realplayer\" }, { \".roff\", \"application/x-troff\" }, { \".rp\", \"image/vnd.rn-realpix\" }, { \".rpm\", \"audio/x-pn-realaudio-plugin\" }, { \".rt\", \"text/vnd.rn-realtext\" }, { \".rte\", \"x-lml/x-gps\" }, { \".rtf\", \"application/rtf\" }, { \".rtg\", \"application/metastream\" }, { \".rtx\", \"text/richtext\" }, { \".rv\", \"video/vnd.rn-realvideo\" }, { \".rwc\", \"application/x-rogerwilco\" }, { \".s3m\", \"audio/x-mod\" }, { \".s3z\", \"audio/x-mod\" }, { \".sca\", \"application/x-supercard\" }, { \".scd\", \"application/x-msschedule\" }, { \".sct\", \"text/scriptlet\" }, { \".sdf\", \"application/e-score\" }, { \".sea\", \"application/x-stuffit\" }, { \".setpay\", \"application/set-payment-initiation\" }, { \".setreg\", \"application/set-registration-initiation\" }, { \".sgm\", \"text/x-sgml\" }, { \".sgml\", \"text/x-sgml\" }, { \".sh\", \"application/x-sh\" }, { \".shar\", \"application/x-shar\" }, { \".shtml\", \"magnus-internal/parsed-html\" }, { \".shw\", \"application/presentations\" }, { \".si6\", \"image/si6\" }, { \".si7\", \"image/vnd.stiwap.sis\" }, { \".si9\", \"image/vnd.lgtwap.sis\" }, { \".sis\", \"application/vnd.symbian.install\" }, { \".sit\", \"application/x-stuffit\" }, { \".skd\", \"application/x-Koan\" }, { \".skm\", \"application/x-Koan\" }, { \".skp\", \"application/x-Koan\" }, { \".skt\", \"application/x-Koan\" }, { \".slc\", \"application/x-salsa\" }, { \".smd\", \"audio/x-smd\" }, { \".smi\", \"application/smil\" }, { \".smil\", \"application/smil\" }, { \".smp\", \"application/studiom\" }, { \".smz\", \"audio/x-smd\" }, { \".snd\", \"audio/basic\" }, { \".spc\", \"application/x-pkcs7-certificates\" }, { \".spl\", \"application/futuresplash\" }, { \".spr\", \"application/x-sprite\" }, { \".sprite\", \"application/x-sprite\" }, { \".sdp\", \"application/sdp\" }, { \".spt\", \"application/x-spt\" }, { \".src\", \"application/x-wais-source\" }, { \".sst\", \"application/vnd.ms-pkicertstore\" }, { \".stk\", \"application/hyperstudio\" }, { \".stl\", \"application/vnd.ms-pkistl\" }, { \".stm\", \"text/html\" }, { \".svg\", \"image/svg+xml\" }, { \".sv4cpio\", \"application/x-sv4cpio\" }, { \".sv4crc\", \"application/x-sv4crc\" }, { \".svf\", \"image/vnd\" }, { \".svg\", \"image/svg+xml\" }, { \".svh\", \"image/svh\" }, { \".svr\", \"x-world/x-svr\" }, { \".swf\", \"application/x-shockwave-flash\" }, { \".swfl\", \"application/x-shockwave-flash\" }, { \".t\", \"application/x-troff\" }, { \".tad\", \"application/octet-stream\" }, { \".talk\", \"text/x-speech\" }, { \".tar\", \"application/x-tar\" }, { \".taz\", \"application/x-tar\" }, { \".tbp\", \"application/x-timbuktu\" }, { \".tbt\", \"application/x-timbuktu\" }, { \".tcl\", \"application/x-tcl\" }, { \".tex\", \"application/x-tex\" }, { \".texi\", \"application/x-texinfo\" }, { \".texinfo\", \"application/x-texinfo\" }, { \".tgz\", \"application/x-compressed\" }, { \".thm\", \"application/vnd.eri.thm\" }, { \".tif\", \"image/tiff\" }, { \".tiff\", \"image/tiff\" }, { \".tki\", \"application/x-tkined\" }, { \".tkined\", \"application/x-tkined\" }, { \".toc\", \"application/toc\" }, { \".toy\", \"image/toy\" }, { \".tr\", \"application/x-troff\" }, { \".trk\", \"x-lml/x-gps\" }, { \".trm\", \"application/x-msterminal\" }, { \".tsi\", \"audio/tsplayer\" }, { \".tsp\", \"application/dsptype\" }, { \".tsv\", \"text/tab-separated-values\" }, { \".ttf\", \"application/octet-stream\" }, { \".ttz\", \"application/t-time\" }, { \".txt\", \"text/plain\" }, { \".uls\", \"text/iuls\" }, { \".ult\", \"audio/x-mod\" }, { \".ustar\", \"application/x-ustar\" }, { \".uu\", \"application/x-uuencode\" }, { \".uue\", \"application/x-uuencode\" }, { \".vcd\", \"application/x-cdlink\" }, { \".vcf\", \"text/x-vcard\" }, { \".vdo\", \"video/vdo\" }, { \".vib\", \"audio/vib\" }, { \".viv\", \"video/vivo\" }, { \".vivo\", \"video/vivo\" }, { \".vmd\", \"application/vocaltec-media-desc\" }, { \".vmf\", \"application/vocaltec-media-file\" }, { \".vmi\", \"application/x-dreamcast-vms-info\" }, { \".vms\", \"application/x-dreamcast-vms\" }, { \".vox\", \"audio/voxware\" }, { \".vqe\", \"audio/x-twinvq-plugin\" }, { \".vqf\", \"audio/x-twinvq\" }, { \".vql\", \"audio/x-twinvq\" }, { \".vre\", \"x-world/x-vream\" }, { \".vrml\", \"x-world/x-vrml\" }, { \".vrt\", \"x-world/x-vrt\" }, { \".vrw\", \"x-world/x-vream\" }, { \".vts\", \"workbook/formulaone\" }, { \".wav\", \"audio/x-wav\" }, { \".wax\", \"audio/x-ms-wax\" }, { \".wbmp\", \"image/vnd.wap.wbmp\" }, { \".wcm\", \"application/vnd.ms-works\" }, { \".wdb\", \"application/vnd.ms-works\" }, { \".web\", \"application/vnd.xara\" }, { \".wi\", \"image/wavelet\" }, { \".wis\", \"application/x-InstallShield\" }, { \".wks\", \"application/vnd.ms-works\" }, { \".wm\", \"video/x-ms-wm\" }, { \".wma\", \"audio/x-ms-wma\" }, { \".wmd\", \"application/x-ms-wmd\" }, { \".wmf\", \"application/x-msmetafile\" }, { \".wml\", \"text/vnd.wap.wml\" }, { \".wmlc\", \"application/vnd.wap.wmlc\" }, { \".wmls\", \"text/vnd.wap.wmlscript\" }, { \".wmlsc\", \"application/vnd.wap.wmlscriptc\" }, { \".wmlscript\", \"text/vnd.wap.wmlscript\" }, { \".wmv\", \"audio/x-ms-wmv\" }, { \".wmx\", \"video/x-ms-wmx\" }, { \".wmz\", \"application/x-ms-wmz\" }, { \".wpng\", \"image/x-up-wpng\" }, { \".wps\", \"application/vnd.ms-works\" }, { \".wpt\", \"x-lml/x-gps\" }, { \".wri\", \"application/x-mswrite\" }, { \".wrl\", \"x-world/x-vrml\" }, { \".wrz\", \"x-world/x-vrml\" }, { \".ws\", \"text/vnd.wap.wmlscript\" }, { \".wsc\", \"application/vnd.wap.wmlscriptc\" }, { \".wv\", \"video/wavelet\" }, { \".wvx\", \"video/x-ms-wvx\" }, { \".wxl\", \"application/x-wxl\" }, { \".x-gzip\", \"application/x-gzip\" }, { \".xaf\", \"x-world/x-vrml\" }, { \".xar\", \"application/vnd.xara\" }, { \".xbm\", \"image/x-xbitmap\" }, { \".xdm\", \"application/x-xdma\" }, { \".xdma\", \"application/x-xdma\" }, { \".xdw\", \"application/vnd.fujixerox.docuworks\" }, { \".xht\", \"application/xhtml+xml\" }, { \".xhtm\", \"application/xhtml+xml\" }, { \".xhtml\", \"application/xhtml+xml\" }, { \".xla\", \"application/vnd.ms-excel\" }, { \".xlc\", \"application/vnd.ms-excel\" }, { \".xll\", \"application/x-excel\" }, { \".xlm\", \"application/vnd.ms-excel\" }, { \".xls\", \"application/vnd.ms-excel\" }, { \".xlsx\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\" }, { \".xlt\", \"application/vnd.ms-excel\" }, { \".xlw\", \"application/vnd.ms-excel\" }, { \".xm\", \"audio/x-mod\" }, {\".xml\",\"text/plain\"}, {\".xml\",\"application/xml\"}, [1] { \".xmz\", \"audio/x-mod\" }, { \".xof\", \"x-world/x-vrml\" }, { \".xpi\", \"application/x-xpinstall\" }, { \".xpm\", \"image/x-xpixmap\" }, { \".xsit\", \"text/xml\" }, { \".xsl\", \"text/xml\" }, { \".xul\", \"text/xul\" }, { \".xwd\", \"image/x-xwindowdump\" }, { \".xyz\", \"chemical/x-pdb\" }, { \".yz1\", \"application/x-yz1\" }, { \".z\", \"application/x-compress\" }, { \".zac\", \"application/x-zaurus-zac\" }, { \".zip\", \"application/zip\" }, { \".json\", \"application/json\" } Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-19 18:32:39 "},"前端杂项/个人总结.html":{"url":"前端杂项/个人总结.html","title":"个人总结","keywords":"","body":"前端技术 html,css 语义化结构 方便seo css less sass styl。熟悉一个最起码要了解学习 页面的重绘 回流 理解 回流一定重绘 js 技术栈 原生 Es5 es6 用过的数组方法 Array.filter Array.includes Array.map Array.forEach Array.some Array.every Array.reduce var let const 结构复制 数据浅拷贝 深拷贝 Object.assign() ....Object.keys() Object.values() Object.entires() 了解节流 和 防抖 promise async await eslint 代码控制 有时间可以看typescript 框架 vue 语法糖 v-model 双向数据绑定原理 Object.define() set get 组件化 组件通讯 父子 兄弟 全局 prop emit bus=new Vue(). Veux 全局（模块） 生命周期 缓存keep-alive 动态路由 过滤相关路由 路由守卫 react 生命周期 hooks componentwillMount componentWillUnmout componentWillUpdate useState useEffect useContext useReducer useMemo useRef 自定义（就是包裹上面 自己定义相关） 没有了 相关双向绑定 要自己去实现 onInput react-router-dom 学习了解路由 redux 熟悉react 的状态机 webpack 了解基本概念。entry output plugins loder 掌握一定 vuecli3 的 自定义配置 vue.config.js 处理相关js loader 缓存部分第三方插件 开发 打包优化的一些处理方式 mobile rem ，vw meta标签 图片优化 svg 或者精灵图 或者 tinypng 上线优化 js 压缩 图片精灵图或者压缩 gzip 服务端要开启 一般是在nginx设置也行了 协调后端减少http请求 假如第三方外链cdn 数据本地缓存 localStorage sessionStorage Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-19 18:44:19 "},"前端杂项/优化.html":{"url":"前端杂项/优化.html","title":"优化","keywords":"","body":"优化 上线 初始阶段nginx目录 xx.html xx.css xx.js 如果xx.js更新，客户端会有缓存， 拿到的 js 还是 原来的。但是html 已经是新的 阶段2 nginx目录 xx.html xx.css xx.js j s,css 接入 version 会产生没有变化的js也重新加载。hash 是针对内容变化后更新 阶段3 Nginx Index.html Cdn 静态资源（xx.js xx.css） 先部署 html 还是静态资源 都会让 客户端请求出错 有风险 所以 Cdn xx.hash.js 每次部署上线文件名都不一样 不会报错 Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-19 18:54:04 "},"前端杂项/前端性能优化24条建议.html":{"url":"前端杂项/前端性能优化24条建议.html","title":"性能优化","keywords":"","body":" 本文由 简悦 SimpRead 转码， 原文地址 mp.weixin.qq.com 性能优化是把双刃剑，有好的一面也有坏的一面。好的一面就是能提升网站性能，坏的一面就是配置麻烦，或者要遵守的规则太多。并且某些性能优化规则并不适用所有场景，需要谨慎使用，请读者带着批判性的眼光来阅读本文。 1. 减少 HTTP 请求 一个完整的 HTTP 请求需要经历 DNS 查找，TCP 握手，浏览器发出 HTTP 请求，服务器接收请求，服务器处理请求并发回响应，浏览器接收响应等过程。接下来看一个具体的例子帮助理解 HTTP ： 这是一个 HTTP 请求，请求的文件大小为 28.4KB。 名词解释： Queueing: 在请求队列中的时间。 Stalled: 从TCP 连接建立完成，到真正可以传输数据之间的时间差，此时间包括代理协商时间。 Proxy negotiation: 与代理服务器连接进行协商所花费的时间。 DNS Lookup: 执行DNS查找所花费的时间，页面上的每个不同的域都需要进行DNS查找。 Initial Connection / Connecting: 建立连接所花费的时间，包括TCP握手/重试和协商SSL。 SSL: 完成SSL握手所花费的时间。 Request sent: 发出网络请求所花费的时间，通常为一毫秒的时间。 Waiting(TFFB): TFFB 是发出页面请求到接收到应答数据第一个字节的时间。 Content Download: 接收响应数据所花费的时间。 从这个例子可以看出，真正下载数据的时间占比为 13.05 / 204.16 = 6.39%，文件越小，这个比例越小，文件越大，比例就越高。这就是为什么要建议将多个小文件合并为一个大文件，从而减少 HTTP 请求次数的原因。 2. 使用 HTTP2 HTTP2 相比 HTTP1.1 有如下几个优点： 解析速度快 服务器解析 HTTP1.1 的请求时，必须不断地读入字节，直到遇到分隔符 CRLF 为止。而解析 HTTP2 的请求就不用这么麻烦，因为 HTTP2 是基于帧的协议，每个帧都有表示帧长度的字段。 多路复用 HTTP1.1 如果要同时发起多个请求，就得建立多个 TCP 连接，因为一个 TCP 连接同时只能处理一个 HTTP1.1 的请求。 在 HTTP2 上，多个请求可以共用一个 TCP 连接，这称为多路复用。同一个请求和响应用一个流来表示，并有唯一的流 ID 来标识。多个请求和响应在 TCP 连接中可以乱序发送，到达目的地后再通过流 ID 重新组建。 首部压缩 HTTP2 提供了首部压缩功能。 例如有如下两个请求： :authority: unpkg.zhimg.com :method: GET :path: /za-js-sdk@2.16.0/dist/zap.js :scheme: https accept: */* accept-encoding: gzip, deflate, br accept-language: zh-CN,zh;q=0.9 cache-control: no-cache pragma: no-cache referer: https://www.zhihu.com/ sec-fetch-dest: script sec-fetch-mode: no-cors sec-fetch-site: cross-site user-agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36 :authority: zz.bdstatic.com :method: GET :path: /linksubmit/push.js :scheme: https accept: */* accept-encoding: gzip, deflate, br accept-language: zh-CN,zh;q=0.9 cache-control: no-cache pragma: no-cache referer: https://www.zhihu.com/ sec-fetch-dest: script sec-fetch-mode: no-cors sec-fetch-site: cross-site user-agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36 从上面两个请求可以看出来，有很多数据都是重复的。如果可以把相同的首部存储起来，仅发送它们之间不同的部分，就可以节省不少的流量，加快请求的时间。 HTTP/2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送。 下面再来看一个简化的例子，假设客户端按顺序发送如下请求首部： Header1:foo Header2:bar Header3:bat 当客户端发送请求时，它会根据首部值创建一张表： 索引首部名称值62Header1foo63Header2bar64Header3bat 如果服务器收到了请求，它会照样创建一张表。当客户端发送下一个请求的时候，如果首部相同，它可以直接发送这样的首部块： 62 63 64 服务器会查找先前建立的表格，并把这些数字还原成索引对应的完整首部。 优先级 HTTP2 可以对比较紧急的请求设置一个较高的优先级，服务器在收到这样的请求后，可以优先处理。 流量控制 由于一个 TCP 连接流量带宽（根据客户端到服务器的网络带宽而定）是固定的，当有多个请求并发时，一个请求占的流量多，另一个请求占的流量就会少。流量控制可以对不同的流的流量进行精确控制。 服务器推送 HTTP2 新增的一个强大的新功能，就是服务器可以对一个客户端请求发送多个响应。换句话说，除了对最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确地请求。 例如当浏览器请求一个网站时，除了返回 HTML 页面外，服务器还可以根据 HTML 页面中的资源的 URL，来提前推送资源。 现在有很多网站已经开始使用 HTTP2 了，例如知乎： 其中 h2 是指 HTTP2 协议，http/1.1 则是指 HTTP1.1 协议。 3. 使用服务端渲染 客户端渲染: 获取 HTML 文件，根据需要下载 JavaScript 文件，运行文件，生成 DOM，再渲染。 服务端渲染：服务端返回 HTML 文件，客户端只需解析 HTML。 优点：首屏渲染快，SEO 好。 缺点：配置麻烦，增加了服务器的计算压力。 下面我用 Vue SSR 做示例，简单的描述一下 SSR 过程。 客户端渲染过程 访问客户端渲染的网站。 服务器返回一个包含了引入资源语句和 的 HTML 文件。 客户端通过 HTTP 向服务器请求资源，当必要的资源都加载完毕后，执行 new Vue() 开始实例化并渲染页面。 服务端渲染过程 访问服务端渲染的网站。 服务器会查看当前路由组件需要哪些资源文件，然后将这些文件的内容填充到 HTML 文件。如果有 ajax 请求，就会执行它进行数据预取并填充到 HTML 文件里，最后返回这个 HTML 页面。 当客户端接收到这个 HTML 页面时，可以马上就开始渲染页面。与此同时，页面也会加载资源，当必要的资源都加载完毕后，开始执行 new Vue() 开始实例化并接管页面。 从上述两个过程中可以看出，区别就在于第二步。客户端渲染的网站会直接返回 HTML 文件，而服务端渲染的网站则会渲染完页面再返回这个 HTML 文件。 这样做的好处是什么？是更快的内容到达时间 (time-to-content)。 假设你的网站需要加载完 abcd 四个文件才能渲染完毕。并且每个文件大小为 1 M。 这样一算：客户端渲染的网站需要加载 4 个文件和 HTML 文件才能完成首页渲染，总计大小为 4M（忽略 HTML 文件大小）。而服务端渲染的网站只需要加载一个渲染完毕的 HTML 文件就能完成首页渲染，总计大小为已经渲染完毕的 HTML 文件（这种文件不会太大，一般为几百K，我的个人博客网站（SSR）加载的 HTML 文件为 400K）。这就是服务端渲染更快的原因。 4. 静态资源使用 CDN 内容分发网络（CDN）是一组分布在多个不同地理位置的 Web 服务器。我们都知道，当服务器离用户越远时，延迟越高。CDN 就是为了解决这一问题，在多个位置部署服务器，让用户离服务器更近，从而缩短请求时间。 CDN 原理 当用户访问一个网站时，如果没有 CDN，过程是这样的： 浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。 本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到网站服务器的 IP 地址。 本地 DNS 将 IP 地址发回给浏览器，浏览器向网站服务器 IP 地址发出请求并得到资源。 如果用户访问的网站部署了 CDN，过程是这样的： 浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。 本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到全局负载均衡系统（GSLB）的 IP 地址。 本地 DNS 再向 GSLB 发出请求，GSLB 的主要功能是根据本地 DNS 的 IP 地址判断用户的位置，筛选出距离用户较近的本地负载均衡系统（SLB），并将该 SLB 的 IP 地址作为结果返回给本地 DNS。 本地 DNS 将 SLB 的 IP 地址发回给浏览器，浏览器向 SLB 发出请求。 SLB 根据浏览器请求的资源和地址，选出最优的缓存服务器发回给浏览器。 浏览器再根据 SLB 发回的地址重定向到缓存服务器。 如果缓存服务器有浏览器需要的资源，就将资源发回给浏览器。如果没有，就向源服务器请求资源，再发给浏览器并缓存在本地。 将 CSS 放在文件头部，JavaScript 文件放在底部 所有放在 head 标签里的 CSS 和 JS 文件都会堵塞渲染（CSS 不会阻塞 DOM 解析）。如果这些 CSS 和 JS 需要加载和解析很久的话，那么页面就空白了。所以 JS 文件要放在底部，等 HTML 解析完了再加载 JS 文件。 那为什么 CSS 文件还要放在头部呢？ 因为先加载 HTML 再加载 CSS，会让用户第一时间看到的页面是没有样式的、“丑陋”的，为了避免这种情况发生，就要将 CSS 文件放在头部了。 另外，JS 文件也不是不可以放在头部，只要给 script 标签加上 defer 属性就可以了，异步下载，延迟执行。 6. 使用字体图标 iconfont 代替图片图标 字体图标就是将图标制作成一个字体，使用时就跟字体一样，可以设置属性，例如 font-size、color 等等，非常方便。并且字体图标是矢量图，不会失真。还有一个优点是生成的文件特别小。 压缩字体文件 使用 fontmin-webpack 插件对字体文件进行压缩。 善用缓存，不重复加载相同的资源 为了避免用户每次访问网站都得请求文件，我们可以通过添加 Expires 或 max-age 来控制这一行为。Expires 设置了一个时间，只要在这个时间之前，浏览器都不会请求文件，而是直接使用缓存。而 max-age 是一个相对时间，建议使用 max-age 代替 Expires 。 不过这样会产生一个问题，当文件更新了怎么办？怎么通知浏览器重新请求文件？ 可以通过更新页面中引用的资源链接地址，让浏览器主动放弃缓存，加载新资源。 具体做法是把资源地址 URL 的修改与文件内容关联起来，也就是说，只有文件内容变化，才会导致相应 URL 的变更，从而实现文件级别的精确缓存控制。什么东西与文件内容相关呢？我们会很自然的联想到利用数据摘要要算法对文件求摘要信息，摘要信息与文件内容一一对应，就有了一种可以精确到单个文件粒度的缓存控制依据了。 压缩文件 压缩文件可以减少文件下载时间，让用户体验性更好。 得益于 webpack 和 node 的发展，现在压缩文件已经非常方便了。 在 webpack 可以使用如下插件进行压缩： JavaScript：UglifyPlugin CSS ：MiniCssExtractPlugin HTML：HtmlWebpackPlugin 其实，我们还可以做得更好。那就是使用 gzip 压缩。可以通过向 HTTP 请求头中的 Accept-Encoding 头添加 gzip 标识来开启这一功能。当然，服务器也得支持这一功能。 gzip 是目前最流行和最有效的压缩方法。举个例子，我用 Vue 开发的项目构建后生成的 app.js 文件大小为 1.4MB，使用 gzip 压缩后只有 573KB，体积减少了将近 60%。 附上 webpack 和 node 配置 gzip 的使用方法。 下载插件 npm install compression-webpack-plugin --save-dev npm install compression webpack 配置 const CompressionPlugin = require('compression-webpack-plugin'); module.exports = { plugins: [new CompressionPlugin()], } node 配置 const compression = require('compression') // 在其他中间件前使用 app.use(compression()) 9. 图片优化 (1). 图片延迟加载 在页面中，先不给图片设置路径，只有当图片出现在浏览器的可视区域时，才去加载真正的图片，这就是延迟加载。对于图片很多的网站来说，一次性加载全部图片，会对用户体验造成很大的影响，所以需要使用图片延迟加载。 首先可以将图片这样设置，在页面不可见时图片不会加载： 等页面可见时，使用 JS 加载图片： const img = document.querySelector('img') img.src = img.dataset.src 这样图片就加载出来了。 (2). 响应式图片 响应式图片的优点是浏览器能够根据屏幕大小自动加载合适的图片。 通过 picture 实现 通过 @media 实现 @media (min-width: 769px) { .bg { background-image: url(bg1080.jpg); } } @media (max-width: 768px) { .bg { background-image: url(bg768.jpg); } } (3). 调整图片大小 例如，你有一个 1920 * 1080 大小的图片，用缩略图的方式展示给用户，并且当用户鼠标悬停在上面时才展示全图。如果用户从未真正将鼠标悬停在缩略图上，则浪费了下载图片的时间。 所以，我们可以用两张图片来实行优化。一开始，只加载缩略图，当用户悬停在图片上时，才加载大图。还有一种办法，即对大图进行延迟加载，在所有元素都加载完成后手动更改大图的 src 进行下载。 (4). 降低图片质量 例如 JPG 格式的图片，100% 的质量和 90% 质量的通常看不出来区别，尤其是用来当背景图的时候。我经常用 PS 切背景图时， 将图片切成 JPG 格式，并且将它压缩到 60% 的质量，基本上看不出来区别。 压缩方法有两种，一是通过 webpack 插件 image-webpack-loader，二是通过在线网站进行压缩。 以下附上 webpack 插件 image-webpack-loader 的用法。 npm i -D image-webpack-loader webpack 配置 { test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, use:[ { loader: 'url-loader', options: { limit: 10000, /* 图片大小小于1000字节限制时会自动转成 base64 码引用*/ name: utils.assetsPath('img/[name].[hash:7].[ext]') } }, /*对图片进行压缩*/ { loader: 'image-webpack-loader', options: { bypassOnDebug: true, } } ] } (5). 尽可能利用 CSS3 效果代替图片 有很多图片使用 CSS 效果（渐变、阴影等）就能画出来，这种情况选择 CSS3 效果更好。因为代码大小通常是图片大小的几分之一甚至几十分之一。 (6). 使用 webp 格式的图片 WebP 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都相当优秀、稳定和统一。 参考资料： WebP 相对于 PNG、JPG 有什么优势？ https://www.zhihu.com/question/27201061 10. 通过 webpack 按需加载代码，提取第三库代码，减少 ES6 转为 ES5 的冗余代码 懒加载或者按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把你的代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载。 根据文件内容生成文件名，结合 import 动态引入组件实现按需加载 通过配置 output 的 filename 属性可以实现这个需求。filename 属性的值选项中有一个 [contenthash]，它将根据文件内容创建出唯一 hash。当文件内容发生变化时，[contenthash] 也会发生变化。 output: { filename: '[name].[contenthash].js', chunkFilename: '[name].[contenthash].js', path: path.resolve(__dirname, '../dist'), }, 提取第三方库 由于引入的第三方库一般都比较稳定，不会经常改变。所以将它们单独提取出来，作为长期缓存是一个更好的选择。这里需要使用 webpack4 的 splitChunk 插件 cacheGroups 选项。 optimization: { runtimeChunk: { name: 'manifest' // 将 webpack 的 runtime 代码拆分为一个单独的 chunk。 }, splitChunks: { cacheGroups: { vendor: { name: 'chunk-vendors', test: /[\\\\/]node_modules[\\\\/]/, priority: -10, chunks: 'initial' }, common: { name: 'chunk-common', minChunks: 2, priority: -20, chunks: 'initial', reuseExistingChunk: true } }, } }, test: 用于控制哪些模块被这个缓存组匹配到。原封不动传递出去的话，它默认会选择所有的模块。可以传递的值类型：RegExp、String和Function; priority：表示抽取权重，数字越大表示优先级越高。因为一个 module 可能会满足多个 cacheGroups 的条件，那么抽取到哪个就由权重最高的说了算； reuseExistingChunk：表示是否使用已有的 chunk，如果为 true 则表示如果当前的 chunk 包含的模块已经被抽取出去了，那么将不会重新生成新的。 minChunks（默认是1）：在分割之前，这个代码块最小应该被引用的次数（译注：保证代码块复用性，默认配置的策略是不需要多次引用也可以被分割） chunks (默认是async) ：initial、async和all name(打包的chunks的名字)：字符串或者函数(函数可以根据条件自定义名字) 减少 ES6 转为 ES5 的冗余代码 Babel 转化后的代码想要实现和原来代码一样的功能需要借助一些帮助函数，比如： class Person {} 会被转换为： \"use strict\"; function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } var Person = function Person() { _classCallCheck(this, Person); }; 这里 _classCallCheck 就是一个 helper 函数，如果在很多文件里都声明了类，那么就会产生很多个这样的 helper 函数。 这里的 @babel/runtime 包就声明了所有需要用到的帮助函数，而 @babel/plugin-transform-runtime 的作用就是将所有需要 helper 函数的文件，从 @babel/runtime包 引进来： \"use strict\"; var _classCallCheck2 = require(\"@babel/runtime/helpers/classCallCheck\"); var _classCallCheck3 = _interopRequireDefault(_classCallCheck2); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } var Person = function Person() { (0, _classCallCheck3.default)(this, Person); }; 这里就没有再编译出 helper 函数 classCallCheck 了，而是直接引用了 @babel/runtime 中的 helpers/classCallCheck。 安装 npm i -D @babel/plugin-transform-runtime @babel/runtime 使用 在 .babelrc 文件中 \"plugins\": [ \"@babel/plugin-transform-runtime\" ] 减少重绘重排 浏览器渲染过程 解析HTML生成DOM树。 解析CSS生成CSSOM规则树。 解析JS，操作 DOM 树和 CSSOM 规则树。 将DOM树与CSSOM规则树合并在一起生成渲染树。 遍历渲染树开始布局，计算每个节点的位置大小信息。 浏览器将所有图层的数据发送给GPU，GPU将图层合成并显示在屏幕上。 重排 当改变 DOM 元素位置或大小时，会导致浏览器重新生成渲染树，这个过程叫重排。 重绘 当重新生成渲染树后，就要将渲染树每个节点绘制到屏幕，这个过程叫重绘。不是所有的动作都会导致重排，例如改变字体颜色，只会导致重绘。记住，重排会导致重绘，重绘不会导致重排 。 重排和重绘这两个操作都是非常昂贵的，因为 JavaScript 引擎线程与 GUI 渲染线程是互斥，它们同时只能一个在工作。 什么操作会导致重排？ 添加或删除可见的 DOM 元素 元素位置改变 元素尺寸改变 内容改变 浏览器窗口尺寸改变 如何减少重排重绘？ 用 JavaScript 修改样式时，最好不要直接写样式，而是替换 class 来改变样式。 如果要对 DOM 元素执行一系列操作，可以将 DOM 元素脱离文档流，修改完成后，再将它带回文档。推荐使用隐藏元素（display:none）或文档碎片（DocumentFragement），都能很好的实现这个方案。 12. 使用事件委托 事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。所有用到按钮的事件（多数鼠标事件和键盘事件）都适合采用事件委托技术， 使用事件委托可以节省内存。 苹果 香蕉 凤梨 // good document.querySelector('ul').onclick = (event) => { const target = event.target if (target.nodeName === 'LI') { console.log(target.innerHTML) } } // bad document.querySelectorAll('li').forEach((e) => { e.onclick = function() { console.log(this.innerHTML) } }) 13. 注意程序的局部性 一个编写良好的计算机程序常常具有良好的局部性，它们倾向于引用最近引用过的数据项附近的数据项，或者最近引用过的数据项本身，这种倾向性，被称为局部性原理。有良好局部性的程序比局部性差的程序运行得更快。 局部性通常有两种不同的形式： 时间局部性：在一个具有良好时间局部性的程序中，被引用过一次的内存位置很可能在不远的将来被多次引用。 空间局部性 ：在一个具有良好空间局部性的程序中，如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用附近的一个内存位置。 时间局部性示例 function sum(arry) { let i, sum = 0 let len = arry.length for (i = 0; i 在这个例子中，变量sum在每次循环迭代中被引用一次，因此，对于sum来说，具有良好的时间局部性 空间局部性示例 具有良好空间局部性的程序 // 二维数组 function sum1(arry, rows, cols) { let i, j, sum = 0 for (i = 0; i 空间局部性差的程序 // 二维数组 function sum2(arry, rows, cols) { let i, j, sum = 0 for (j = 0; j 看一下上面的两个空间局部性示例，像示例中从每行开始按顺序访问数组每个元素的方式，称为具有步长为1的引用模式。如果在数组中，每隔k个元素进行访问，就称为步长为k的引用模式。一般而言，随着步长的增加，空间局部性下降。 这两个例子有什么区别？区别在于第一个示例是按行扫描数组，每扫描完一行再去扫下一行；第二个示例是按列来扫描数组，扫完一行中的一个元素，马上就去扫下一行中的同一列元素。 数组在内存中是按照行顺序来存放的，结果就是逐行扫描数组的示例得到了步长为 1 引用模式，具有良好的空间局部性；而另一个示例步长为 rows，空间局部性极差。 性能测试 运行环境： cpu: i5-7400 浏览器: chrome 70.0.3538.110 对一个长度为9000的二维数组（子数组长度也为9000）进行10次空间局部性测试，时间（毫秒）取平均值，结果如下： 所用示例为上述两个空间局部性示例 步长为 1步长为 90001242316 从以上测试结果来看，步长为 1 的数组执行时间比步长为 9000 的数组快了一个数量级。 总结： 重复引用相同变量的程序具有良好的时间局部性 对于具有步长为 k 的引用模式的程序，步长越小，空间局部性越好；而在内存中以大步长跳来跳去的程序空间局部性会很差 14. if-else 对比 switch 当判断条件数量越来越多时，越倾向于使用 switch 而不是 if-else。 if (color == 'blue') { } else if (color == 'yellow') { } else if (color == 'white') { } else if (color == 'black') { } else if (color == 'green') { } else if (color == 'orange') { } else if (color == 'pink') { } switch (color) { case 'blue': break case 'yellow': break case 'white': break case 'black': break case 'green': break case 'orange': break case 'pink': break } 像以上这种情况，使用 switch 是最好的。假设 color 的值为 pink，则 if-else 语句要进行 7 次判断，switch 只需要进行一次判断。从可读性来说，switch 语句也更好。 从使用时机来说，当条件值大于两个的时候，使用 switch 更好。不过 if-else 也有 switch 无法做到的事情，例如有多个判断条件的情况下，无法使用 switch。 15. 查找表 当条件语句特别多时，使用 switch 和 if-else 不是最佳的选择，这时不妨试一下查找表。查找表可以使用数组和对象来构建。 switch (index) { case '0': return result0 case '1': return result1 case '2': return result2 case '3': return result3 case '4': return result4 case '5': return result5 case '6': return result6 case '7': return result7 case '8': return result8 case '9': return result9 case '10': return result10 case '11': return result11 } 可以将这个 switch 语句转换为查找表 const results = [result0,result1,result2,result3,result4,result5,result6,result7,result8,result9,result10,result11] return results[index] 如果条件语句不是数值而是字符串，可以用对象来建立查找表 const map = { red: result0, green: result1, } return map[color] 16. 避免页面卡顿 60fps 与设备刷新率 目前大多数设备的屏幕刷新率为 60 次/秒。因此，如果在页面中有一个动画或渐变效果，或者用户正在滚动页面，那么浏览器渲染动画或页面的每一帧的速率也需要跟设备屏幕的刷新率保持一致。 其中每个帧的预算时间仅比 16 毫秒多一点 (1 秒/ 60 = 16.66 毫秒)。但实际上，浏览器有整理工作要做，因此您的所有工作需要在 10 毫秒内完成。如果无法符合此预算，帧率将下降，并且内容会在屏幕上抖动。此现象通常称为卡顿，会对用户体验产生负面影响。 假如你用 JavaScript 修改了 DOM，并触发样式修改，经历重排重绘最后画到屏幕上。如果这其中任意一项的执行时间过长，都会导致渲染这一帧的时间过长，平均帧率就会下降。假设这一帧花了 50 ms，那么此时的帧率为 1s / 50ms = 20fps，页面看起来就像卡顿了一样。 对于一些长时间运行的 JavaScript，我们可以使用定时器进行切分，延迟执行。 for (let i = 0, len = arry.length; i 假设上面的循环结构由于 process() 复杂度过高或数组元素太多，甚至两者都有，可以尝试一下切分。 const todo = arry.concat() setTimeout(function() { process(todo.shift()) if (todo.length) { setTimeout(arguments.callee, 25) } else { callback(arry) } }, 25) 如果有兴趣了解更多，可以查看一下高性能JavaScript第 6 章和高效前端：Web高效编程与优化实践第 3 章。 17. 使用 requestAnimationFrame 来实现视觉变化 从第 16 点我们可以知道，大多数设备屏幕刷新率为 60 次/秒，也就是说每一帧的平均时间为 16.66 毫秒。在使用 JavaScript 实现动画效果的时候，最好的情况就是每次代码都是在帧的开头开始执行。而保证 JavaScript 在帧开始时运行的唯一方式是使用 requestAnimationFrame。 /** * If run as a requestAnimationFrame callback, this * will be run at the start of the frame. */ function updateScreen(time) { // Make visual updates here. } requestAnimationFrame(updateScreen); 如果采取 setTimeout 或 setInterval 来实现动画的话，回调函数将在帧中的某个时点运行，可能刚好在末尾，而这可能经常会使我们丢失帧，导致卡顿。 18. 使用 Web Workers Web Worker 使用其他工作线程从而独立于主线程之外，它可以执行任务而不干扰用户界面。一个 worker 可以将消息发送到创建它的 JavaScript 代码, 通过将消息发送到该代码指定的事件处理程序（反之亦然）。 Web Worker 适用于那些处理纯数据，或者与浏览器 UI 无关的长时间运行脚本。 创建一个新的 worker 很简单，指定一个脚本的 URI 来执行 worker 线程（main.js）： var myWorker = new Worker('worker.js'); // 你可以通过postMessage() 方法和onmessage事件向worker发送消息。 first.onchange = function() { myWorker.postMessage([first.value,second.value]); console.log('Message posted to worker'); } second.onchange = function() { myWorker.postMessage([first.value,second.value]); console.log('Message posted to worker'); } 在 worker 中接收到消息后，我们可以写一个事件处理函数代码作为响应（worker.js）： onmessage = function(e) { console.log('Message received from main script'); var workerResult = 'Result: ' + (e.data[0] * e.data[1]); console.log('Posting message back to main script'); postMessage(workerResult); } onmessage处理函数在接收到消息后马上执行，代码中消息本身作为事件的data属性进行使用。这里我们简单的对这2个数字作乘法处理并再次使用postMessage()方法，将结果回传给主线程。 回到主线程，我们再次使用onmessage以响应worker回传的消息： myWorker.onmessage = function(e) { result.textContent = e.data; console.log('Message received from worker'); } 在这里我们获取消息事件的data，并且将它设置为result的textContent，所以用户可以直接看到运算的结果。 不过在worker内，不能直接操作DOM节点，也不能使用window对象的默认方法和属性。然而你可以使用大量window对象之下的东西，包括WebSockets，IndexedDB以及FireFox OS专用的Data Store API等数据存储机制。 19. 使用位操作 JavaScript 中的数字都使用 IEEE-754 标准以 64 位格式存储。但是在位操作中，数字被转换为有符号的 32 位格式。即使需要转换，位操作也比其他数学运算和布尔操作快得多。 取模 由于偶数的最低位为 0，奇数为 1，所以取模运算可以用位操作来代替。 if (value % 2) { // 奇数 } else { // 偶数 } // 位操作 if (value & 1) { // 奇数 } else { // 偶数 } 取整 ~~10.12 // 10 ~~10 // 10 ~~'1.5' // 1 ~~undefined // 0 ~~null // 0 位掩码 const a = 1 const b = 2 const c = 4 const options = a | b | c 通过定义这些选项，可以用按位与操作来判断 a/b/c 是否在 options 中。 // 选项 b 是否在选项中 if (b & options) { ... } 20. 不要覆盖原生方法 无论你的 JavaScript 代码如何优化，都比不上原生方法。因为原生方法是用低级语言写的（C/C++），并且被编译成机器码，成为浏览器的一部分。当原生方法可用时，尽量使用它们，特别是数学运算和 DOM 操作。 21. 降低 CSS 选择器的复杂性 (1). 浏览器读取选择器，遵循的原则是从选择器的右边到左边读取。 看个示例 #block .text p { color: red; } 查找所有 P 元素。 查找结果 1 中的元素是否有类名为 text 的父元素 查找结果 2 中的元素是否有 id 为 block 的父元素 (2). CSS 选择器优先级 内联 > ID选择器 > 类选择器 > 标签选择器 根据以上两个信息可以得出结论。 选择器越短越好。 尽量使用高优先级的选择器，例如 ID 和类选择器。 避免使用通配符 *。 最后要说一句，据我查找的资料所得，CSS 选择器没有优化的必要，因为最慢和慢快的选择器性能差别非常小。 22. 使用 flexbox 而不是较早的布局模型 在早期的 CSS 布局方式中我们能对元素实行绝对定位、相对定位或浮动定位。而现在，我们有了新的布局方式 flexbox，它比起早期的布局方式来说有个优势，那就是性能比较好。 下面的截图显示了在 1300 个框上使用浮动的布局开销： 然后我们用 flexbox 来重现这个例子： 现在，对于相同数量的元素和相同的视觉外观，布局的时间要少得多（本例中为分别 3.5 毫秒和 14 毫秒）。 不过 flexbox 兼容性还是有点问题，不是所有浏览器都支持它，所以要谨慎使用。 各浏览器兼容性： Chrome 29+ Firefox 28+ Internet Explorer 11 Opera 17+ Safari 6.1+ (prefixed with -webkit-) Android 4.4+ iOS 7.1+ (prefixed with -webkit-) 23. 使用 transform 和 opacity 属性更改来实现动画 在 CSS 中，transforms 和 opacity 这两个属性更改不会触发重排与重绘，它们是可以由合成器（composite）单独处理的属性。 参考资料： 使用 transform 和 opacity 属性更改来实现动画 24. 合理使用规则，避免过度优化 性能优化主要分为两类： 加载时优化 运行时优化 上述 23 条建议中，属于加载时优化的是前面 10 条建议，属于运行时优化的是后面 13 条建议。通常来说，没有必要 23 条性能优化规则都用上，根据网站用户群体来做针对性的调整是最好的，节省精力，节省时间。 在解决问题之前，得先找出问题，否则无从下手。所以在做性能优化之前，最好先调查一下网站的加载性能和运行性能。 检查加载性能 一个网站加载性能如何主要看白屏时间和首屏时间。 白屏时间：指从输入网址，到页面开始显示内容的时间。 首屏时间：指从输入网址，到页面完全渲染的时间。 将以下脚本放在 前面就能获取白屏时间。 new Date() - performance.timing.navigationStart 在 window.onload 事件里执行 new Date() \\- performance.timing.navigationStart 即可获取首屏时间。 检查运行性能 配合 chrome 的开发者工具，我们可以查看网站在运行时的性能。 打开网站，按 F12 选择 performance，点击左上角的灰色圆点，变成红色就代表开始记录了。这时可以模仿用户使用网站，在使用完毕后，点击 stop，然后你就能看到网站运行期间的性能报告。如果有红色的块，代表有掉帧的情况；如果是绿色，则代表 FPS 很好。performance 的具体使用方法请用搜索引擎搜索一下，毕竟篇幅有限。 通过检查加载和运行性能，相信你对网站性能已经有了大概了解。所以这时候要做的事情，就是使用上述 23 条建议尽情地去优化你的网站，加油！ EOF - 推荐阅读 点击标题可跳转 1、Vue实现原理+前端性能优化 2、从 12.67s 到 1.06s 的网站性能优化实战 3、你必须懂的前端性能优化 觉得本文对你有帮助？请分享给更多人 推荐关注「前端大全」，提升前端技能 点赞和在看就是最大的支持❤️ Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-19 18:43:16 "},"前端杂项/原型、原型链以及继承.html":{"url":"前端杂项/原型、原型链以及继承.html","title":"原型、原型链以及继承","keywords":"","body":"什么是对象 * 多个数据（属性）的集合； * 用来保存多个数据（属性）的容器； 属性组成 属性名：字符串（标识）； 属性值：任意类型； 属性的分类： 一般：属性值不是 function，描述对象的状态； 方法：属性值为 function 的属性，描述对象的行为； 特别的对象 数组：属性名是 0，1，2，3 之类的索引； 函数：可执行的； 对象是一种复合数据类型，可以保存不同类型的属性； 创建对象 var obj = new object(); 复制代码 向对象中添加属性 . 属性名； ['属性名']：属性名有特殊字符 / 属性名是一个变量； obj.属性名 = 属性值； obj[‘属性名’] = 属性值； 复制代码 使用[]去操作属性时，[]中传递的是一个字符串。 能传字符串的地方就能传变量； 如果我们对象的属性名过于奇怪，则必须使用 [] 来操作。 对象创建模式 1. 对象字面量模式 套路: 使用 {} 创建对象, 同时指定属性 / 方法; 适用场景: 起始时对象内部数据是确定的； 问题: 如果创建多个对象, 有重复代码; var p = { name: 'Tom', age: 23, setName: function (name) { this.name = name } } console.log(p.name, p.age) p.setName('JACK') console.log(p.name, p.age) var p2 = { name: 'BOB', age: 24, setName: function (name) { this.name = name } } 复制代码 2.Object 构造函数的模式 套路: 先创建空 Object 对象, 再动态添加属性 / 方法 适用场景: 起始时不确定对象内部数据； 问题: 语句太多； // 一个人: name:\"Tom\", age: 12 var p = new Object() p = {} p.name = 'Tom' p.age = 12 p.setName = function (name) { this.name = name } p.setaAge = function (age) { this.age = age } console.log(p) 复制代码 3. 工厂模式 套路: 通过工厂函数动态创建对象并返回； 适用场景: 需要创建多个对象； 问题: 对象没有一个具体的类型，都是 Object 类型； // 工厂函数: 返回一个需要的数据的函数 function createPerson(name, age) { var p = { name: name, age: age, setName: function (name) { this.name = name } } return p } var p1 = createPerson('Tom', 12) var p2 = createPerson('JAck', 13) console.log(p1) console.log(p2) 复制代码 4. 自定义构造函数模式； 套路: 自定义构造函数，通过 new 创建对象； 适用场景: 需要创建多个类型确定的对象； 问题: 每个对象都有相同的数据, 浪费内存；将属性和方法添加到各个实例对象上去，但是每个实例都有相同的方法，重复了，我们可以将相同的方法放到他的构造函数的原型对象上去； function Person(name, age) { this.name = name this.age = age this.setName = function (name) { this.name = name } } var p1 = new Person('Tom', 12) var p2 = new Person('Tom2', 13) console.log(p1, p1 instanceof Person) 复制代码 对象高级 原型与原型链 什么是原型 1、prototype 本质上还是一个 JavaScript 对象； 2、每个函数都有一个默认的 prototype 属性； 3、通过 prototype 我们可以扩展 Javascript 的内建对象 原型的扩展 所有函数都有一个特别的属性：prototype 显式原型属性（只有函数有 prototype，对象是没有的。）； 所有实例对象都有一个特别的属性：proto隐式原型属性； 原型是用于保存对象的共享属性和方法的，原型的属性和方法并不会影响函数本身的属性和方法。 显式原型与隐式原型的关系 函数的 prototype：定义函数时被自动赋值，值默认为 {}，即原型对象； 实例对象的proto: 在创建实例对象时被自动添加, 并赋值为构造函数的 prototype 值； 原型对象即为当前实例对象的父对象； 原型链 所有的实例对象都有proto属性, 它指向的就是原型对象 这样通过proto属性就形成了一个链的结构 ----> 原型链； 当查找对象内部的属性 / 方法时, js 引擎自动沿着这个原型链查找； 当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作； 面试必画图 图片是个人画的图，面试官但凡问到原型链问题，就可以画出此图，并且边画边叙述，会给你蹭蹭地加分哦； 图片上有必说的语句，并且标明了结合画图时说这些语句的时机 new 关键字做了什么 示例： // 构造函数 function Base(){} var baseObj = new Base() 复制代码 创建了一个空对象； 将这个空对象的隐式原型proto\\ 指向构造函数的显示原型 prototype；如例，是将空对象的proto成员指向了 Base 函数对象 prototype 成员对象； 将构造函数的 this 指向实例（即空对象），并调用构造函数 Base； var obj = {}; obj.__proto__ = Base.prototype; Base.call(obj); 复制代码 根据 new 的工作原理手动实现一下 new 运算符 let newObj = function(func){ //创建对象,错误示范：Object.create()方法创建一个新对象，使用现有的对象的prototype指向括号中的对象func.prototype。 // let obj = Object.create(func.prototype) // 所以应该如下创造对象，是为了使新创建的对象的__proto__指向构造函数的原型func.prototype let obj = new Object() obj.__proto__=func.prototype // 将构造函数的作用域给新的对象，并且执行构造函数 // 如果构造函数有返回值，那就返回返回值，如果没有，会返回undefined let k = func.call(obj) if(typeof k === 'object'){ // 如果返回的类型是一个对象，那就返回该对象 return k }else{ // 如果构造函数执行后，返回的类型不是一个对象的话，那就返回创建的对象 return obj } } 复制代码 对象的继承 复制属性式继承 // 创建父对象 var parentObj = { name: 'parentName', age: 25, showName:function(){ console.log(this.name); } } // 创建需要继承的子对象 var childrenObj= {} // 开始拷贝属性(使用for...in...循环) for(var i in parentObj){ childrenObj[i] = parentObj[i] } console.log(childrenObj); //{ name: 'parentName', age: 25, showName: [Function: showName] } console.log(parentObj); // { name: 'parentName', age: 25, showName: [Function: showName] } 复制代码 重点：将父对象的函数和方法循环进行复制，复制到子对象里； 缺点：如果继承过来的成员是引用类型的话，那么这个引用类型的成员在父对象和子对象之间是共享的，也就是说修改了之后, 父子对象都会受到影响。 原型继承：//TODO 原型式继承就是借用构造函数的原型对象实现继承，即 子构造函数. prototype = 父构造函数. prototype； // 创建父构造函数 function Parent(){} // 设置父构造函数的原型对象 Parent.prototype.age = 25; Parent.prototype.friends = ['小名','小丽']; Parent.prototype.showAge = function(){ console.log(this.age); }; // 创建子构造函数 function Child(){} // 设置子构造器的原型对象实现继承 Child.prototype = Parent.prototype // 因为子构造函数的原型被覆盖了, 所以现在子构造函数的原型的构造器属性已经不再指向Child，而是Parent。此时实例化Child和实例化parent的区别是不大的，所以再次创建Child是没有意义的，并且Child.prototype添加属性，也是会影响到Parent.prototype； console.log(Child.prototype.constructor == Parent);// true console.log(Parent.prototype.constructor == Parent);// true // 问题就在这里！！！！ // 所以我们需要修正一下 Parent.prototype.constructor = Child; // 上面这行代码之后, 就实现了继承 var childObj = new Child(); console.log(childObj.age);// 25 console.log(childObj.friends);// ['小名','小丽'] childObj.showAge();// 25 复制代码 问题： 只能继承父构造函数的原型对象上的成员, 不能继承父构造函数的实例对象的成员； 父构造函数的原型对象和子构造函数的原型对象上的成员有共享问题； 原型链继承 : 得到方法 // 定义父构造函数 function Parent(name,friends){ this.name = name; this.friends = friends; } Parent.prototype.test = function(){ console.log('原型方法', this.friends) }; // 定义子构造函数 function Child(name,friends,age){ this.age = '12' } // 将子构造函数的原型指定父函数的实例 Child.prototype = new Parent('parentName',['a','b','c']); // 但是 console.log(Child.prototype.constructor); //输出：function Parent(){this.name = 'me';this.sex = ['male','female']} // 所以，把Child的原型的构造函数修复为child Child.prototype.constructor = Child var childObj = new Child('childName',[3,4,'ddd'],24);//有test() // 问题一：子实例无法向父类传值 console.log(childObj.name,childObj.friends) // parentName和[\"a\", \"b\", \"c\"] // 问题二：如果其中一个子类修改了父类中的引用数据类型的属性，那么就会影响其他的子类 var childObj2 = new Child('childName',[3,4],24); childObj2.friends.push('additem') console.log(childObj1.friends,childObj2.friends)// [\"a\", \"b\", \"c\", \"additem\"]， [\"a\", \"b\", \"c\", \"additem\"] 复制代码 重点：让新实例（继承对象 childObj）的构造函数（Child）的原型等于父类的实例（被继承的实例 new Parent()），或者说将父类的实例作为子类的原型； 特点： 实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。 缺点： 1、新实例无法向父类的构造函数中传递参数。 2、继承单一。 3、所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！） 借用构造函数 call（经典继承） : 得到属性 使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）； 问题：Child 无法继承 Parent 原型上的对象，并没有真正的实现继承（部分继承）； function Parent(xxx){this.xxx = xxx} Parent.prototype.test = function(){}; function Child(xxx,yyy){ Parent.call(this, xxx); } var child = new Child('a', 'b'); //child.xxx为'a', 但child没有test() // 问题： console.log(child.test);// undefined 复制代码 特点 创建子类实例时，可以向父类传递参数 可以实现多继承（call 多个父类对象） 组合式继承 借用构造函数 + 原型式继承 // 创建父构造函数 // 父类属性 function Parent(name){ this.name = name; this.sex = ['male','female'] } // 父类原型方法 Parent.prototype.test = function(){ console.log(this.name) }; // 定义子构造函数 function Child(name,age){ // 复制父级构造函数的属性和方法 // 使得每一个子对象都能复制一份父对象的属性且不会相互影响 Parent.call(this,name);//继承实例属性，第一次调用Parent() this.age = age } // 将子构造函数的原型对象指向父级实例 var parentObj = new Parent();//继承父类方法，第二次调用Parent() Child.prototype = parentObj; //得到test() // 将子构造函数Child原型的构造函数修复为Child Child.prototype.constructor = Child; var childObj = new Child('zhangsan',15); console.log(childObj,childObj.name,childObj.sex,childObj.test) // 输出：childObj.name:'zhangsan';childObj.sex:[\"male\", \"female\"];childObj.test：一个函数 复制代码 相当重要的一步：Child.prototype.constructor = Child; 任何一个 Prototype 对象都有一个 constructor 指针，指向它的构造函数； 每个实例中也会有一个 constructor 指针，这个指针默认调用 Prototype 对象的 constructor 属性。 结果：当替换了子类的原型之后，即 Child.prototype = new Parent() 之后，Child.prototype.constructor 就指向了 Parent()，Child 的实例的 constructor 也指向了 Parent()，这就出现问题了。 因为这造成了继承链的紊乱，因为 Child 的实例是由 Child 构造函数创建的，现在其 constructor 属性却指向了 Parent, 为了避免这一现象，就必须在替换 prototype 对象之后，为新的 prototype 对象加上 constructor 属性，使其指向原来的构造函数。 缺点：通过将子构造函数的原型指向父构造函数的实例，会两次调用父类构造函数； 寄生组合式继承 原理：通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。 思路：不必为了指定子类的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。 寄生组合式继承就是为了降低调用父类构造函数的开销而出现的 ; 本质上，就是使用寄生式继承来继承父类型的原型，然后再将结果指定给子类型的原型。 解决方法是在中间架一座桥梁，加一个空的构造函数； // 创建父构造函数 function Parent(){ this.name = 'me'; this.sex = ['male','female'] } Parent.prototype.test = function(){}; // 定义子构造函数 function Child(){ // 复制父级构造函数的属性和方法 // 使得每一个子对象都能复制一份父对象的属性且不会相互影响 Parent.call(this); this.age = '12' } // 定义空函数 function F(){} // 把空函数的原型指向Parent.prototype // 寄生式组合继承 F.prototype = Parent.prototype // 将子构造函数的原型对象指向空函数F的实例对象fObj var fObj = new F(); Child.prototype = fObj; // 将子构造函数Child原型的构造函数修复为Child Child.prototype.constructor = Child; var childObj = new Child(); 复制代码 优点：高效率体现在只调用了一次 Parent 构造函数，并且因此避免了在 Child.prototype 上面创建不必要的，多余的属性。与此同时，原型链还能保持不变；因此，还能正常使用 instanceof 和 isPrototypeOf()。 开发人员普遍认为寄生式组合式继承是引用类型最理想的继承范式。 Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-19 18:44:46 "},"前端杂项/JavaScript数组去重.html":{"url":"前端杂项/JavaScript数组去重.html","title":"数组去重","keywords":"","body":"数组去重的方法 一、利用ES6 Set去重（ES6中最常用） function unique (arr) { return Array.from(new Set(arr)) } var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}]; console.log(unique(arr)) //[1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", {}, {}] 不考虑兼容性，这种去重的方法代码最少。这种方法还无法去掉“{}”空对象，后面的高阶方法会添加去掉重复“{}”的方法。 二、利用for嵌套for，然后splice去重（ES5中最常用） function unique(arr){ for(var i=0; i双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值。想快速学习更多常用的ES6语法，可以看我之前的文章《学习ES6笔记──工作中常用到的ES6语法》。 三、利用indexOf去重 function unique(arr) { if (!Array.isArray(arr)) { console.log('type error!') return } var array = []; for (var i = 0; i 新建一个空的结果数组，for 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则push进数组。 四、利用sort() function unique(arr) { if (!Array.isArray(arr)) { console.log('type error!') return; } arr = arr.sort() var arrry= [arr[0]]; for (var i = 1; i 利用sort()排序方法，然后根据排序后的结果进行遍历及相邻元素比对。 五、利用对象的属性不能相同的特点进行去重（这种数组去重的方法有问题，不建议用，有待改进） function unique(arr) { if (!Array.isArray(arr)) { console.log('type error!') return } var arrry= []; var obj = {}; for (var i = 0; i 六、利用includes function unique(arr) { if (!Array.isArray(arr)) { console.log('type error!') return } var array =[]; for(var i = 0; i 七、利用hasOwnProperty function unique(arr) { var obj = {}; return arr.filter(function(item, index, arr){ return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true) }) } var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}]; console.log(unique(arr)) //[1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", {…}] //所有的都去重了 利用hasOwnProperty 判断是否存在对象属性 八、利用filter function unique(arr) { return arr.filter(function(item, index, arr) { //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素 return arr.indexOf(item, 0) === index; }); } var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}]; console.log(unique(arr)) //[1, \"true\", true, 15, false, undefined, null, \"NaN\", 0, \"a\", {…}, {…}] 九、利用递归去重 function unique(arr) { var array= arr; var len = array.length; array.sort(function(a,b){ //排序后更加方便去重 return a - b; }) function loop(index){ if(index >= 1){ if(array[index] === array[index-1]){ array.splice(index,1); } loop(index - 1); //递归loop，然后数组去重 } } loop(len-1); return array; } var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}]; console.log(unique(arr)) //[1, \"a\", \"true\", true, 15, false, 1, {…}, null, NaN, NaN, \"NaN\", 0, \"a\", {…}, undefined] 十、利用Map数据结构去重 function arrayNonRepeatfy(arr) { let map = new Map(); let array = new Array(); // 数组用于返回结果 for (let i = 0; i 创建一个空Map数据结构，遍历需要去重的数组，把数组的每一个元素作为key存到Map中。由于Map中不会出现相同的key值，所以最终得到的就是去重后的结果。 十一、利用reduce+includes function unique(arr){ return arr.reduce((prev,cur) => prev.includes(cur) ? prev : [...prev,cur],[]); } var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}]; console.log(unique(arr)); // [1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", {…}, {…}] 十二、[...new Set(arr)] [...new Set(arr)] //代码就是这么少----（其实，严格来说并不算是一种，相对于第一种方法来说只是简化了代码） PS：有些文章提到了foreach+indexOf数组去重的方法，个人觉得都是大同小异，所以没有写上去。 Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-22 14:29:15 "},"前端杂项/JS手写题.html":{"url":"前端杂项/JS手写题.html","title":"JS手写题","keywords":"","body":"tips 阅读的时候需要做什么 数据类型判断 typeof 可以正确识别：Undefined、Boolean、Number、String、Symbol、Function 等类型的数据，但是对于其他的都会认为是 object，比如 Null、Date 等，所以通过 typeof 来判断数据类型会不准确。但是可以使用 Object.prototype.toString 实现。 function typeOf(obj) { let res = Object.prototype.toString.call(obj).split(' ')[1] res = res.substring(0, res.length - 1).toLowerCase() return res } typeOf([]) // 'array' typeOf({}) // 'object' typeOf(new Date) // 'date' 继承 原型链继承 function Animal() { this.colors = ['black', 'white'] } Animal.prototype.getColor = function() { return this.colors } function Dog() {} Dog.prototype = new Animal() let dog1 = new Dog() dog1.colors.push('brown') let dog2 = new Dog() console.log(dog2.colors) // ['black', 'white', 'brown'] 原型链继承存在的问题： 问题1：原型中包含的引用类型属性将被所有实例共享； 问题2：子类在实例化的时候不能给父类构造函数传参； 借用构造函数实现继承 function Animal(name) { this.name = name this.getName = function() { return this.name } } function Dog(name) { Animal.call(this, name) } Dog.prototype = new Animal() 借用构造函数实现继承解决了原型链继承的 2 个问题：引用类型共享问题以及传参问题。但是由于方法必须定义在构造函数中，所以会导致每次创建子类实例都会创建一遍方法。 组合继承 组合继承结合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。 function Animal(name) { this.name = name this.colors = ['black', 'white'] } Animal.prototype.getName = function() { return this.name } function Dog(name, age) { Animal.call(this, name) this.age = age } Dog.prototype = new Animal() Dog.prototype.constructor = Dog let dog1 = new Dog('奶昔', 2) dog1.colors.push('brown') let dog2 = new Dog('哈赤', 1) console.log(dog2) // { name: \"哈赤\", colors: [\"black\", \"white\"], age: 1 } 寄生式组合继承 组合继承已经相对完善了，但还是存在问题，它的问题就是调用了 2 次父类构造函数，第一次是在 new Animal()，第二次是在 Animal.call() 这里。 所以解决方案就是不直接调用父类构造函数给子类原型赋值，而是通过创建空函数 F 获取父类原型的副本。 寄生式组合继承写法上和组合继承基本类似，区别是如下这里： - Dog.prototype = new Animal() - Dog.prototype.constructor = Dog + function F() {} + F.prototype = Animal.prototype + let f = new F() + f.constructor = Dog + Dog.prototype = f 稍微封装下上面添加的代码后： function object(o) { function F() {} F.prototype = o return new F() } function inheritPrototype(child, parent) { let prototype = object(parent.prototype) prototype.constructor = child child.prototype = prototype } inheritPrototype(Dog, Animal) 如果你嫌弃上面的代码太多了，还可以基于组合继承的代码改成最简单的寄生式组合继承： - Dog.prototype = new Animal() - Dog.prototype.constructor = Dog + Dog.prototype = Object.create(Animal.prototype) + Dog.prototype.constructor = Dog class 实现继承 class Animal { constructor(name) { this.name = name } getName() { return this.name } } class Dog extends Animal { constructor(name, age) { super(name) this.age = age } } 数组去重 ES5 实现： function unique(arr) { var res = arr.filter(function(item, index, array) { return array.indexOf(item) === index }) return res } ES6 实现： var unique = arr => [...new Set(arr)] 数组扁平化 数组扁平化就是将 [1, [2, [3]]] 这种多层的数组拍平成一层 [1, 2, 3]。使用 Array.prototype.flat 可以直接将多层数组拍平成一层： [1, [2, [3]]].flat(2) // [1, 2, 3] 现在就是要实现 flat 这种效果。 ES5 实现：递归。 function flatten(arr) { var result = []; for (var i = 0, len = arr.length; i ES6 实现： function flatten(arr) { while (arr.some(item => Array.isArray(item))) { arr = [].concat(...arr); } return arr; } 深浅拷贝 浅拷贝：只考虑对象类型。 function shallowCopy(obj) { if (typeof obj !== 'object') return let newObj = obj instanceof Array ? [] : {} for (let key in obj) { if (obj.hasOwnProperty(key)) { newObj[key] = obj[key] } } return newObj } 简单版深拷贝：只考虑普通对象属性，不考虑内置对象和函数。 function deepClone(obj) { if (typeof obj !== 'object') return; var newObj = obj instanceof Array ? [] : {}; for (var key in obj) { if (obj.hasOwnProperty(key)) { newObj[key] = typeof obj[key] === 'object' ? deepClone(obj[key]) : obj[key]; } } return newObj; } 复杂版深克隆：基于简单版的基础上，还考虑了内置对象比如 Date、RegExp 等对象和函数以及解决了循环引用的问题。 const isObject = (target) => (typeof target === \"object\" || typeof target === \"function\") && target !== null; function deepClone(target, map = new WeakMap()) { if (map.get(target)) { return target; } // 获取当前值的构造函数：获取它的类型 let constructor = target.constructor; // 检测当前对象target是否与正则、日期格式对象匹配 if (/^(RegExp|Date)$/i.test(constructor.name)) { // 创建一个新的特殊对象(正则类/日期类)的实例 return new constructor(target); } if (isObject(target)) { map.set(target, true); // 为循环引用的对象做标记 const cloneTarget = Array.isArray(target) ? [] : {}; for (let prop in target) { if (target.hasOwnProperty(prop)) { cloneTarget[prop] = deepClone(target[prop], map); } } return cloneTarget; } else { return target; } } 事件总线（发布订阅模式） class EventEmitter { constructor() { this.cache = {} } on(name, fn) { if (this.cache[name]) { this.cache[name].push(fn) } else { this.cache[name] = [fn] } } off(name, fn) { let tasks = this.cache[name] if (tasks) { const index = tasks.findIndex(f => f === fn || f.callback === fn) if (index >= 0) { tasks.splice(index, 1) } } } emit(name, once = false, ...args) { if (this.cache[name]) { // 创建副本，如果回调函数内继续注册相同事件，会造成死循环 let tasks = this.cache[name].slice() for (let fn of tasks) { fn(...args) } if (once) { delete this.cache[name] } } } } // 测试 let eventBus = new EventEmitter() let fn1 = function(name, age) { console.log(`${name} ${age}`) } let fn2 = function(name, age) { console.log(`hello, ${name} ${age}`) } eventBus.on('aaa', fn1) eventBus.on('aaa', fn2) eventBus.emit('aaa', false, '布兰', 12) // '布兰 12' // 'hello, 布兰 12' 解析 URL 参数为对象 function parseParam(url) { const paramsStr = /.+\\?(.+)$/.exec(url)[1]; // 将 ? 后面的字符串取出来 const paramsArr = paramsStr.split('&'); // 将字符串以 & 分割后存到数组中 let paramsObj = {}; // 将 params 存到对象中 paramsArr.forEach(param => { if (/=/.test(param)) { // 处理有 value 的参数 let [key, val] = param.split('='); // 分割 key 和 value val = decodeURIComponent(val); // 解码 val = /^\\d+$/.test(val) ? parseFloat(val) : val; // 判断是否转为数字 if (paramsObj.hasOwnProperty(key)) { // 如果对象有 key，则添加一个值 paramsObj[key] = [].concat(paramsObj[key], val); } else { // 如果对象没有这个 key，创建 key 并设置值 paramsObj[key] = val; } } else { // 处理没有 value 的参数 paramsObj[param] = true; } }) return paramsObj; } 字符串模板 function render(template, data) { const reg = /\\{\\{(\\w+)\\}\\}/; // 模板字符串正则 if (reg.test(template)) { // 判断模板里是否有模板字符串 const name = reg.exec(template)[1]; // 查找当前模板里第一个模板字符串的字段 template = template.replace(reg, data[name]); // 将第一个模板字符串渲染 return render(template, data); // 递归的渲染并返回渲染后的结构 } return template; // 如果模板没有模板字符串直接返回 } 测试： let template = '我是{{name}}，年龄{{age}}，性别{{sex}}'; let person = { name: '布兰', age: 12 } render(template, person); // 我是布兰，年龄12，性别undefined 图片懒加载 与普通的图片懒加载不同，如下这个多做了 2 个精心处理： 图片全部加载完成后移除事件监听； 加载完的图片，从 imgList 移除； let imgList = [...document.querySelectorAll('img')] let length = imgList.length const imgLazyLoad = function() { let count = 0 return function() { let deleteIndexList = [] imgList.forEach((img, index) => { let rect = img.getBoundingClientRect() if (rect.top !deleteIndexList.includes(index)) } } // 这里最好加上防抖处理 document.addEventListener('scroll', imgLazyLoad) 参考：图片懒加载[1] 函数防抖 触发高频事件 N 秒后只会执行一次，如果 N 秒内事件再次触发，则会重新计时。 简单版：函数内部支持使用 this 和 event 对象； function debounce(func, wait) { var timeout; return function () { var context = this; var args = arguments; clearTimeout(timeout) timeout = setTimeout(function(){ func.apply(context, args) }, wait); } } 使用： var node = document.getElementById('layout') function getUserAction(e) { console.log(this, e) // 分别打印：node 这个节点 和 MouseEvent node.innerHTML = count++; }; node.onmousemove = debounce(getUserAction, 1000) 最终版：除了支持 this 和 event 外，还支持以下功能： 支持立即执行； 函数可能有返回值； 支持取消功能； function debounce(func, wait, immediate) { var timeout, result; var debounced = function () { var context = this; var args = arguments; if (timeout) clearTimeout(timeout); if (immediate) { // 如果已经执行过，不再执行 var callNow = !timeout; timeout = setTimeout(function(){ timeout = null; }, wait) if (callNow) result = func.apply(context, args) } else { timeout = setTimeout(function(){ func.apply(context, args) }, wait); } return result; }; debounced.cancel = function() { clearTimeout(timeout); timeout = null; }; return debounced; } 使用： var setUseAction = debounce(getUserAction, 10000, true); // 使用防抖 node.onmousemove = setUseAction // 取消防抖 setUseAction.cancel() 参考：JavaScript专题之跟着underscore学防抖 函数节流 触发高频事件，且 N 秒内只执行一次。 简单版：使用时间戳来实现，立即执行一次，然后每 N 秒执行一次。 function throttle(func, wait) { var context, args; var previous = 0; return function() { var now = +new Date(); context = this; args = arguments; if (now - previous > wait) { func.apply(context, args); previous = now; } } } 最终版：支持取消节流；另外通过传入第三个参数，options.leading 来表示是否可以立即执行一次，opitons.trailing 表示结束调用的时候是否还要执行一次，默认都是 true。注意设置的时候不能同时将 leading 或 trailing 设置为 false。 function throttle(func, wait, options) { var timeout, context, args, result; var previous = 0; if (!options) options = {}; var later = function() { previous = options.leading === false ? 0 : new Date().getTime(); timeout = null; func.apply(context, args); if (!timeout) context = args = null; }; var throttled = function() { var now = new Date().getTime(); if (!previous && options.leading === false) previous = now; var remaining = wait - (now - previous); context = this; args = arguments; if (remaining wait) { if (timeout) { clearTimeout(timeout); timeout = null; } previous = now; func.apply(context, args); if (!timeout) context = args = null; } else if (!timeout && options.trailing !== false) { timeout = setTimeout(later, remaining); } }; throttled.cancel = function() { clearTimeout(timeout); previous = 0; timeout = null; } return throttled; } 节流的使用就不拿代码举例了，参考防抖的写就行。 参考：JavaScript专题之跟着 underscore 学节流 函数柯里化 什么叫函数柯里化？其实就是将使用多个参数的函数转换成一系列使用一个参数的函数的技术。还不懂？来举个例子。 function add(a, b, c) { return a + b + c } add(1, 2, 3) let addCurry = curry(add) addCurry(1)(2)(3) 现在就是要实现 curry 这个函数，使函数从一次调用传入多个参数变成多次调用每次传一个参数。 function curry(fn) { let judge = (...args) => { if (args.length == fn.length) return fn(...args) return (...arg) => judge(...args, ...arg) } return judge } 偏函数 什么是偏函数？偏函数就是将一个 n 参的函数转换成固定 x 参的函数，剩余参数（n - x）将在下次调用全部传入。举个例子： function add(a, b, c) { return a + b + c } let partialAdd = partial(add, 1) partialAdd(2, 3) 发现没有，其实偏函数和函数柯里化有点像，所以根据函数柯里化的实现，能够能很快写出偏函数的实现： function partial(fn, ...args) { return (...arg) => { return fn(...args, ...arg) } } 如上这个功能比较简单，现在我们希望偏函数能和柯里化一样能实现占位功能，比如： function clg(a, b, c) { console.log(a, b, c) } let partialClg = partial(clg, '_', 2) partialClg(1, 3) // 依次打印：1, 2, 3 _ 占的位其实就是 1 的位置。相当于：partial(clg, 1, 2)，然后 partialClg(3)。明白了原理，我们就来写实现： function partial(fn, ...args) { return (...arg) => { args[index] = return fn(...args, ...arg) } } JSONP JSONP 核心原理：script 标签不受同源策略约束，所以可以用来进行跨域请求，优点是兼容性好，但是只能用于 GET 请求； const jsonp = ({ url, params, callbackName }) => { const generateUrl = () => { let dataSrc = '' for (let key in params) { if (params.hasOwnProperty(key)) { dataSrc += `${key}=${params[key]}&` } } dataSrc += `callback=${callbackName}` return `${url}?${dataSrc}` } return new Promise((resolve, reject) => { const scriptEle = document.createElement('script') scriptEle.src = generateUrl() document.body.appendChild(scriptEle) window[callbackName] = data => { resolve(data) document.removeChild(scriptEle) } }) } AJAX const getJSON = function(url) { return new Promise((resolve, reject) => { const xhr = XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject('Mscrosoft.XMLHttp'); xhr.open('GET', url, false); xhr.setRequestHeader('Accept', 'application/json'); xhr.onreadystatechange = function() { if (xhr.readyState !== 4) return; if (xhr.status === 200 || xhr.status === 304) { resolve(xhr.responseText); } else { reject(new Error(xhr.responseText)); } } xhr.send(); }) } 实现数组原型方法 forEach Array.prototype.forEach2 = function(callback, thisArg) { if (this == null) { throw new TypeError('this is null or not defined') } if (typeof callback !== \"function\") { throw new TypeError(callback + ' is not a function') } const O = Object(this) // this 就是当前的数组 const len = O.length >>> 0 // 后面有解释 let k = 0 while (k 参考：forEach#polyfill[2] O.length >>> 0 是什么操作？就是无符号右移 0 位，那有什么意义嘛？就是为了保证转换后的值为正整数。其实底层做了 2 层转换，第一是非 number 转成 number 类型，第二是将 number 转成 Uint32 类型。感兴趣可以阅读 something >>> 0是什么意思?[3]。 map 基于 forEach 的实现能够很容易写出 map 的实现： - Array.prototype.forEach2 = function(callback, thisArg) { + Array.prototype.map2 = function(callback, thisArg) { if (this == null) { throw new TypeError('this is null or not defined') } if (typeof callback !== \"function\") { throw new TypeError(callback + ' is not a function') } const O = Object(this) const len = O.length >>> 0 - let k = 0 + let k = 0, res = [] while (k filter 同样，基于 forEach 的实现能够很容易写出 filter 的实现： - Array.prototype.forEach2 = function(callback, thisArg) { + Array.prototype.filter2 = function(callback, thisArg) { if (this == null) { throw new TypeError('this is null or not defined') } if (typeof callback !== \"function\") { throw new TypeError(callback + ' is not a function') } const O = Object(this) const len = O.length >>> 0 - let k = 0 + let k = 0, res = [] while (k some 同样，基于 forEach 的实现能够很容易写出 some 的实现： - Array.prototype.forEach2 = function(callback, thisArg) { + Array.prototype.some2 = function(callback, thisArg) { if (this == null) { throw new TypeError('this is null or not defined') } if (typeof callback !== \"function\") { throw new TypeError(callback + ' is not a function') } const O = Object(this) const len = O.length >>> 0 let k = 0 while (k reduce Array.prototype.reduce2 = function(callback, initialValue) { if (this == null) { throw new TypeError('this is null or not defined') } if (typeof callback !== \"function\") { throw new TypeError(callback + ' is not a function') } const O = Object(this) const len = O.length >>> 0 let k = 0, acc if (arguments.length > 1) { acc = initialValue } else { // 没传入初始值的时候，取数组中第一个非 empty 的值为初始值 while (k len) { throw new TypeError( 'Reduce of empty array with no initial value' ); } acc = O[k++] } while (k 实现函数原型方法 call 使用一个指定的 this 值和一个或多个参数来调用一个函数。 实现要点： this 可能传入 null； 传入不固定个数的参数； 函数可能有返回值； Function.prototype.call2 = function (context) { var context = context || window; context.fn = this; var args = []; for(var i = 1, len = arguments.length; i apply apply 和 call 一样，唯一的区别就是 call 是传入不固定个数的参数，而 apply 是传入一个数组。 实现要点： this 可能传入 null； 传入一个数组； 函数可能有返回值； Function.prototype.apply2 = function (context, arr) { var context = context || window; context.fn = this; var result; if (!arr) { result = context.fn(); } else { var args = []; for (var i = 0, len = arr.length; i bind bind 方法会创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。 实现要点： bind() 除了 this 外，还可传入多个参数； bing 创建的新函数可能传入多个参数； 新函数可能被当做构造函数调用； 函数可能有返回值； Function.prototype.bind2 = function (context) { var self = this; var args = Array.prototype.slice.call(arguments, 1); var fNOP = function () {}; var fBound = function () { var bindArgs = Array.prototype.slice.call(arguments); return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs)); } fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; } 实现 new 关键字 new 运算符用来创建用户自定义的对象类型的实例或者具有构造函数的内置对象的实例。 实现要点： new 会产生一个新对象； 新对象需要能够访问到构造函数的属性，所以需要重新指定它的原型； 构造函数可能会显示返回； function objectFactory() { var obj = new Object() Constructor = [].shift.call(arguments); obj.__proto__ = Constructor.prototype; var ret = Constructor.apply(obj, arguments); // ret || obj 这里这么写考虑了构造函数显示返回 null 的情况 return typeof ret === 'object' ? ret || obj : obj; }; 使用： function person(name, age) { this.name = name this.age = age } let p = objectFactory(person, '布兰', 12) console.log(p) // { name: '布兰', age: 12 } 实现 instanceof 关键字 instanceof 就是判断构造函数的 prototype 属性是否出现在实例的原型链上。 function instanceOf(left, right) { let proto = left.__proto__ while (true) { if (proto === null) return false if (proto === right.prototype) { return true } proto = proto.__proto__ } } 上面的 left.proto 这种写法可以换成 Object.getPrototypeOf(left)。 实现 Object.create Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。 Object.create2 = function(proto, propertyObject = undefined) { if (typeof proto !== 'object' && typeof proto !== 'function') { throw new TypeError('Object prototype may only be an Object or null.') if (propertyObject == null) { new TypeError('Cannot convert undefined or null to object') } function F() {} F.prototype = proto const obj = new F() if (propertyObject != undefined) { Object.defineProperties(obj, propertyObject) } if (proto === null) { // 创建一个没有原型对象的对象，Object.create(null) obj.__proto__ = null } return obj } 实现 Object.assign Object.assign2 = function(target, ...source) { if (target == null) { throw new TypeError('Cannot convert undefined or null to object') } let ret = Object(target) source.forEach(function(obj) { if (obj != null) { for (let key in obj) { if (obj.hasOwnProperty(key)) { ret[key] = obj[key] } } } }) return ret } 实现 JSON.stringify JSON.stringify([, replacer [, space]) 方法是将一个 JavaScript 值(对象或者数组)转换为一个 JSON 字符串。此处模拟实现，不考虑可选的第二个参数 replacer 和第三个参数 space，如果对这两个参数的作用还不了解，建议阅读 MDN[4] 文档。 基本数据类型： undefined 转换之后仍是 undefined(类型也是 undefined) boolean 值转换之后是字符串 \"false\"/\"true\" number 类型(除了 NaN 和 Infinity)转换之后是字符串类型的数值 symbol 转换之后是 undefined null 转换之后是字符串 \"null\" string 转换之后仍是string NaN 和 Infinity 转换之后是字符串 \"null\" 函数类型：转换之后是 undefined 如果是对象类型(非函数) 如果有 toJSON() 方法，那么序列化 toJSON() 的返回值。 如果属性值中出现了 undefined、任意的函数以及 symbol 值，忽略。 所有以 symbol 为属性键的属性都会被完全忽略掉。 如果是一个数组：如果属性值中出现了 undefined、任意的函数以及 symbol，转换成字符串 \"null\" ； 如果是 RegExp 对象：返回 {} (类型是 string)； 如果是 Date 对象，返回 Date 的 toJSON 字符串值； 如果是普通对象； 对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。 function jsonStringify(data) { let dataType = typeof data; if (dataType !== 'object') { let result = data; //data 可能是 string/number/null/undefined/boolean if (Number.isNaN(data) || data === Infinity) { //NaN 和 Infinity 序列化返回 \"null\" result = \"null\"; } else if (dataType === 'function' || dataType === 'undefined' || dataType === 'symbol') { //function 、undefined 、symbol 序列化返回 undefined return undefined; } else if (dataType === 'string') { result = '\"' + data + '\"'; } //boolean 返回 String() return String(result); } else if (dataType === 'object') { if (data === null) { return \"null\" } else if (data.toJSON && typeof data.toJSON === 'function') { return jsonStringify(data.toJSON()); } else if (data instanceof Array) { let result = []; //如果是数组 //toJSON 方法可以存在于原型链中 data.forEach((item, index) => { if (typeof item === 'undefined' || typeof item === 'function' || typeof item === 'symbol') { result[index] = \"null\"; } else { result[index] = jsonStringify(item); } }); result = \"[\" + result + \"]\"; return result.replace(/'/g, '\"'); } else { //普通对象 /** * 循环引用抛错(暂未检测，循环引用时，堆栈溢出) * symbol key 忽略 * undefined、函数、symbol 为属性值，被忽略 */ let result = []; Object.keys(data).forEach((item, index) => { if (typeof item !== 'symbol') { //key 如果是symbol对象，忽略 if (data[item] !== undefined && typeof data[item] !== 'function' && typeof data[item] !== 'symbol') { //键值如果是 undefined、函数、symbol 为属性值，忽略 result.push('\"' + item + '\"' + \":\" + jsonStringify(data[item])); } } }); return (\"{\" + result + \"}\").replace(/'/g, '\"'); } } } 参考：实现 JSON.stringify[5] 实现 JSON.parse 介绍 2 种方法实现： eval 实现； new Function 实现； eval 实现 第一种方式最简单，也最直观，就是直接调用 eval，代码如下： var json = '{\"a\":\"1\", \"b\":2}'; var obj = eval(\"(\" + json + \")\"); // obj 就是 json 反序列化之后得到的对象 但是直接调用 eval 会存在安全问题，如果数据中可能不是 json 数据，而是可执行的 JavaScript 代码，那很可能会造成 XSS 攻击。因此，在调用 eval 之前，需要对数据进行校验。 var rx_one = /^[\\],:{}\\s]*$/; var rx_two = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g; var rx_three = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g; var rx_four = /(?:^|:|,)(?:\\s*\\[)+/g; if ( rx_one.test( json.replace(rx_two, \"@\") .replace(rx_three, \"]\") .replace(rx_four, \"\") ) ) { var obj = eval(\"(\" +json + \")\"); } 参考：JSON.parse 三种实现方式[6] new Function 实现 Function 与 eval 有相同的字符串参数特性。 var json = '{\"name\":\"小姐姐\", \"age\":20}'; var obj = (new Function('return ' + json))(); 实现 Promise 实现 Promise 需要完全读懂 Promise A+ 规范[7]，不过从总体的实现上看，有如下几个点需要考虑到： then 需要支持链式调用，所以得返回一个新的 Promise； 处理异步问题，所以得先用 onResolvedCallbacks 和 onRejectedCallbacks 分别把成功和失败的回调存起来； 为了让链式调用正常进行下去，需要判断 onFulfilled 和 onRejected 的类型； onFulfilled 和 onRejected 需要被异步调用，这里用 setTimeout 模拟异步； 处理 Promise 的 resolve； const PENDING = 'pending'; const FULFILLED = 'fulfilled'; const REJECTED = 'rejected'; class Promise { constructor(executor) { this.status = PENDING; this.value = undefined; this.reason = undefined; this.onResolvedCallbacks = []; this.onRejectedCallbacks = []; let resolve = (value) = > { if (this.status === PENDING) { this.status = FULFILLED; this.value = value; this.onResolvedCallbacks.forEach((fn) = > fn()); } }; let reject = (reason) = > { if (this.status === PENDING) { this.status = REJECTED; this.reason = reason; this.onRejectedCallbacks.forEach((fn) = > fn()); } }; try { executor(resolve, reject); } catch (error) { reject(error); } } then(onFulfilled, onRejected) { // 解决 onFufilled，onRejected 没有传值的问题 onFulfilled = typeof onFulfilled === \"function\" ? onFulfilled : (v) = > v; // 因为错误的值要让后面访问到，所以这里也要抛出错误，不然会在之后 then 的 resolve 中捕获 onRejected = typeof onRejected === \"function\" ? onRejected : (err) = > { throw err; }; // 每次调用 then 都返回一个新的 promise let promise2 = new Promise((resolve, reject) = > { if (this.status === FULFILLED) { //Promise/A+ 2.2.4 --- setTimeout setTimeout(() = > { try { let x = onFulfilled(this.value); // x可能是一个proimise resolvePromise(promise2, x, resolve, reject); } catch (e) { reject(e); } }, 0); } if (this.status === REJECTED) { //Promise/A+ 2.2.3 setTimeout(() = > { try { let x = onRejected(this.reason); resolvePromise(promise2, x, resolve, reject); } catch (e) { reject(e); } }, 0); } if (this.status === PENDING) { this.onResolvedCallbacks.push(() = > { setTimeout(() = > { try { let x = onFulfilled(this.value); resolvePromise(promise2, x, resolve, reject); } catch (e) { reject(e); } }, 0); }); this.onRejectedCallbacks.push(() = > { setTimeout(() = > { try { let x = onRejected(this.reason); resolvePromise(promise2, x, resolve, reject); } catch (e) { reject(e); } }, 0); }); } }); return promise2; } } const resolvePromise = (promise2, x, resolve, reject) = > { // 自己等待自己完成是错误的实现，用一个类型错误，结束掉 promise Promise/A+ 2.3.1 if (promise2 === x) { return reject( new TypeError(\"Chaining cycle detected for promise #\")); } // Promise/A+ 2.3.3.3.3 只能调用一次 let called; // 后续的条件要严格判断 保证代码能和别的库一起使用 if ((typeof x === \"object\" && x != null) || typeof x === \"function\") { try { // 为了判断 resolve 过的就不用再 reject 了（比如 reject 和 resolve 同时调用的时候） Promise/A+ 2.3.3.1 let then = x.then; if (typeof then === \"function\") { // 不要写成 x.then，直接 then.call 就可以了 因为 x.then 会再次取值，Object.defineProperty Promise/A+ 2.3.3.3 then.call( x, (y) = > { // 根据 promise 的状态决定是成功还是失败 if (called) return; called = true; // 递归解析的过程（因为可能 promise 中还有 promise） Promise/A+ 2.3.3.3.1 resolvePromise(promise2, y, resolve, reject); }, (r) = > { // 只要失败就失败 Promise/A+ 2.3.3.3.2 if (called) return; called = true; reject(r); }); } else { // 如果 x.then 是个普通值就直接返回 resolve 作为结果 Promise/A+ 2.3.3.4 resolve(x); } } catch (e) { // Promise/A+ 2.3.3.2 if (called) return; called = true; reject(e); } } else { // 如果 x 是个普通值就直接返回 resolve 作为结果 Promise/A+ 2.3.4 resolve(x); } }; Promise 写完之后可以通过 promises-aplus-tests 这个包对我们写的代码进行测试，看是否符合 A+ 规范。不过测试前还得加一段代码： // promise.js // 这里是上面写的 Promise 全部代码 Promise.defer = Promise.deferred = function () { let dfd = {} dfd.promise = new Promise((resolve,reject)=>{ dfd.resolve = resolve; dfd.reject = reject; }); return dfd; } module.exports = Promise; 全局安装： npm i promises-aplus-tests -g 终端下执行验证命令： promises-aplus-tests promise.js 上面写的代码可以顺利通过全部 872 个测试用例。 参考： BAT前端经典面试问题：史上最最最详细的手写Promise教程[8] 100 行代码实现 Promises/A+ 规范[9] Promise.resolve Promsie.resolve(value) 可以将任何值转成值为 value 状态是 fulfilled 的 Promise，但如果传入的值本身是 Promise 则会原样返回它。 Promise.resolve = function(value) { // 如果是 Promsie，则直接输出它 if(value instanceof Promise){ return value } return new Promise(resolve => resolve(value)) } 参考：深入理解 Promise[10] Promise.reject 和 Promise.resolve() 类似，Promise.reject() 会实例化一个 rejected 状态的 Promise。但与 Promise.resolve() 不同的是，如果给 Promise.reject() 传递一个 Promise 对象，则这个对象会成为新 Promise 的值。 Promise.reject = function(reason) { return new Promise((resolve, reject) => reject(reason)) } Promise.all Promise.all 的规则是这样的： 传入的所有 Promsie 都是 fulfilled，则返回由他们的值组成的，状态为 fulfilled 的新 Promise； 只要有一个 Promise 是 rejected，则返回 rejected 状态的新 Promsie，且它的值是第一个 rejected 的 Promise 的值； 只要有一个 Promise 是 pending，则返回一个 pending 状态的新 Promise； Promise.all = function(promiseArr) { let index = 0, result = [] return new Promise((resolve, reject) => { promiseArr.forEach((p, i) => { Promise.resolve(p).then(val => { index++ result[i] = val if (index === promiseArr.length) { resolve(result) } }, err => { reject(err) }) }) }) } Promise.race Promise.race 会返回一个由所有可迭代实例中第一个 fulfilled 或 rejected 的实例包装后的新实例。 Promise.race = function(promiseArr) { return new Promise((resolve, reject) => { promiseArr.forEach(p => { Promise.resolve(p).then(val => { resolve(val) }, err => { rejecte(err) }) }) }) } Promise.allSettled Promise.allSettled 的规则是这样： 所有 Promise 的状态都变化了，那么新返回一个状态是 fulfilled 的 Promise，且它的值是一个数组，数组的每项由所有 Promise 的值和状态组成的对象； 如果有一个是 pending 的 Promise，则返回一个状态是 pending 的新实例； Promise.allSettled = function(promiseArr) { let result = [] return new Promise((resolve, reject) => { promiseArr.forEach((p, i) => { Promise.resolve(p).then(val => { result.push({ status: 'fulfilled', value: val }) if (result.length === promiseArr.length) { resolve(result) } }, err => { result.push({ status: 'rejected', reason: err }) if (result.length === promiseArr.length) { resolve(result) } }) }) }) } Promise.any Promise.any 的规则是这样： 空数组或者所有 Promise 都是 rejected，则返回状态是 rejected 的新 Promsie，且值为 AggregateError 的错误； 只要有一个是 fulfilled 状态的，则返回第一个是 fulfilled 的新实例； 其他情况都会返回一个 pending 的新实例； Promise.any = function(promiseArr) { let index = 0 return new Promise((resolve, reject) => { if (promiseArr.length === 0) return promiseArr.forEach((p, i) => { Promise.resolve(p).then(val => { resolve(val) }, err => { index++ if (index === promiseArr.length) { reject(new AggregateError('All promises were rejected')) } }) }) }) } 后话 能看到这里的对代码都是真爱了，毕竟代码这玩意看起来是真的很枯燥，但是如果看懂了后，就会像打游戏赢了一样开心，而且这玩意会上瘾，当你通关了越多的关卡后，你的能力就会拔高一个层次。 参考资料 [1] 图片懒加载: https://juejin.cn/post/6844903856489365518#heading-19 [2] forEach#polyfill: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#polyfill [3] something >>> 0是什么意思: https://zhuanlan.zhihu.com/p/100790268 [4] stringify: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify [5] 实现 JSON.stringify: https://github.com/YvetteLau/Step-By-Step/issues/39#issuecomment-508327280 [6] JSON.parse 三种实现方式: https://github.com/youngwind/blog/issues/115#issue-300869613 [7] Promise A+ 规范: https://promisesaplus.com/ [8] BAT前端经典面试问题：史上最最最详细的手写Promise教程: https://juejin.cn/post/6844903625769091079 [9] 100 行代码实现 Promises/A+ 规范: https://mp.weixin.qq.com/s/qdJ0Xd8zTgtetFdlJL3P1g [10] 深入理解 Promise: https://bubuzou.com/2020/10/22/promise/ Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-22 14:30:56 "},"前端杂项/骨架屏项目实践.html":{"url":"前端杂项/骨架屏项目实践.html","title":"骨架屏项目实践","keywords":"","body":"骨架屏项目实践 (vue) page-skeleton-webpack-plugin https://github.com/ElemeFE/page-skeleton-webpack-plugin vue.config.js const { SkeletonPlugin } = require('page-skeleton-webpack-plugin') const pageSkeleton = new SkeletonPlugin({ pathname: path.resolve(__dirname, './shell'), // 用来存储 shell 文件的地址 staticDir: path.resolve(__dirname, './dist'), // 最好和 `output.path` 相同 routes: ['/', '/login', '/act', '/home', '/task', '/notice'] // 将需要生成骨架屏的路由添加到数组中 }) module.exports = { configureWebpack:{ plugins } } routes:[/] 测试结果 一定要带 根路由 不然其他的路由页面无法渲染出来 在模版文件 /public/index.html 中 开启shell展位符 设置 打包生产是 要注意 不要删除模版页面的 注释信息 module.exports ={ chainWebpack(config){ if (!isDev) { config.plugin('html').tap(opts => { opts[0].minify.removeComments = false return opts }) } } } 注意是事项。开启报占据端口问题 找到插件 SkeletonPlugin.prototype.createServer = function () { // eslint-disable-line func-names if (!this.server) { const server = this.server = new Server(this.options) // eslint-disable-line no-multi-assign server.listen().catch(err => server.log.warn(err)) } } 如果路由 做了权限 特别是根路由做了redirect 这个时候要注意 放开权限 防止 preview 页面找不到 vue-skeleton-webpack-plugin https://github.com/lavas-project/vue-skeleton-webpack-plugin const SkeletonWebpackPlugin = require('vue-skeleton-webpack-plugin'); const vueSkeleton = new SkeletonWebpackPlugin({ webpackConfig: { entry: { app: resolve('./src/skeleton/entry-skeleton.js') } }, quiet: true, minimize: true, router: { mode: 'history', routes: [ { path: '/login', skeletonId: 'skeleton1' }, { path: '*', skeletonId: 'skeleton2' } ] } }) module.exports = { configureWebpack:{ plugins:[vueSkeleton] } } ​ entry-skeleton.js import Vue from 'vue' import Skeleton1 from './Skeleton1' import Skeleton2 from './Skeleton2' export default new Vue({ components: { Skeleton1, Skeleton2 }, template: ` ` }) Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-19 18:32:39 "},"前端框架/vue3/Vue3 学习手册.html":{"url":"前端框架/vue3/Vue3 学习手册.html","title":"手册","keywords":"","body":"Vue3 学习手册 setup 内部定义变量 需要 实际操作 ``` import {ref} from 'vue' export default { setup(props ,context) { // 注意 this 里面setup()，this不会对当前的活动实例的引用自setup()其他组件选项都解决了之前被调用，this里面setup()会表现得很不同于this其他选项。setup()与其他Options API一起使用时，这可能会造成混乱。 // setup 执行时 组建尚未建立 so 只能访问 props，attrs,slots, emit 不能访问 data computed methods //props 是响应式的 在没有给定默认值的情况下不能用来结构 // context {attrs ,slots, emit} const data = ref(0) return { data ,// 在模版中你使用时不需要 data.value 引用ref 会自动解包 } } } ``` 生命周期 Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-19 19:02:15 "},"前端框架/react 不使用 eject 的配置方法（config-overrides 复现 vue 项目全部配置config-overrides.html":{"url":"前端框架/react 不使用 eject 的配置方法（config-overrides 复现 vue 项目全部配置config-overrides.html","title":"react_config-overridess","keywords":"","body":" 本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net 基础依赖 暴露全部配置 eject 十分不友好，我们基于 customize-cra 和 react-app-rewired 进行自定义配置： yarn add -D customize-cra react-app-rewired 之后修改 package.json 的 scripts 部分： \"scripts\": { \"start\": \"react-app-rewired start\", \"build\": \"react-app-rewired build\", \"test\": \"react-app-rewired test\", \"_eject\": \"react-scripts eject\" }, 注意前三个命令只是把原来的 react-scripts 替换为了 react-app-rewired ，最后 eject 为了安全我加了下划线（你也可以不修改最后一行 eject ）。 下面就可以开始自定义配置了。 config-overrides.js 根目录下建立一个配置重写文件 config-overrides.js ，刚刚安装的依赖就会注入 react 内帮我们 override 相应的配置。 总体把握 我们开一个新项目，使用 eject 暴露所有配置，会发现根目录下生成了 config 目录，下面有 react 的所有配置文件： 很多教程都只讲如何配置 webpack.config.js ，那其他文件怎么配置呢？ 自定义配置 react 打包生成目录 在 config-overrides.js 写入如下内容： const path = require('path') function resolve(dir) { return path.join(__dirname, dir) } module.exports = { paths: function (paths) { paths.appBuild = resolve('./dist') return paths } } 先导入了 path 依赖并写了 resolve() 函数用来补全路径，path.resolve() 这个函数也可以补全，不过在 ('/a', '/b') 情况下，只有 path.join() 是可以补全为 /a/b 的。 之后导出我们要重写的配置对象，键就是你要重写的配置文件名，要重写 paths.js ，那就是 paths 这个键下进行重写。 之后 build 打包生成的内容就会在 ./dist 下而不是默认的 ./build 下。 查看所有 paths.js 配置 如果你要查看所有 paths.js 的配置，第一种方法你重开一个 react 项目使用 eject 去查看有什么选项，第二种方法你在里面打印即可： module.exports = { paths: function (paths) { paths.appBuild = resolve('./dist') console.log(paths) return paths } } 我们执行 yarn start 就可以看到所有配置了： 这些配置和 eject 暴露全部配置后生成的 paths.js 是一样的： 配置 webpack 根据上面的经验，我们配置 webpack 只需要如下写法即可： module.exports = { webpack: override() } 下面几个例子简单说明。 配置路径 @ 快捷前缀 在 customize-cra 里给我们提供了一些封装好的 api ，我们直接使用就可以： const { override, addWebpackAlias } = require('customize-cra') const path = require('path') function resolve(dir) { return path.join(__dirname, dir) } module.exports = { webpack: override( addWebpackAlias({ '@': resolve('src') }) } 这里使用了 addWebpackAlias() 这个 api ，十分方便。 完整 api 请查看：官方 api 文档 配置 less 编译器 先安装基本依赖： yarn add -D less less-loader react-app-rewire-less react-app-rewire-less-modules 之后配置 config-overrides.js ： const { override, addWebpackAlias } = require('customize-cra') const path = require('path') function resolve(dir) { return path.join(__dirname, dir) } module.exports = { webpack: override( addLessLoader() } 这样就可以打开 less-loader 了。 在 less 中添加全局变量 如果我们直接在项目入口 index.jsx 或 app.jsx 导入 .less 是不能识别到定义的变量的（样式可以），我们要在 less-loader 选项中导入全局资源： module.exports = { webpack: override( addLessLoader({ additionalData: `@import \"${ resolve('./src/assets/css/variable.less') }\";` }) } 官方对 addLessLoader() 这个 api 的参数定义是 loaderOptions ，也就是说里面可以传 less-loader 的配置对象。 less-loader 可配置项：webpack-contrib / less-loader 注：正如 vue-cli 在 css 相关 所说，该 @import \"...\"; 导入语句结尾必须要有分号！ 查看所有 webpack 配置 customize-cra 给我们提供的 api 不多，但是如同之前配置 paths.js 所说，我们可以用一个函数配置全部 webpack 的配置： const fs = require('fs') module.exports = { webpack: override( (config) => { if (process.env.NODE_ENV === \"production\") { // 进行生产环境的配置 } // 打印配置 console.log(config) // 输出到文件（有些对象内部配置没法在控制台显示） fs.writeFileSync(`./config-${process.env.NODE_ENV}.json`, JSON.stringify(config)) } ) } 注：该函数只能传入一次。 下面说几个实用配置。 随心所欲配置法 如果你在上面一步中将 config 打印到了控制台，你会发现插件都无法显示内部配置： 但是输出到文件会发现，丢失了插件名字，成了一个个对象： 好心的 OptimizeCssAssetsWebpackPlugin 还给我们准备了插件说明，但是 TerserPlugin 却只是一个配置对象，没有任何说明，我们也不知道哪个对象是哪个插件的。 我们可以使用构造函数名字解决这个问题： /** * @param target: 要遍历的对象 * @param name: 插件名 * @param callback: 回调函数，第一个参数为该插件对象 * @return null */ function invade(target, name, callback) { target.forEach( item => { if (item.constructor.name === name) { callback(item) } } ) } 生产环境去除 console.log 有了上面的 invade() 函数，我们可以这样写： module.exports = { webpack: override( (config) => { if (process.env.NODE_ENV === \"production\") { invade(config.optimization.minimizer, 'TerserPlugin', (e) => { // 去除 LICENSE.txt e.options.extractComments = false // 去除生产环境 console.log e.options.terserOptions.compress.drop_console = true }) } } ) } 关闭 sourceMap react 官方很好心的给我们准备了这个环境变量，在 eject 后的 webpack.config.js 可以看到： 在根目录建立 .env.production ： GENERATE_SOURCEMAP = false 关闭生产环境 devtool module.exports = { webpack: override( (config) => { if (process.env.NODE_ENV === \"production\") { config.devtool = false; } ) } 漂亮的打包 js/css 文件名 默认打包后文件名带 .chunk 结尾，去掉即可： module.exports = { webpack: override( (config) => { if (process.env.NODE_ENV === \"production\") { // 美化打包后 js 文件名 config.output.chunkFilename = config.output.chunkFilename.replace('.chunk', '') // 美化打包后 css 文件名 invade(config.plugins, 'MiniCssExtractPlugin', (e) => { e.options.chunkFilename = e.options.chunkFilename.replace('.chunk', '') }) } ) } runtime 内联策略 有关 runtime 为何要内联，简单的说就是避免几 K 的文件还要单独加载一次，提高加载速度，你可以查找一些其他资料深入学习。 需要说的一点是，react 官方给我们提供了 process.env.INLINE_RUNTIME_CHUNK 选项，但是他不会配合 babel ，生成的 runtime 内联到 index.html 后仍然在 js 文件夹下生成，这是不友好的。 我们使用 script-ext-html-webpack-plugin ： yarn add -D script-ext-html-webpack-plugin 配置： const ScriptExtHtmlWebpackPlugin = require('script-ext-html-webpack-plugin') module.exports = { webpack: override( (config) => { if (process.env.NODE_ENV === \"production\") { config.plugins.push( new ScriptExtHtmlWebpackPlugin( { // `runtime` must same as runtimeChunk name. default is `runtime` inline: /runtime\\..*\\.js$/ }) ) // 单一整合 runtime config.optimization.runtimeChunk = 'single' } ) } 注：不知道有没有细心的人会疑惑，customize-cra 给我们提供了 addWebpackPlugin() 的快捷 api 啊，为啥还要 push ，这里不详细说明了，有兴趣可以去查一下该 api 的代码，也是做了 config.push() ，在我们自定义的 (config) => { } 函数里用了是不生效的，因为没有 config 对象给他了，只能在外面用。 外面怎么用？ module.exports = { webpack: override( process.env.NODE_ENV === \"production\" ? addWebpackPlugin(new ScriptExtHtmlWebpackPlugin(...)) : null ) } 应该没有人会这么用。 之后再打包就会发现，runtime 内联到了 index.html ，并且在 js 文件夹下不再生成了。 打包 splitChunks 分块策略 splitChunks: { chunks: 'async', //指定代码分割样式 async异步 initial同步 all所有 minSize: 30000, //指定执行分割代码的最小大小，默认为30000字节(30kb)，所以如果需要打包的文件小于30kb的不进行打包 maxSize: 0, //限制打包的空间大小,比如某个打包文件为1Mb，maxSize设为100kb，那他的打包文件就会想方设法将打包文件分成每份为100kb或以下进行拆分打包，一般用默认配置即可，以后业务需要用到的话再单独设置 minChunks: 1, //该参数就是命令行中每次导包都可以看到的打包参数Chunks maxAsyncRequests: 5,// 指定入口文件中最大打包的异步代码数，默认5 maxInitialRequests: 3,//指定入口文件中最大打包的同步代码数，默认3 automaticNameDelimiter: '~', // 指定生成默认的命名时之间的连接符，如符合vendors规则打包的，生成的打包文件名就是vendors~main.js name: true, cacheGroups: { //缓存组，当符合上面配置时会记录在缓存组中，然后进入里面的规则对号入座进行打包输出,如果相同的出口的则会一起打包在一起，比如当前有两个第三方插件都符合vendors，则他们都会一同打包输出 vendors: { //符合在node_modules中的第三方插件库引入的，命名为vendors~xxx. test: /[\\\\/]node_modules[\\\\/]/, priority: -10 }, default: { //不符合在node_modules中的第三方插件库引入的，命名为default~xxx. minChunks: 2, priority: -20, //区分当同时符合vendors和default的，进行优先级处理，值越大优先级越高 reuseExistingChunk: true //检测模块是否被打包过，如果是则直接使用导包过的模块即可，缓存复用性 } } } } 这里直接把 vue 的搬过来： module.exports = { webpack: override( (config) => { if (process.env.NODE_ENV === \"production\") { config.optimization.splitChunks = { chunks: 'all', cacheGroups: { libs: { name: 'chunk-libs', test: /[\\\\/]node_modules[\\\\/]/, priority: 10, chunks: 'initial' // only package third parties that are initially dependent }, commons: { name: 'chunk-commons', test: resolve('src/components'), // can customize your rules minChunks: 3, // minimum common number priority: 5, reuseExistingChunk: true } } } } ) } 非常易懂，不详细说明了。 prefetch 策略 在预加载和懒加载上也有一定的学问，可以先学习这篇文章： 《[译] React 16.6 懒加载 (与预加载) 组件》 在 webpack 4 中这么用即可： () => import(/* webpackPrefetch: true */ \"./pages/home\") 有关 preload 请参考 这里 ，不需要 preload 。 其他 能参照 vue 进行的优化配置还有很多，比如 svg 的配置，自行参照搬过来即可。 还有两个没有说到： 我如何知道 react 内置了什么插件：请打印 config.plugins react 打包后路由块的文件名不好看：请配置 webpackChunkName ： () => import(/* webpackChunkName: \"home\" */ \"./pages/home\") 之后就会打包出来 home.contenthash.js 。 总结 本文全部配置如下： const { override, addLessLoader, addWebpackAlias } = require('customize-cra') // const fs = require('fs') const path = require('path') const ScriptExtHtmlWebpackPlugin = require('script-ext-html-webpack-plugin') /** * @param target: 要遍历的对象 * @param name: 插件名 * @param callback: 回调函数，第一个参数为该插件对象 * @return null */ function invade(target, name, callback) { target.forEach( item => { if (item.constructor.name === name) { callback(item) } } ) } function resolve(dir) { return path.join(__dirname, dir) } module.exports = { paths: function (paths) { paths.appBuild = resolve('./dist') return paths }, webpack: override( addWebpackAlias({ '@': resolve('src'), }), addLessLoader({ additionalData: `@import \"${ resolve('./src/assets/css/variable.less') }\";` }), (config) => { if (process.env.NODE_ENV === \"production\") { config.devtool = false; config.output.chunkFilename = config.output.chunkFilename.replace('.chunk', '') invade(config.optimization.minimizer, 'TerserPlugin', (e) => { e.options.extractComments = false e.options.terserOptions.compress.drop_console = true }) invade(config.plugins, 'MiniCssExtractPlugin', (e) => { e.options.chunkFilename = e.options.chunkFilename.replace('.chunk', '') }) config.optimization.splitChunks = { chunks: 'all', cacheGroups: { libs: { name: 'chunk-libs', test: /[\\\\/]node_modules[\\\\/]/, priority: 10, chunks: 'initial' // only package third parties that are initially dependent }, commons: { name: 'chunk-commons', test: resolve('src/components'), // can customize your rules minChunks: 3, // minimum common number priority: 5, reuseExistingChunk: true } } } config.plugins.push( new ScriptExtHtmlWebpackPlugin( { // `runtime` must same as runtimeChunk name. default is `runtime` inline: /runtime\\..*\\.js$/ }) ) config.optimization.runtimeChunk = 'single' } // fs.writeFileSync(`./config-${process.env.NODE_ENV}.json`, JSON.stringify(config)) return config } ) } 这不是一个完美的配置，还有一些细节和 svg 内联没有追究，有时间可以自行参照配一下，但基本上复现了在 vue 中我们的配置。 《vue-cli 创建项目后优化更多配置（一）》 《vue-cli 创建项目后优化更多配置（二）》 《vue-cli 创建项目后优化更多配置（三）》 Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-22 11:09:10 "},"前端框架/React 状态 管理工具.html":{"url":"前端框架/React 状态 管理工具.html","title":"react-状态管理","keywords":"","body":"React 状态 管理工具 redux ​ react-redux redux redux-thunk 全局 根节点 套 provider import React from \"react\"; import ReactDOM from \"react-dom\"; import { BrowserRouter } from \"react-router-dom\"; import { Provider } from \"react-redux\"; import { ConfigProvider } from \"antd\"; import store from \"./store\"; // import zhCN from \"antd/es/locale/zh_CN\"; import { isDev } from \"utils/config\"; import App from \"./App\"; const Router = BrowserRouter; ReactDOM.render( , document.getElementById(\"root\")); store 是所有的状态管理 import { applyMiddleware, createStore } from 'redux' // import thunk from 'redux-thunk' // 异步 import logger from 'redux-logger' // 日志。生产可以不用 import { isDev } from 'utils/config' import reducer from './reducer' // 各个模块的 状态控制 const middleWare = [thunk] if (isDev) { middleWare.push(logger) } const store = createStore(reducer, applyMiddleware(...middleWare)) export default store reducer import { combineReducers } from 'redux' import modules from './modules' // 所有模块的状态 const reducer = combineReducers(modules) export default reducer // modules/index.js // 利用 require.context. 将模块文件夹下所有文件映射 const files = require.context('.', false, /\\.js$/) const modules = {} files.keys().forEach(key => { if (key === './index.js') return modules[key.replace(/(\\.\\/|\\.js)/g, '')] = files(key).default }) export default modules // 单个 文件 的 reducer import { listModel } from 'utils/tools' const courseIno = { // 默认数据状态 manage: listModel(), manageScore: listModel(), target: listModel() } const status = { //action.type COURSE_MANAGE: 'manage', COURSE_MANAGE_SCORE: 'manageScore', COURSE_TARGET: 'target' } // 处理不同的 action const courseStore = (state = courseIno, action) => { const { type } = action if (status[type]) { return { ...state, [status[type]]: { ...action.payload }} } return state } export default courseStore // 异步 action // 在其他模块使用的 异步方法 可以把异步方法单独放文件使用 export const getSupport = (params) => { return async(dispatch) => { const p = await getData(API.SUPPORT_HEAD, params) const { errcode, data: lists } = p if (errcode !== 0) { return console.log(p.errmsg) } dispatch(createAction(ACTION.SUPPORT_HEAD)(lists)) } } 其他模块使用 import React from \"react\"; import { connect } from \"react-redux\"; import ContentTitle from \"component/ContentTitle\"; import BasePagination from \"component/BasePagination\"; import { Table, Button } from \"antd\"; import { courseManageScoreCols as tableCols } from \"utils/cols\"; import { HomeState } from \"utils/extends\"; import { getCourseManageScore as getList } from \"store/async\"; @connect( state => ({ lists: state.course.manageScore.lists.map((list, index) => { const { student: { class: classes, id, name, student_no } } = list; return { key: id, class: classes, name, student_no }; }), page: state.course.manageScore.page }), { getList } ) class ManageScore extends HomeState { constructor(props) { super(props); console.log(this); console.log(this.props); this.state.loading = true; this.state.training_plan_id = this.props.location.state.id; } componentDidMount() { const dom = this.refs.need; const ycal = dom.clientHeight * 0.6; this.setState({ scroll: { x: dom.clientWidth - 40, y: ycal } }); this.getList(); } componentWillReceiveProps(nextProps) { this.setState({ loading: false }); } getList = params => { const { page, page_size } = this.props.page; this.setState({ loading: true }); this.props.getList({ page, page_size, ...params, training_plan_id: this.state.training_plan_id }); }; render() { const { state } = this.props.location; const { scroll, search_params, loading } = this.state; const { lists, page } = this.props; return ( {state.h3}} btn={ 批量导入 新增 } /> ); } } export default ManageScore; mobx 类似于 redux。但是 处理异步的时候 runInAction 或者 利用@action 将回调的的再处理包装成同步 或者使用flow 异步操作 异步1 useHooks useReducer Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-19 19:02:14 "},"前端框架/TypeScript tsconfig.json 配置详解.html":{"url":"前端框架/TypeScript tsconfig.json 配置详解.html","title":"tsconfig","keywords":"","body":" 本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net { \"compilerOptions\": { /* Basic Options */ \"target\": \"es5\" /* target用于指定编译之后的版本目标: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019' or 'ESNEXT'. */, \"module\": \"commonjs\" /* 用来指定要使用的模块标准: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'. */, \"lib\": [\"es6\", \"dom\"] /* lib用于指定要包含在编译中的库文件 */, \"allowJs\": true, /* allowJs设置的值为true或false，用来指定是否允许编译js文件，默认是false，即不编译js文件 */ \"checkJs\": true, /* checkJs的值为true或false，用来指定是否检查和报告js文件中的错误，默认是false */ \"jsx\": \"preserve\", /* 指定jsx代码用于的开发环境: 'preserve', 'react-native', or 'react'. */ \"declaration\": true, /* declaration的值为true或false，用来指定是否在编译的时候生成相应的\".d.ts\"声明文件。如果设为true，编译每个ts文件之后会生成一个js文件和一个声明文件。但是declaration和allowJs不能同时设为true */ \"declarationMap\": true, /* 值为true或false，指定是否为声明文件.d.ts生成map文件 */ \"sourceMap\": true, /* sourceMap的值为true或false，用来指定编译时是否生成.map文件 */ \"outFile\": \"./\", /* outFile用于指定将输出文件合并为一个文件，它的值为一个文件路径名。比如设置为\"./dist/main.js\"，则输出的文件为一个main.js文件。但是要注意，只有设置module的值为amd和system模块时才支持这个配置 */ \"outDir\": \"./\", /* outDir用来指定输出文件夹，值为一个文件夹路径字符串，输出的文件都将放置在这个文件夹 */ \"rootDir\": \"./\", /* 用来指定编译文件的根目录，编译器会在根目录查找入口文件，如果编译器发现以rootDir的值作为根目录查找入口文件并不会把所有文件加载进去的话会报错，但是不会停止编译 */ \"composite\": true, /* 是否编译构建引用项目 */ \"incremental\": true, /* 是否启用增量编译*/ \"tsBuildInfoFile\": \"./\", /* 指定文件用来存储增量编译信息 */ \"removeComments\": true, /* removeComments的值为true或false，用于指定是否将编译后的文件中的注释删掉，设为true的话即删掉注释，默认为false */ \"noEmit\": true, /* 不生成编译文件，这个一般比较少用 */ \"importHelpers\": true, /* importHelpers的值为true或false，指定是否引入tslib里的辅助工具函数，默认为false */ \"downlevelIteration\": true, /* 当target为'ES5' or 'ES3'时，为'for-of', spread, and destructuring'中的迭代器提供完全支持 */ \"isolatedModules\": true, /* isolatedModules的值为true或false，指定是否将每个文件作为单独的模块，默认为true，它不可以和declaration同时设定 */ /* Strict Type-Checking Options */ \"strict\": true /* strict的值为true或false，用于指定是否启动所有类型检查，如果设为true则会同时开启下面这几个严格类型检查，默认为false */, \"noImplicitAny\": true, /* noImplicitAny的值为true或false，如果我们没有为一些值设置明确的类型，编译器会默认认为这个值为any，如果noImplicitAny的值为true的话。则没有明确的类型会报错。默认值为false */ \"strictNullChecks\": true, /* strictNullChecks为true时，null和undefined值不能赋给非这两种类型的值，别的类型也不能赋给他们，除了any类型。还有个例外就是undefined可以赋值给void类型 */ \"strictFunctionTypes\": true, /* strictFunctionTypes的值为true或false，用于指定是否使用函数参数双向协变检查 */ \"strictBindCallApply\": true, /* 设为true后会对bind、call和apply绑定的方法的参数的检测是严格检测的 */ \"strictPropertyInitialization\": true, /* 设为true后会检查类的非undefined属性是否已经在构造函数里初始化，如果要开启这项，需要同时开启strictNullChecks，默认为false */ \"noImplicitThis\": true, /* 当this表达式的值为any类型的时候，生成一个错误 */ \"alwaysStrict\": true, /* alwaysStrict的值为true或false，指定始终以严格模式检查每个模块，并且在编译之后的js文件中加入\"use strict\"字符串，用来告诉浏览器该js为严格模式 */ /* Additional Checks */ \"noUnusedLocals\": true, /* 用于检查是否有定义了但是没有使用的变量，对于这一点的检测，使用eslint可以在你书写代码的时候做提示，你可以配合使用。它的默认值为false */ \"noUnusedParameters\": true, /* 用于检查是否有在函数体中没有使用的参数，这个也可以配合eslint来做检查，默认为false */ \"noImplicitReturns\": true, /* 用于检查函数是否有返回值，设为true后，如果函数没有返回值则会提示，默认为false */ \"noFallthroughCasesInSwitch\": true, /* 用于检查switch中是否有case没有使用break跳出switch，默认为false */ /* Module Resolution Options */ \"moduleResolution\": \"node\", /* 用于选择模块解析策略，有'node'和'classic'两种类型' */ \"baseUrl\": \"./\", /* baseUrl用于设置解析非相对模块名称的基本目录，相对模块不会受baseUrl的影响 */ \"paths\": {}, /* 用于设置模块名称到基于baseUrl的路径映射 */ \"rootDirs\": [], /* rootDirs可以指定一个路径列表，在构建时编译器会将这个路径列表中的路径的内容都放到一个文件夹中 */ \"typeRoots\": [], /* typeRoots用来指定声明文件或文件夹的路径列表，如果指定了此项，则只有在这里列出的声明文件才会被加载 */ \"types\": [], /* types用来指定需要包含的模块，只有在这里列出的模块的声明文件才会被加载进来 */ \"allowSyntheticDefaultImports\": true, /* 用来指定允许从没有默认导出的模块中默认导入 */ \"esModuleInterop\": true /* 通过为导入内容创建命名空间，实现CommonJS和ES模块之间的互操作性 */, \"preserveSymlinks\": true, /* 不把符号链接解析为其真实路径，具体可以了解下webpack和nodejs的symlink相关知识 */ /* Source Map Options */ \"sourceRoot\": \"\", /* sourceRoot用于指定调试器应该找到TypeScript文件而不是源文件位置，这个值会被写进.map文件里 */ \"mapRoot\": \"\", /* mapRoot用于指定调试器找到映射文件而非生成文件的位置，指定map文件的根路径，该选项会影响.map文件中的sources属性 */ \"inlineSourceMap\": true, /* 指定是否将map文件的内容和js文件编译在同一个js文件中，如果设为true，则map的内容会以//# sourceMappingURL=然后拼接base64字符串的形式插入在js文件底部 */ \"inlineSources\": true, /* 用于指定是否进一步将.ts文件的内容也包含到输入文件中 */ /* Experimental Options */ \"experimentalDecorators\": true /* 用于指定是否启用实验性的装饰器特性 */ \"emitDecoratorMetadata\": true, /* 用于指定是否为装饰器提供元数据支持，关于元数据，也是ES6的新标准，可以通过Reflect提供的静态方法获取元数据，如果需要使用Reflect的一些方法，需要引入ES2015.Reflect这个库 */ } \"files\": [], // files可以配置一个数组列表，里面包含指定文件的相对或绝对路径，编译器在编译的时候只会编译包含在files中列出的文件，如果不指定，则取决于有没有设置include选项，如果没有include选项，则默认会编译根目录以及所有子目录中的文件。这里列出的路径必须是指定文件，而不是某个文件夹，而且不能使用* ? **/ 等通配符 \"include\": [], // include也可以指定要编译的路径列表，但是和files的区别在于，这里的路径可以是文件夹，也可以是文件，可以使用相对和绝对路径，而且可以使用通配符，比如\"./src\"即表示要编译src文件夹下的所有文件以及子文件夹的文件 \"exclude\": [], // exclude表示要排除的、不编译的文件，它也可以指定一个列表，规则和include一样，可以是文件或文件夹，可以是相对路径或绝对路径，可以使用通配符 \"extends\": \"\", // extends可以通过指定一个其他的tsconfig.json文件路径，来继承这个配置文件里的配置，继承来的文件的配置会覆盖当前文件定义的配置。TS在3.2版本开始，支持继承一个来自Node.js包的tsconfig.json配置文件 \"compileOnSave\": true, // compileOnSave的值是true或false，如果设为true，在我们编辑了项目中的文件保存的时候，编辑器会根据tsconfig.json中的配置重新生成文件，不过这个要编辑器支持 \"references\": [], // 一个对象数组，指定要引用的项目 } Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-19 19:02:14 "},"前端框架/Vue 项目 优化 开发 生产.html":{"url":"前端框架/Vue 项目 优化 开发 生产.html","title":"vue优化","keywords":"","body":"Vue 项目 优化 开发 生产 package.json 添加指令 scripts:{ ..., \"dll\": \"webpack -p --progress --config ./webpack.dll.conf.js\" } 开发阶段 dev 处理静态资源 类似 element-ui axios vue全家桶 webpack.dll.conf.js const path = require('path') const webpack = require('webpack') const CleanWebpackPlugin = require('clean-webpack-plugin') // dll文件存放的目录 const dllPath = 'public/vendor' module.exports = { entry: { // 需要提取的库文件 // vendor: [ // 'vue/dist/vue.common.js', // 'vue-router/dist/vue-router.common.js', // 'vuex/dist/vuex.common.js', // 'element-ui', // 'axios', 'qs', 'nprogress'] vendor: ['vue', 'vue-router', 'vuex', 'axios', 'element-ui', 'qs', 'nprogress'] // vendor: ['axios', 'qs', 'nprogress'], // 也可以把部分模块集中化处理 // entry: { // vue: ['vue', 'vuex', 'vue-router'], // vue全家桶dll: vue.dll.js // ec: ['echarts', 'echarts-wordcloud'], // echarts相关dll: ec.dll.js // commons: [ // 其他第三方库: commons.dll.js // ] // } }, output: { path: path.join(__dirname, dllPath), filename: '[name].dll.js', // vendor.dll.js中暴露出的全局变量名 // 保持与 webpack.DllPlugin 中名称一致 library: '[name]_[hash]' }, plugins: [ // 清除之前的dll文件 new CleanWebpackPlugin(['*.*'], { root: path.join(__dirname, dllPath) }), // 设置环境变量 new webpack.DefinePlugin({ 'process.env': { NODE_ENV: 'production' } }), // manifest.json 描述动态链接库包含了哪些内容 new webpack.DllPlugin({ path: path.join(__dirname, dllPath, '[name]-manifest.json'), // 保持与 output.library 中名称一致 name: '[name]_[hash]', context: process.cwd() }) ] } 在vue.config.js 处理这些静态资源 不再项目里面进行打包 这里 没有做动动态打包引入打包的那种操作 const webpack = require('webpack') const plugins =[] plugins.push( new webpack.DllReferencePlugin({ context: process.cwd(), manifest: require('./public/vendor/${name}-manifest.json') }) ) const cdn = { dev: { css: [ 'https://cdn.bootcdn.net/ajax/libs/normalize/8.0.1/normalize.min.css', 'https://cdn.bootcdn.net/ajax/libs/element-ui/2.13.2/theme-chalk/index.css' ], js: [ '/vendor/vendor.dll.js' // 'https://cdn.bootcdn.net/ajax/libs/element-ui/2.13.2/index.js' ] }, build: { css: [ 'https://cdn.bootcdn.net/ajax/libs/animate.css/4.1.1/animate.min.css', 'https://cdn.bootcdn.net/ajax/libs/nprogress/0.2.0/nprogress.min.css', 'https://cdn.bootcdn.net/ajax/libs/element-ui/2.13.2/theme-chalk/index.css', 'https://cdn.bootcdn.net/ajax/libs/normalize/8.0.1/normalize.min.css' ], js: [ 'https://cdn.bootcdn.net/ajax/libs/vue/2.6.10/vue.min.js', 'https://cdn.bootcss.com/vue-router/3.0.6/vue-router.min.js', 'https://cdn.bootcss.com/vuex/3.1.1/vuex.min.js', 'https://cdn.bootcdn.net/ajax/libs/axios/0.20.0/axios.min.js', 'https://cdn.bootcdn.net/ajax/libs/nprogress/0.2.0/nprogress.min.js', 'https://cdn.bootcdn.net/ajax/libs/element-ui/2.13.2/index.js', 'https://cdn.bootcdn.net/ajax/libs/qs/6.9.4/qs.min.js' ] } } module.exports={ ..., chainWebpack(config) { config.plugin('html').tap(args => { // 这里是为了 将那些静态资源引入到html中去 if (isDev) { args[0].cdn = cdn.dev } else { args[0].cdn = cdn.build } return args }) }, configureWebpack:{ plugins } } favicon.ico\" /> demo1 \" rel=\"preload\" as=\"style\" /> \" rel=\"stylesheet\" /> We're sorry but demo1 doesn't work properly without JavaScript enabled. Please enable it to continue. \"> 生产阶段 pro vue.config.js externals处理 // 控制cdn 外链 const externals = { 'vue': 'Vue', 'vue-router': 'VueRouter', 'vuex': 'Vuex', 'axios': 'axios', 'nprogress': 'NProgress', // 'element-ui': 'ElementUI' 'element-ui': 'ELEMENT', 'qs': 'Qs' } module.exports ={ chainWebpack(config) { config.plugin('html').tap(args => { // 这里是为了 将那些静态资源引入到html中去 if (isDev) { args[0].cdn = cdn.dev } else { args[0].cdn = cdn.build } return args }) }, configureWebpack:{ externals: isDev?{}:externals } } 后续 静态资源有添加更改只需要配置好一次 提前打包静态话处理 后续 都不会需要打包进项目文件 缩短开发时项目启动 跟新慢的问题 有些UI插件 类似 normalize.css animate.css 可以直接丢在cdn上 或者丢在公司的服务器 给个链接 有些UI框架库 类似 antd-design-vue 配不好外链的externals 也可以打包成静态文件丢在服务器上 附加学习 https://segmentfault.com/a/1190000020485804 Hard-source-webpack-plugin 类似最优解。但是如果为了减少静态三分文件 也可以先 dll处理后 打包开发 一面每次跟行app.bundle 过大 目的： 所以第三方不更新的插件静态话 开发页面 引入2次以上合包（利用webpack.splitChunks） 如果第三方包（类似 normalize.css vue其他） 在一定大小情况下可以打包进自己的app.js 减少页面请求也行 完整用列 const path = require('path') const webpack = require('webpack') const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin const CompressionPlugin = require('compression-webpack-plugin') // Gzip 只用在 开发阶段 // eslint-disable-next-line const { SkeletonPlugin } = require('page-skeleton-webpack-plugin') // eslint-disable-next-line const pageSkeleton = new SkeletonPlugin({ pathname: path.resolve(__dirname, './shell'), // 用来存储 shell 文件的地址 staticDir: path.resolve(__dirname, './dist'), // 最好和 `output.path` 相同 routes: ['/', '/login', '/act'], // 将需要生成骨架屏的路由添加到数组中 port: '8988' }) const isDev = process.env.NODE_ENV === 'development' const plugins = [] // plugins.push(pageSkeleton) const gzip = new CompressionPlugin({ // 文件开启Gzip，也可以通过服务端(如：nginx)(https://github.com/webpack-contrib/compression-webpack-plugin) filename: '[path].gz[query]', algorithm: 'gzip', test: new RegExp('\\\\.(' + ['js', 'css'].join('|') + ')$'), threshold: 8192, minRatio: 0.8 }) if (!isDev) { plugins.push(new BundleAnalyzerPlugin()) plugins.push(gzip) } if (isDev) { plugins.push(new BundleAnalyzerPlugin()) plugins.push( new webpack.DllReferencePlugin({ context: process.cwd(), manifest: require('./public/vendor/vendor-manifest.json') }) ) } const cdn = { dev: { css: [ 'https://cdn.bootcdn.net/ajax/libs/normalize/8.0.1/normalize.min.css', 'https://cdn.bootcdn.net/ajax/libs/element-ui/2.13.2/theme-chalk/index.css' ], js: [ '/vendor/vendor.dll.js' // 'https://cdn.bootcdn.net/ajax/libs/element-ui/2.13.2/index.js' ] }, build: { css: [ 'https://cdn.bootcdn.net/ajax/libs/animate.css/4.1.1/animate.min.css', 'https://cdn.bootcdn.net/ajax/libs/nprogress/0.2.0/nprogress.min.css', 'https://cdn.bootcdn.net/ajax/libs/element-ui/2.13.2/theme-chalk/index.css', 'https://cdn.bootcdn.net/ajax/libs/normalize/8.0.1/normalize.min.css' ], js: [ 'https://cdn.bootcdn.net/ajax/libs/vue/2.6.10/vue.min.js', 'https://cdn.bootcss.com/vue-router/3.0.6/vue-router.min.js', 'https://cdn.bootcss.com/vuex/3.1.1/vuex.min.js', 'https://cdn.bootcdn.net/ajax/libs/axios/0.20.0/axios.min.js', 'https://cdn.bootcdn.net/ajax/libs/nprogress/0.2.0/nprogress.min.js', 'https://cdn.bootcdn.net/ajax/libs/element-ui/2.13.2/index.js', 'https://cdn.bootcdn.net/ajax/libs/qs/6.9.4/qs.min.js' ] } } // 控制cdn 外链 const externals = { 'vue': 'Vue', 'vue-router': 'VueRouter', 'vuex': 'Vuex', 'axios': 'axios', 'nprogress': 'NProgress', // 'element-ui': 'ElementUI' 'element-ui': 'ELEMENT', 'qs': 'Qs' } console.log(require('os').cpus().length) module.exports = { productionSourceMap: false, // 构建时开启多进程处理 babel 编译 // parallel: require('os').cpus().length > 1, devServer: { open: false, proxy: { '/isDev': { target: 'http://whrdd.f3322.net:28889', changeOrigin: true, ws: true, // proxy websockets pathRewrite: { '^/isDev': '' } }, '/isTest': { target: 'http://whrdd.f3322.net:60091', changeOrigin: true, ws: true, // proxy websockets pathRewrite: { '^/isTest': '' } } } }, chainWebpack(config) { // 移除 prefetch 插件 config.plugins.delete('prefetch') // 移除 preload 插件 config.plugins.delete('preload') config .when(process.env.NODE_ENV !== 'development', config => { config .optimization.splitChunks({ chunks: 'all', cacheGroups: { libs: { name: 'chunk-libs', test: /[\\\\/]node_modules[\\\\/]/, priority: 10, chunks: 'initial' // only package third parties that are initially dependent }, // elementUI: { // name: 'chunk-elementUI', // split elementUI into a single package // priority: 20, // the weight needs to be larger than libs and app or it will be packaged into libs or app // test: /[\\\\/]node_modules[\\\\/]_?element-ui(.*)/ // in order to adapt to cnpm // }, commons: { name: 'chunk-commons', test: path.resolve(__dirname, 'src/components'), minChunks: 3, // minimum common number priority: 5, reuseExistingChunk: true } } }) // https://webpack.js.org/configuration/optimization/#optimizationruntimechunk config.optimization.runtimeChunk('single') } ) config.plugin('html').tap(args => { if (isDev) { args[0].cdn = cdn.dev } else { args[0].cdn = cdn.build } return args }) if (!isDev) { config.plugin('html').tap(opts => { opts[0].minify.removeComments = false return opts }) } }, configureWebpack: { plugins, externals: isDev ? {} : externals } } Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-19 19:10:07 "},"前端面试/CSS.html":{"url":"前端面试/CSS.html","title":"CSS","keywords":"","body":"CSS 说一下css盒模型 盒模型的组成，由里向外content，padding，border，margin。 标准模型 总宽度为：width+border+padding IE盒模型 总宽度为：width 画一条0.5px的线 transform transform: scale会导致Chrome变虚了，而粗细几乎没有变化。但是如果加上transform-origin: 50% 100% transform: scaleY(0.5); transform-origin: 50% 100% boxshadow 这个方法在Chrome和Firefox都非常完美，但是Safari不支持小于1px的boxshadow，所以完全没显示出来了。 height: 1px; background: none; box-shadow: 0 0.5px 0 #000; 其中width=device-width表示将viewport视窗的宽度调整为设备的宽度，这个宽度通常是指物理上宽度。默认的缩放比例为1，如iphone 6竖屏的宽度为750px，它的dpr=2，用2px表示1px，这样设置之后viewport的宽度就变成375px。这时候0.5px的边就使用我们上面讨论的方法。 但是你可以把scale改成0.5： 这样的话，viewport的宽度就是原本的750px，所以1个px还是1px，正常画就行，但这样也意味着UI需要按2倍图的出，整体面面的单位都会放大一倍。 在iPone X和一些安卓手机等dpr = 3的设备上，需要设置scale为0.333333，这个时候就是3倍地画了。 link标签和import标签的区别 差别1：老祖宗的差别，link属于XHTML标签，而@import完全是css提供的一种方式。link标签除了可以加载css外，还可以做很多其他的事情，比如定义RSS，定义rel连接属性等，@import只能加载CSS。 差别2：加载顺序的差别：当一个页面被夹在的时候（就是被浏览者浏览的时候），link引用的CSS会同时被加载，而@import引用的CSS会等到页面全部被下载完再加载。所以有时候浏览@import加载CSS的页面时会没有样式（就是闪烁），网速慢的时候还挺明显。 差别3：兼容性的差别。由于@import是CSS2.1提出的所以老的浏览器不支持，@import只有在IE5以上的才能识别，而link标签无此问题，完全兼容。 差别4：使用dom控制样式时的差别。当时用JavaScript控制dom去改变样式的时候，只能使用link标签，因为@import不是dom可以控制的（不支持）。 差别5（不推荐）：@import可以在css中再次引入其他样式表，比如创建一个主样式表，在主样式表中再引入其他的样式表，但是：这样做有一个缺点，会对网站服务器产生过多的HTTP请求，以前是一个文件，而现在确实两个或更多的文件了，服务器压力增大，浏览量大的网站还是谨慎使用。 animation 和 transition 的区别 animation 可以用 name 设置动画的名称，用 duration 设置动画完成的周期，用 timing-function 设置动画的速度曲线，delay 设置动画什么时候开始，iteration-count 设置动画播放的次数，direction 规定下一个周期是否逆向的播放，play-state 动画是否正在进行或者暂停，fill-mode 设置动画停了之后位置什么状态 transition 用 property 去设置过渡效果的属性名称，duration 设置过渡效果的周期，timing-function 规定速度效果的速度曲线，delay 设定过渡效果什么时候开始；　 -webkit-transition: background-color 1s ease 0.1s,width 1s linear 0.1s,height 1s ease-in-out 0.1s; -moz-transition: background-color 1s ease 0.1s ,width 1s linear 0.1s,height 1s ease-in-out 0.1s; -ms-transition: background-color 1s ease 0.1s,width 1s linear 0.1s,height 1s ease-in-out 0.1s; -o-transition: background-color 1s ease 0.1s,width 1s linear 0.1s,height 1s ease-in-out 0.1s; transition: background-color 1s ease 0.1s,width 1s linear 0.1s,height 1s ease-in-out 0.1s; 　 区别： 1、transition 是过渡，是样式值的变化的过程，只有开始和结束；animation 其实也叫关键帧，通过和 keyframe 结合可以设置中间帧的一个状态； 2、animation 配合 @keyframe 可以不触发时间就触发这个过程，而 transition 需要通过 hover 或者 js 事件来配合触发； 3、animation 可以设置很多的属性，比如循环次数，动画结束的状态等等，transition 只能触发一次； animation: name duration timing-function delay iteration-count direction; | 值 | 描述 | | :----------------------------------------------------------- | :--------------------------------------- | | animation-name | 规定需要绑定到选择器的 keyframe 名称。。 | | animation-duration | 规定完成动画所花费的时间，以秒或毫秒计。 | | animation-timing-function | 规定动画的速度曲线。 | | animation-delay | 规定在动画开始之前的延迟。 | | animation-iteration-count | 规定动画应该播放的次数。 | | animation-direction | 规定是否应该轮流反向播放动画。 | 4、animation 可以结合 keyframe 设置每一帧，但是 transition 只有两帧； 5、在性能方面：浏览器有一个主线程和排版线程；主线程一般是对 js 运行的、页面布局、生成位图等等，然后把生成好的位图传递给排版线程，而排版线程会通过 GPU 将位图绘制到页面上，也会向主线程请求位图等等；我们在用使用 aniamtion 的时候这样就可以改变很多属性，像我们改变了 width、height、postion 等等这些改变文档流的属性的时候就会引起，页面的回流和重绘，对性能影响就比较大，但是我们用 transition 的时候一般会结合 tansfrom 来进行旋转和缩放等不会生成新的位图，当然也就不会引起页面的重排了； Flex布局 display: -webkit-flex; /* Safari */ display: flex; 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。 flex-direction: row | row-reverse | column | column-reverse; row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap: nowrap | wrap | wrap-reverse; nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 flex-flow: || ; 项目的属性 order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-grow 属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大，如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍 flex-shrink 属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 BFC BFC(Block formatting context)直译为\"块级格式化上下文\"。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。 每个盒子（块盒与行盒）的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算。 垂直居中的方法 通过vertical-align:middle实现CSS垂直居中是最常使用的方法，但是有一点需要格外注意，vertical生效的前提是元素的display：inline-block。 定位（position） 弹性盒子（flex） Margin:auto Js动画与Css3动画的差异性 功能涵盖面，JS比CSS3大 定义动画过程的@keyframes不支持递归定义，如果有多种类似的动画过程，需要调节多个参数来生成的话，将会有很大的冗余（比如jQuery Mobile的动画方案），而JS则天然可以以一套函数实现多个不同的动画过程 时间尺度上，@keyframes的动画粒度粗，而JS的动画粒度控制可以很细 CSS3动画里被支持的时间函数非常少，不够灵活 以现有的接口，CSS3动画无法做到支持两个以上的状态转化 实现/重构难度不一，CSS3比JS更简单，性能调优方向固定 对于帧速表现不好的低版本浏览器，CSS3可以做到自然降级，而JS则需要撰写额外代码 CSS动画有天然事件支持（TransitionEnd、AnimationEnd，但是它们都需要针对浏览器加前缀），JS则需要自己写事件 CSS3有兼容性问题，而JS大多时候没有兼容性问题 说一下块元素和行元素 行内元素特征： (1)设置宽高无效 (2)对margin仅设置左右方向有效，上下无效；padding设置上下左右都有效，即会撑大空间 (3)不会自动进行换行 块状元素特征： (1)能够识别宽高 (2)margin和padding的上下左右均对其有效 (3)可以自动换行 (4)多个块状元素标签写在一起，默认排列方式为从上至 行内块状元素特征： (1)不自动换行 (2)能够识别宽高 (3)默认排列方式为从左到右 多行元素的 文本省略号 使文字数量不同在相同的地方显示，给盒子加固定高度 overflow：hidden; display：-webkit-box; 将盒子转换为弹性盒子 -webkit-line-clamp：2; 设置显示多少行 text-overflow：ellipsis; 文本以省略号显示 -webkit-box-orient：vertical; 文本显示方式，默认水平 单行文本的溢出溢出省略号使用text-overflow：ellipsis overflow:hidden; text-overflow:ellipsis; white-space: nowrap; opacity:0、visibility:hidden、display:none 空间占据 display:none隐藏后不占据额外空间，它会产生回流和重绘，而visibility:hidden和opacity:0元素虽然隐藏了，但它们仍然占据着空间，它们俩只会引起页面重绘。 子元素继承 display:none不会被子元素继承，但是父元素都不在了，子元素自然也就不会显示了，皮之不存，毛之安附~~ visibility:hidden 会被子元素继承，可以通过设置子元素visibility:visible 使子元素显示出来 opacity: 0 也会被子元素继承，但是不能通过设置子元素opacity: 0使其重新显示 事件绑定 display:none 的元素都已经不再页面存在了，因此肯定也无法触发它上面绑定的事件； visibility:hidden 元素上绑定的事件也无法触发； opacity: 0元素上面绑定的事件是可以触发的。 过渡动画 transition对于display肯定是无效的，大家应该都知道； transition对于visibility也是无效的； transition对于opacity是有效，大家也是知道的:). 双边距重叠问题 什么是双边距重叠 多个相邻的（兄弟或者父子关系）标准流中的块元素垂直方向的margin会重叠。 折叠结果 两个相邻的外边距都是正数的时候，折叠结果就是它们两者之间较大的值 两个相邻的外边距都是负数的时候，折叠结果就是它们两者之间绝对值的较大值 两个相邻的外边距一正一负的时候，折叠结果就是它们两者相加的和 如何解决双边距重叠 给其中的一个div添加一个父的div，并且为这个div设置边框或者实现overflow：hidden； 将块级div设置成行内div（display：inline-block；） Position 值 描述 absolute 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 \"left\", \"top\", \"right\" 以及 \"bottom\" 属性进行规定。 fixed 生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 \"left\", \"top\", \"right\" 以及 \"bottom\" 属性进行规定。 relative 生成相对定位的元素，相对于其正常位置进行定位。因此，\"left:20\" 会向元素的 LEFT 位置添加 20 像素。 static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 inherit 规定应该从父元素继承 position 属性的值。 浮动清除 额外标签法（在最后一个浮动标签后，新加一个标签，给其设置clear：both；）（不推荐） 父级添加overflow属性（父元素添加overflow:hidden）（不推荐）通过触发BFC方式，实现清除浮动 使用after伪元素清除浮动（推荐使用） 使用before和after双伪元素清除浮动 .clearfix:after,.clearfix:before{ content: \"\"; display: block; height: 0; clear: both; visibility: hidden; } .clearfix { /* 触发 hasLayout */ zoom: 1; } css3新特性 CSS选择器 总结排序：!important>内部样式>ID选择器>类选择器>标签选择器>通配符选择器>继承>浏览器默认属性 float元素 display 是block Display:table 和 table 目前，在大多数开发环境中，已经基本不用table元素来做网页布局了，取而代之的是div+css，那么为什么不用table系表格元素呢？ 1、用DIV+CSS编写出来的文件k数比用table写出来的要小，不信你在页面中放1000个table和1000个div比比看哪个文件大 2、table必须在页面完全加载后才显示，没有加载完毕前，table为一片空白，也就是说，需要页面完毕才显示，而div是逐行显示，不需要页面完全加载完毕，就可以一边加载一边显示 3、非表格内容用table来装，不符合标签语义化要求，不利于SEO 4、table的嵌套性太多，用DIV代码会比较简洁 | table | （类似 ）此元素会作为块级表格来显示，表格前后带有换行符。 | | ------------------ | ------------------------------------------------------------ | | inline-table | （类似 ）此元素会作为内联表格来显示，表格前后没有换行符。 | | table-row-group | （类似 ）此元素会作为一个或多个行的分组来显示。 | | table-header-group | （类似 ）此元素会作为一个或多个行的分组来显示。 | | table-footer-group | （类似 ）此元素会作为一个或多个行的分组来显示。 | | table-row | （类似 ）此元素会作为一个表格行显示。 | | table-column-group | （类似 ）此元素会作为一个或多个列的分组来显示。 | | table-column | （类似 ）此元素会作为一个单元格列显示。 | | table-cell | （类似 和 ）此元素会作为一个表格单元格显示。 | | table-caption | （类似 ）此元素会作为一个表格标题显示。 | display:table能解决哪些问题？ （1）大小不固定的元素垂直居中 　　父元素设置：display:table; 子元素：display:table-cell; vertical-align:middle; （2）两列自适应布局 （3）等高布局 如果想要改变一个DOM元素的字体颜色，不在它本身上进行操作？ css继承 在父元素上操作 color line-height height height：表示 行高 line-height：表示 每行文字所占的高度 设置一个元素的背景颜色，背景颜色会填充哪些区域？ 链接：https://www.nowcoder.com/questionTerminal/cdcd727a9d114faeaf79703ff720c774 来源：牛客网 “标准盒模型”与“ IE 盒模型”造成背景颜色的填充范围不同的主要原因就是：设置 width 时，其对应的范围不同。IE 盒子的 width 不仅包含了 content，还包含了 padding 和 border，而标准盒模型的 width 其范围就只包含了 content。 在默认值情况下，background-color 的渲染范围不论是标准盒模型还是 IE 盒模型，都是一样的，都是 border 及以内的范围会被 background-color 的颜色覆盖。 至于 background-clip 三个值对应 background-color 渲染范围的区别，从值的名字就可以直接看出来。 ​ content-box：背景颜色只覆盖 content 的部分； ​ padding-box：背景颜色覆盖 padding、content 的部分； ​ border-box（默认）：背景颜色覆盖 border、padding 和 content 的部分（同时，这又是默认的属性，在不手动设置 background-clip 属性值时，背景颜色默认覆盖了这三个范围，只不过平时我们设置的border都是实线且比较窄，所以一般情况下看起来似乎并没有覆盖border，其实是有的。） 为什么img 是inline 还可以设置宽高 可替换元素 在 CSS 中，可替换元素（replaced element）的展现效果不是由 CSS 来控制的。这些元素是一种外部对象，它们外观的渲染，是独立于 CSS 的。 简单来说，它们的内容不受当前文档的样式的影响。CSS 可以影响可替换元素的位置，但不会影响到可替换元素自身的内容。例如 元素，可能具有自己的样式表，但它们不会继承父文档的样式。 典型的可替换元素有： 有些元素仅在特定情况下被作为可替换元素处理，例如： \"image\" 类型的 元素就像一样可替换 （已废弃） CSS的 content 属性用于在元素的 ::before 和 ::after 伪元素中插入内容。使用content 属性插入的内容都是匿名的可替换元素。 Overflow原理 overflow 属性规定当内容溢出元素框时发生的事情。 | 值 | 描述 | | :------ | :------------------------------------------------------- | | visible | 默认值。内容不会被修剪，会呈现在元素框之外。 | | hidden | 内容会被修剪，并且其余内容是不可见的。 | | scroll | 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。 | | auto | 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 | | inherit | 规定应该从父元素继承 overflow 属性的值。 | Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-19 19:12:02 "},"前端面试/Javascript.html":{"url":"前端面试/Javascript.html","title":"Javascript","keywords":"","body":"Javascript get请求传参长度的误区 误解：HTTP 协议下的 Get 请求参数长度是有大小限制的，最大不能超过XX，而 Post 是无限制的。 1、首先即使有长度限制，也是限制的是整个 URI 长度，而不仅仅是你的参数值数据长度。 2、HTTP 协议从未规定 GET/POST 的请求长度限制是多少。 3、所谓的请求长度限制是由浏览器和 web 服务器决定和设置的，各种浏览器和 web 服务器的设定 均不一样，这依赖于各个浏览器厂家的规定或者可以根据 web 服务器的处理能力来设定。 get和post请求在缓存方面的区别 get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。 post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。 闭包 一句话可以概括：闭包就是能够读取其他函数内部变量的函数，或者子函数在外调用，子函数所在的父函数的作用域不会被释放。闭包是定义在一个函数内部可访问该函数内部局部变量的函数，作用就是让函数外部可以访问函数内部局部变量。 类的创建和继承 //创建 function FuncA() {} function Func() {} 继承 //原型链继承 //特点：基于原型链，既是父类的实例，也是子类的实例。 //缺点：不能实现多继承。 FuncA.prototype = new Func() FuncA.prototype.constructor = FuncA //构造继承 //特点：可以实现多继承。 //缺点：只能实现继承父类的属性和方法，不能继承原型链上的属性和方法。 function FuncA() { Func.call(this) } //组合继承 //相当于构造继承和原型链继承的组合体。通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用。 //缺点：调用了两次父类构造函数，生成了两份实例。 function FuncA() { Func.call(this) } FuncA.prototype = new Func() FuncA.prototype.constructor = FuncA //寄生组合继承 var f = new FuncA() 如何解决异步回调地狱 async/await promise generator 前端中的事件流 事件流的3个阶段，即顺序： 事件捕获阶段 处于目标阶段 事件冒泡阶段 dom.addEventlistener(event, cb,bool) event = 'click'|... 事件 cb = function(){} bool = true(捕获阶段触发)｜false('冒泡阶段') 图片的懒加载和预加载 预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。 原理：事先把网页的图片记载到本地，之后就直接到缓存中拿图片 懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。 场景：对于图片过多的页面，为了加快页面加载速度，需要将页面内未出现的可视区域内的图片先不做加载，等到滚动可视区域后再去加载。 原理：img标签的src属性用来表示图片的URL，当这个属性值不为空时，浏览器就会根据这个值发送请求，如果没有src属性就不会发送请求。所以，在页面加入时将img标签的src指向为空或者指向一个小图片（loading或者缺省图），将真实地址存在一个自定义属性data-src中，当页面滚动时，将可视区域的图片的src值赋为真实的值。 两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载 则会增加服务器前端压力。 mouseover和mouseenter的区别 二者的本质区别在于,mouseenter不会冒泡,简单的说,它不会被它本身的子元素的状态影响到.但是mouseover就会被它的子元素影响到,在触发子元素的时候,mouseover会冒泡触发它的父元素.(想要阻止mouseover的冒泡事件就用mouseenter) 共同点:当二者都没有子元素时,二者的行为是一致的,但是二者内部都包含子元素时,行为就不同了. Javascript中new()到底做了些什么？new操作原理 (1) 创建一个新对象； (2) 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象） ； (3) 执行构造函数中的代码（为这个新对象添加属性） ； (4) 返回新对象。 call bind apply 的 区别 三者都可以改变函数的this对象指向。 三者第一个参数都是this要指向的对象，如果如果没有这个参数或参数为undefined或null，则默认指向全局window。 三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入。 bind 是返回绑定this之后的函数，便于稍后调用；apply 、call 则是立即执行。 简易版 Function.prototype.bind=function () { var _this=this; var context=arguments[0]; var arg=[].slice.call(arguments,1); return function(){ arg=[].concat.apply(arg,arguments); _this.apply(context,arg); } }; 完美版 //实现bind方法 Function.prototype.bind = function(oThis) { if (typeof this !== 'function') { // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable'); } var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function() {}, fBound = function() { // this instanceof fBound === true时,说明返回的fBound被当做new的构造函数调用 return fToBind.apply(this instanceof fBound ? this : oThis, // 获取调用时(fBound)的传参.bind 返回的函数入参往往是这么传递的 aArgs.concat(Array.prototype.slice.call(arguments))); }; // 维护原型关系 if (this.prototype) { // 当执行Function.prototype.bind()时, this为Function.prototype // this.prototype(即Function.prototype.prototype)为undefined fNOP.prototype = this.prototype; } // 下行的代码使fBound.prototype是fNOP的实例,因此 // 返回的fBound若作为new的构造函数,new生成的新对象作为this传入fBound,新对象的__proto__就是fNOP的实例 fBound.prototype = new fNOP(); return fBound; }; var arr=[1,11,5,8,12]; var max=Math.max.bind(null,arr[0],arr[1],arr[2],arr[3]); console.log(max(arr[4])); //12 clientHeight, scrollHeight,offsetHeight,scrollTop,offsetTop,clientTop clientHeight：包括padding但不包括border、水平滚动条、margin的元素的高度。对于inline的元素这个属性一直是0，单位px，只读元素 offsetHeight：包括padding、border、水平滚动条，但不包括margin的元素的高度。对于inline的元素这个属性一直是0，单位px，只读元素 clientHeight: 可理解为内部可视区高度，样式的height+上下padding scrollHeight: 内容的实际高度+上下padding（如果没有限制div的height，即height是自适应的，一般是scrollHeight==clientHeight） offsetHeight:可理解为div的可视高度，样式的height+上下padding+上下border-width。 clientTop: 容器内部相对于容器本身的top偏移，实际就是 上border-width （div1是10px，div2是20px） scrollTop: Y轴的滚动条没有，或滚到最上时，是0；y轴的滚动条滚到最下时是 scrollHeight-clientHeight（很好理解） offsetTop: 容器到其包含块顶部的距离，粗略的说法可以理解为其父元素。 offsetTop = top + margin-top + border-top JS拖拽功能的实现 异步加载js的方法 HTML5中新增的属性，Chrome、FF、IE9&IE9+均支持（IE6~8不支持）。此外，这种方法不能保证脚本按顺序执行 (function(){ var scriptEle = document.createElement(\"script\"); scriptEle.type = \"text/javasctipt\"; scriptEle.async = true; scriptEle.src = \"http://cdn.bootcss.com/jquery/3.0.0-beta1/jquery.min.js\"; var x = document.getElementsByTagName(\"head\")[0]; x.insertBefore(scriptEle, x.firstChild); })(); window.onload (function(){ if(window.attachEvent){ window.attachEvent(\"load\", asyncLoad); }else{ window.addEventListener(\"load\", asyncLoad); } var asyncLoad = function(){ var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); } )(); 标签的defer=\"defer\"属性 点评：兼容所有浏览器。此外，这种方法可以确保所有设置defer属性的脚本按顺序执行。 Ajax 加载后 eval 内容 Ajax解决浏览器缓存问题 禁止浏览器缓存功能有如下几种方法： 在ajax发送请求前加上 anyAjaxObj.setRequestHeader(\"If-Modified-Since\",\"0\")。 在ajax发送请求前加上 anyAjaxObj.setRequestHeader(\"Cache-Control\",\"no-cache\")。 在URL后面加上一个随机数：\"fresh=\" + Math.random();。 在URL后面加上时间搓：\"nowtime=\" + new Date().getTime();。 如果是使用jQuery，直接这样就可以了$.ajaxSetup({cache:false})。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录。 JS节流和防抖 函数防抖：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。 function debounce(fn,delay){ let timer = null //借助闭包 return function() { if(timer){ clearTimeout(timer) } timer = setTimeout(fn,delay) // 简化写法 } } 函数节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。 function throttle(fn,delay){ let valid = true return function() { if(!valid){ //休息时间 暂不接客 return false } // 工作时间，执行函数并且在间隔期内把状态位设为无效 valid = false setTimeout(() => { fn() valid = true; }, delay) } } /* 请注意，节流函数并不止上面这种实现方案, 例如可以完全不借助setTimeout，可以把状态位换成时间戳，然后利用时间戳差值是否大于指定间隔时间来做判定。 也可以直接将setTimeout的返回的标记当做判断条件-判断当前定时器是否存在，如果存在表示还在冷却，并且在执行fn之后消除定时器表示激活，原理都一样 */ 区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。 JS垃圾回收机制 前端模块化 好处：避免变量污染，命名冲突 提高代码复用率 提高维护性 依赖关系的管理 规范：CommonJs AMD CMD ES6 CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。 AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。 CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Node.js中运行。不过，依赖SPM 打包，模块的加载逻辑偏重 ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。 AMD与CMD区别 总结如下： 最明显的区别就是在模块定义时对依赖的处理不同。 AMD推崇依赖前置 在定义模块的时候就有声明其依赖的模块 CMD推崇就近依赖 只有在用到某模块的时候再去require AMD和CMD最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同。 很多人说requireJS是异步加载模块，SeaJS是同步加载模块，这么理解实际上是不准确的，其实加载模块都是异步的，只不过AMD依赖前置，js可以方便知道依赖模块是谁，立即加载，而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略。 为什么我们说两个的区别是依赖模块执行时机不同，为什么很多人认为ADM是异步的，CMD是同步的（除了名字的原因。。。） 同样都是异步加载模块，AMD在加载模块完成后就会执行改模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行。 CMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的。 这也是很多人说AMD用户体验好，因为没有延迟，依赖模块提前执行了，CMD性能好，因为只有用户需要的时候才执行的原因。 　 深度克隆详解以及实现 用odash.cloneDeep 1. function deepClone(obj) { let newObj = Array.isArray(obj) ? [] : {} if (obj && typeof obj === \"object\") { for (let key in obj) { if (obj.hasOwnProperty(key)) { newObj[key] = (obj && typeof obj[key] === 'object') ? deepClone(obj[key]) : obj[key]; } } } return newObj } const newObj = deepClone(oldObj)); 2.自己内部资料 function DeepClone(source) { // 判断目标是数组还是对象 const targetObj = source.constructor === Array ? [] : {}; for (let key in source) { if (source.hasOwnProperty(key)) { // 如果是对象就递归 if (source[key] && typeof source[key] === 'object') { targetObj[key] = source[key].constructor === Array ? [] : {} targetObj[key] = DeepClone(source[key]) } else { targetObj[key] = source[key] } } } return targetObj } const newObj = JSON.parse(JSON.stringify(oldObj)); 如果obj里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式。而不是时间对象； 如果obj里有RegExp、Error对象，则序列化的结果将只得到空对象； 如果obj里有function，Symbol 类型，undefined，则序列化的结果会把函数或 undefined丢失； 如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null JSON.stringify()只能序列化对象的可枚举的自有属性，例如 如果obj中的对象是有构造函数生成的， 则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的constructor； function deepClone (obj) { if (typeof obj !== 'object') { return obj; } if (!obj) { // obj 是 null的情况 return obj; } if (obj instanceof Date) { return new Date(obj); } if (obj instanceof RegExp) { return new RegExp(obj); } if (obj instanceof Function) { return obj; } let newObj； if (obj instanceof Array) { newObj = []; for(let i = 0, len = obj.length; i 实现一个once函数 传入参数只执行一次 function test(){ alert('coinxu') } var once = (function(){ var memo = {}, i = 0; return function(fn){ for(var key in memo){ //匿名函数支持 if(memo[key].func === fn||memo[key].func.toString() ===fn.toString()){ return memo[key].result } } i += 1 var result = fn() memo[i] = {func:fn, result:result} return result } })() once(test) once(test) 将原生ajax封装成Promise //原生ajax封装成promise function myAjax(method,url,params){ this.state = 'FULFILLED' this.fulfillList = [] this.rejectList = [] ;(function(that){ var data = null method = method.toUpperCase() if(typeof params == 'object'){ var _arr = [] for(var item in params){ _arr.push(item+\"=\"+params[item]) } params = _arr.join('&') } if(method === 'GET'){ url +='?'+params } if(method === 'POST'){ data = params } //start var xhr = new XMLHttpRequest() xhr.open(method,url) xhr.setRequestHeader('Content-type','appliction/x-www-form-urlencoded') xhr.addEventListener('readystatechange',function(){ if(this.readyState !== 4)return; if(this.status !== 200) reject({status:this.status,statusText:this.statusText}) else resolve(this.responseText) }) xhr.send(data) //成功 var resolve = function(data){ that.state = 'FULFILLED' setTimeout(function () { that.fulfillList.forEach(function (itemFn,key,arr) { itemFn(data) arr.shift() }) },0) } //失败，执行失败队列的函数 var reject = function(data){ that.state = 'REJECTED' setTimeout(function () { that.rejectList.forEach(function (itemFn,key,arr) { itemFn(data) arr.shift() }) },0) } })(this) } //成功回调函数 myAjax.prototype.done = function(handle){ if(typeof handle === 'function') this.fulfillList.push(handle) else throw new Error('回调函数出错') return this } //失败回调函数 myAjax.prototype.fail = function(handle){ if(typeof handle === 'function') this.rejectList.push(handle) else throw new Error('回调函数出错') return this } //失败成功写在一个方法内 myAjax.prototype.then = function(fulfill,reject){ this.done(fulfill||function () {}) .fail(reject||function(){}) return this } //测试ajax var ajax = new myAjax('get','./time.php',{a:'123'}) ajax.then(function(data){ console.log(data) },function(data){ console.log(data) }) js监听对象属性的改变 Es5 Object.defineProperty(user, 'name', { set : funtion(value){ name = value; console.log('set: name:' + value) } }) Object.defineProperties(obj,{ a : { configurable: true, // 设置属性可以更改，默认为false set : function(value){} }, b : { configurable: true, // 设置属性可以更改，默认为false set : function(value){} } } }) Es6 funtion handle(){ // 改写set方法，监听设置 set: funtion(){}, get: funtion(){} } let p = new Proxy({},handle) // 第一个参数为监听的对象，第二个参数为改写的方法 如何实现一个私有变量，用getName方法可以访问，不能直接访问？ 通过defineProperty来实现 obj={ name:yuxiaoliang, getName:function(){ return this.name } } object.defineProperty(obj,\"name\",{ //不可枚举不可配置 }); function product(){ var name='yuxiaoliang'; this.getName=function(){ return name; } } var obj=new product() JS中==、===和Object.is()的区别 ==：等同，比较运算符，两边值类型不同的时候，先进行类型转换，再比较； ===：恒等，严格比较运算符，不做类型转换，类型不同就是不等； Object.is()是ES6新增的用来比较两个值是否严格相等的方法，与===的行为基本一致。 先说===，这个比较简单，只需要利用下面的规则来判断两个值是否恒等就行了： 如果类型不同，就不相等 如果两个都是数值，并且是同一个值，那么相等； 值得注意的是，如果两个值中至少一个是NaN，那么不相等（判断一个值是否是NaN，可以用isNaN()或Object.is()来判断）。 如果两个都是字符串，每个位置的字符都一样，那么相等；否则不相等。 如果两个值都是同样的Boolean值，那么相等。 如果两个值都引用同一个对象或函数，那么相等，即两个对象的物理地址也必须保持一致；否则不相等。 如果两个值都是null，或者都是undefined，那么相等。 再说Object.is()，其行为与===基本一致，不过有两处不同： +0不等于-0。 NaN等于自身。 setTimeout, setInterval 与 requestAnimationFrame setTimeout(code, millseconds) 用于延时执行参数指定的代码，如果在指定的延迟时间之前，你想取消这个执行，那么直接用clearTimeout(timeoutId)来清除任务，timeoutID 是 setTimeout 时返回的； setInterval(code, millseconds)用于每隔一段时间执行指定的代码，永无停歇，除非你反悔了，想清除它，可以使用 clearInterval(intervalId)，这样从调用 clearInterval 开始，就不会在有重复执行的任务，intervalId 是 setInterval 时返回的； requestAnimationFrame(code)，一般用于动画，与 setTimeout 方法类似，区别是 setTimeout 是用户指定的，而 requestAnimationFrame 是浏览器刷新频率决定的，一般遵循 W3C 标准，它在浏览器每次刷新页面之前执行。 requestAnimationFrame 使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。他返回一个整数，标识定时器的编号，这个值可以传递给 cancelAnimationFrame用于取消这个函数的执行。 如何实现sleep的效果 Es5 function sleep(numberMillis) { var now = new Date(); var exitTime = now.getTime() + numberMillis; while (true) { now = new Date(); if (now.getTime() > exitTime) return; } } //或 var t = Date.now(); function sleep(d){ while(Date.now - t es6 function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); } async function demo() { console.log('Taking a break...'); await sleep(2000); console.log('Two seconds later'); } 简单实现一个promise demo Function.proto(getPrototypeOf)是什么？ 获取一个对象的原型，在chrome中可以通过proto的形式，或者在ES6中可以通过Object.getPrototypeOf的形式。 那么Function.proto是什么么？也就是说Function由什么对象继承而来，我们来做如下判别。 Function.proto==Object.prototype //false Function.proto==Function.prototype//true 简单实现一个EventEmitter模块 class EventEmitter{ constructor(){ this.handler={}; } on(eventName,callback){ if(!this.handles){ this.handles={}; } if(!this.handles[eventName]){ this.handles[eventName]=[]; } this.handles[eventName].push(callback); } emit(eventName,...arg){ if(this.handles[eventName]){ for(var i=0;i typeOf 可判断：undefined、数值、字符串、布尔值、function 不可判断：null与object、array与object instanceof 判断范围 instanceof用于判断对象的具体类型。 对象只有三种：函数、数组、对象。 console.log(Object.prototype.toString.call(123)); //[object Number] console.log(Object.prototype.toString.call('123')); //[object String] console.log(Object.prototype.toString.call(undefined)); //[object Undefined] console.log(Object.prototype.toString.call(true)); //[object Boolean] console.log(Object.prototype.toString.call({})); //[object Object] console.log(Object.prototype.toString.call([])); //[object Array] console.log(Object.prototype.toString.call(function(){})); //[object Function] console.log(Object.prototype.toString.call(null)); //[[object Null]] JS实现跨域 jsonp请求 CORS window.postMessage domain.name ES6数组去重 test=[1,1,1,2,2,3] [...newSet(test)]; Array.from(new Set(test)) function unique(arr) { const res = new Map(); return arr.filter((a) => !res.has(a) && res.set(a, 1)) } test = test.reduce((cur,next) => { if(cur.includes(next)){ return cur } return [...cur,next] },[]); 跨域是什么 跨域，是指浏览器不能执行其它网站的脚本。它是由浏览器的同源策略造成的，是浏览器对javascript实施的安全限制。 简单来讲，就是从地址A加载的页面，不能访问地址B的服务（如上图）。此时地址A与地址B不同源。 所谓同源，就是域名、协议、端口均相同。举个例子： http://www.123.com/index.html 调用 http://www.123.com/abc.do （非跨域） http://www.123.com/index.html 调用 http://www.456.com/abc.do （主域名不同:123/456，跨域） http://abc.123.com/index.html 调用 http://def.123.com/server.do （子域名不同:abc/def，跨域） http://www.123.com:8080/index.html 调用 http://www.123.com:8081/server.do（端口不同:8080/8081，跨域） http://www.123.com/index.html 调用 https://www.123.com/server.do （协议不同:http/https，跨域） js中不同数据类型之间的比较规则 {} == {} ：两个对象进行比较，比较的是堆内存的地址 null == undefined => true; null===undefined => false NaN == NaN => false ： NaN和谁都不相等 对象和字符串进行比较，是把对象toString()转换为字符串后再比较 剩余的所有数据类型不一样的情况：都是先转换为数字 （1）对象转数字：先转换为字符串，再转换为数字 （2）字符串转换为数字：只要出现非数字字符，结果就是NaN （3）布尔转数字：true=>1 false=>0 （4）null转数字：0 （5）undefined转数字：NaN this的指向问题 作为函数调用，非严格模式下，this指向window，严格模式下，this指向undefined； 作为某对象的方法调用，this通常指向调用的对象。 使用apply、call、bind 可以绑定this的指向。 在构造函数中，this指向新创建的对象 箭头函数没有单独的this值，this在箭头函数创建时确定，它与声明所在的上下文相同。 js 暂时性死区 在代码块内，使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 vdom是什么？为什么存在？ 用js模拟dom结构。 dom发生变化的对比，放在js层做。 提高重绘的性能 怎么获得对象上的属性：比如说通过Object.key（） Object.defineProperty(obj, 'c', { value: 3, enumerable: false }) enumerable设置为false，表示不可枚举，for…in循环、Object.keys()方法和JSON.stringify方法均访问不到该属性。 for key in obj 如果过滤原型上的属性时，需要使用hasOwnProperty Object.getOwnPropertyNames(obj) Object.keys(obj) 返回一个数组，包含对象所有的可枚举属性 Es6新特性 js计算一年有多少周（星期天为第一天 getDate(year) { // 一年第一天是周几 var first = new Date(year,0,1).getDay() // 计算一年有多少天 if((year % 4 == 0 && year % 100 != 0) || (year % 100 == 0 && year % 400 == 0)) { var allyears = 366 }else { var allyears = 365 } // 计算一年有多少周 var week = parseInt((allyears + first) / 7) if(((allyears + first) % 7) != 0) { week += 1 } return week } 箭头函数与function区别 箭头函数是匿名函数，不能作为构造函数，不能使用new 箭头函数没有原型属性 箭头函数不能当做Generator函数,不能使用yield关键字 箭头函数不绑定arguments，取而代之用rest参数...解决 箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值 EventLoop MacroTask（宏任务） script全部代码、setTimeout、setInterval、setImmediate（浏览器暂时不支持，只有IE10支持，具体可见MDN）、I/O、UI Rendering。 MicroTask（微任务） Process.nextTick（Node独有）、Promise、Object.observe(废弃)、MutationObserver（具体使用方式查看这里） 浏览器中的Event Loop Javascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。 JS调用栈 JS调用栈采用的是后进先出的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空。 同步任务和异步任务 Javascript单线程任务被分为同步任务和异步任务，同步任务会在调用栈中按照顺序等待主线程依次执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。 事件循环的进程模型 选择当前要执行的任务队列，选择任务队列中最先进入的任务，如果任务队列为空即null，则执行跳转到微任务（MicroTask）的执行步骤。 将事件循环中的任务设置为已选择任务。 执行任务。 将事件循环中当前运行任务设置为null。 将已经运行完成的任务从任务队列中删除。 microtasks步骤：进入microtask检查点。 执行进入microtask检查点时，用户代理会执行以下步骤： 设置microtask检查点标志为true。 当事件循环microtask执行不为空时：选择一个最先进入的microtask队列的microtask，将事件循环的microtask设置为已选择的microtask，运行microtask，将已经执行完成的microtask为null，移出microtask中的microtask。 清理IndexDB事务 设置进入microtask检查点的标志为false。 更新界面渲染。 返回第一步。 执行栈在执行完同步任务后，查看执行栈是否为空，如果执行栈为空，就会去执行Task（宏任务），每次宏任务执行完毕后，检查微任务(microTask)队列是否为空，如果不为空的话，会按照先入先出的规则全部执行完微任务(microTask)后，设置微任务(microTask)队列为null，然后再执行宏任务，如此循环。 process.nextTick()虽然它是异步API的一部分，但未在图中显示。这是因为process.nextTick()从技术上讲，它不是事件循环的一部分。 当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。 Prcocess.nextTick() >promise Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-19 19:12:02 "},"前端面试/前端核心.html":{"url":"前端面试/前端核心.html","title":"核心","keywords":"","body":"前端核心 服务端编程 JSONP的缺点 优点 它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制，JSONP可以跨越同源策略； 它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持 在请求完毕后可以通过调用callback的方式回传结果。将回调方法的权限给了调用方。这个就相当于将controller层和view层终于分开了。我提供的jsonp服务只提供纯服务的数据，至于提供服务以 后的页面渲染和后续view操作都由调用者来自己定义就好了。如果有两个页面需要渲染同一份数据，你们只需要有不同的渲染逻辑就可以了，逻辑都可以使用同 一个jsonp服务。 缺点 它只支持GET请求而不支持POST等其它类型的HTTP请求 它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。 jsonp在调用失败的时候不会返回各种HTTP状态码。 缺点是安全性。万一假如提供jsonp的服务存在页面注入漏洞，即它返回的javascript的内容被人控制的。那么结果是什么？所有调用这个 jsonp的网站都会存在漏洞。于是无法把危险控制在一个域名下…所以在使用jsonp的时候必须要保证使用的jsonp服务必须是安全可信的。 如何实现跨域 jsonp /** 声明一个回调函数，其函数名(如show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。 创建一个标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。 服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是show，它准备好的数据是show('我不爱你')。 最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。**/ // index.html function jsonp({ url, params, callback }) { return new Promise((resolve, reject) => { let script = document.createElement('script') window[callback] = function(data) { resolve(data) document.body.removeChild(script) } params = { ...params, callback } // wd=b&callback=show let arrs = [] for (let key in params) { arrs.push(`${key}=${params[key]}`) } script.src = `${url}?${arrs.join('&')}` document.body.appendChild(script) }) } jsonp({ url: 'http://localhost:3000/say', params: { wd: 'Iloveyou' }, callback: 'show' }).then(data => { console.log(data) }) // 上面这段代码相当于向http://localhost:3000/say?wd=Iloveyou&callback=show这个地址请求数据，然后后台返回show('我不爱你')，最后会运行show()这个函数，打印出'我不爱你' // server.js let express = require('express') let app = express() app.get('/say', function(req, res) { let { wd, callback } = req.query console.log(wd) // Iloveyou console.log(callback) // show res.end(`${callback}('我不爱你')`) }) app.listen(3000) jQuery的jsonp形式 //JSONP都是GET和异步请求的，不存在其他的请求方式和同步请求，且jQuery默认就会给JSONP的请求清除缓存。 $.ajax({ url:\"http://crossdomain.com/jsonServerResponse\", dataType:\"jsonp\", type:\"get\",//可以省略 jsonpCallback:\"show\",//->自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略 jsonp:\"callback\",//->把传递函数名的那个形参callback，可省略 success:function (data){ console.log(data);} }); CORS CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。 浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。 服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。 虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。 1) 简单请求 只要同时满足以下两大条件，就属于简单请求 条件1：使用下列方法之一： GET HEAD POST 条件2：Content-Type 的值仅限于下列三者之一： text/plain multipart/form-data application/x-www-form-urlencoded 请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器； XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。 2) 复杂请求 不符合以上条件的请求就肯定是复杂请求了。 复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为\"预检\"请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。 ajax ajax返回状态 xmlhttp.readyState的值及解释： 0：请求未初始化（还没有调用 open()）。 1：请求已经建立，但是还没有发送（还没有调用 send()）。 2：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。 3：请求在处理中；通常响应中已有部分数据可用了，但是服务器还没有完成响应的生成。 4：响应已完成；您可以获取并使用服务器的响应了。 原生ajax // GET //步骤一:创建异步对象 var ajax = new XMLHttpRequest(); //步骤二:设置请求的url参数,参数一是请求的类型,参数二是请求的url,可以带参数,动态的传递参数starName到服务端 ajax.open('get','getStar.php?starName='+name); //步骤三:发送请求 ajax.send(); //步骤四:注册事件 onreadystatechange 状态改变就会调用 ajax.onreadystatechange = function () { if (ajax.readyState==4 &&ajax.status==200) { //步骤五 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的 　　　　console.log(ajax.responseText);//输入相应的内容 　　} } //POST //创建异步对象 var xhr = new XMLHttpRequest(); //设置请求的类型及url //post请求一定要添加请求头才行不然会报错 xhr.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\"); xhr.open('post', '02.post.php' ); //发送请求 xhr.send('name=fox&age=18'); xhr.onreadystatechange = function () { // 这步为判断服务器是否正确响应 if (xhr.readyState == 4 && xhr.status == 200) { console.log(xhr.responseText); } }; Fetch和Ajax 比有什么优缺点 移动web开发 知道PWA 移动布局方案 链接1 百分比布局 flex，grid Rem Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-19 19:12:02 "},"前端面试/前端进阶.html":{"url":"前端面试/前端进阶.html","title":"进阶","keywords":"","body":"前端进阶 前端工程化 Babel的原理 抽象语法树 AST [分析]: https://astexplorer.net/ [规范]: https://github.com/estree/estree 工作过程 Parse(解析)：将源代码转换成更加抽象的表示方法（例如抽象语法树） Transform(转换)：对（抽象语法树）做一些特殊处理，让它符合编译器的期望 Generate(代码生成)：将第二步经过转换过的（抽象语法树）生成新的代码 如何写一个把babel插件 [segmentfault]: https://segmentfault.com/a/1190000018562241 [CSDN]: https://blog.csdn.net/frontend_frank/article/details/102459790 git工作流 rebase 和 merge 1.采用merge和rebase后，git log的区别，merge命令不会保留merge的分支的commit： 2.处理冲突的方式： ·（一股脑）使用merge命令合并分支，解决完冲突，执行git add .和git commit -m'fix conflict'。这个时候会产生一个commit。 ·（交互式）使用rebase命令合并分支，解决完冲突，执行git add .和git rebase --continue，不会产生额外的commit。这样的好处是，‘干净’，分支上不会有无意义的解决分支的commit；坏处，如果合并的分支中存在多个commit，需要重复处理多次冲突。 3.git pull和git pull --rebase区别：git pull做了两个操作分别是‘获取’和合并。所以加了rebase就是以rebase的方式进行合并分支，默认为merge。 4.git merge 和 git merge --no-ff的区别 1、我自己尝试merge命令后，发现：merge时并没有产生一个commit。不是说merge时会产生一个merge commit吗？ 注意：只有在冲突的时候，解决完冲突才会自动产生一个commit。 如果想在没有冲突的情况下也自动生成一个commit，记录此次合并就可以用：git merge --no-ff命令， 2、如果不加 --no-ff 则被合并的分支之前的commit都会被抹去，只会保留一个解决冲突后的 merge commit。 git reset, git revert , git checkout 区别 基于commit 级别的操作 webpack和gulp的区别 Gulp Gulp强调的是前端开发的工作流程。我们可以通过配置一系列的task，定义task处理的事务（例如文件压缩合并、雪碧图、启动server、版本控制等），然后定义执行顺序，来让Gulp执行这些task，从而构建项目的整个前端开发流程。 说的形象点，“Gulp就像是一个产品的流水线，整个产品从无到有，都要受流水线的控制，在流水线上我们可以对产品进行管理。” Webpack Webpack是一个前端模块化方案，更侧重模块打包。我们可以把开发中的所有资源（图片、js文件、css文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源。 Webpack就是需要通过其配置文件（Webpack.config.js）中 entry 配置的一个入口文件（JS文件），然后在解析过程中，发现其他的模块，如scss等文件，再调用配置的loader或者插件对相关文件进行解析处理。 两者区别 虽然Gulp 和 Webpack都是前端自动化构建工具，但看2者的定位就知道不是对等的。Gulp严格上讲，模块化不是他强调的东西，旨在规范前端开发流程。Webpack更明显的强调模块化开发，而那些文件压缩合并、预处理等功能，不过是他附带的功能。 Vue框架 vue的理解 优点： 1、数据驱动视图，对真实dom进行抽象出virtual dom（本质就是一个js对象），并配合diff算法、响应式和观察者、异步队列等手段以最小代价更新dom，渲染页面 2、组件化，组件用单文件的形式进行代码的组织编写，使得我们可以在一个文件里编写html\\css（scoped属性配置css隔离）\\js 并且配合vue-loader之后，支持更强大的预处理器等功能 3、强大且丰富的API提供一系列的api能满足业务开发中各类需求 4、由于采用虚拟dom，让vue ssr先天就足 5、生命周期钩子函数，选项式的代码组织方式，写熟了还是蛮顺畅的，但仍然有优化空间（vue3 composition-api） 6、生态好，社区活跃 缺点： 1、由于底层基于Object.defineProperty实现响应式，而这个api本身不支持IE8及以下浏览器 2、csr的先天不足，首屏性能问题（白屏） 3、由于百度等搜索引擎爬虫无法爬取js中的内容，故spa先天就对seo优化心有余力不足（谷歌的puppeteer就挺牛逼的，实现预渲染底层也是用到了这个工具） Vue和React的不同,使用场景 1: https://www.zhihu.com/question/31585377 \"知乎\" [2]: https://segmentfault.com/a/1190000018742160 \"segmentfaul\" 什么是虚拟Dom 虚拟 dom 是相对于浏览器所渲染出来的真实 dom 的，在react，vue等技术出现之前，我们要改变页面展示的内容只能通过遍历查询 dom 树的方式找到需要修改的 dom 然后修改样式行为或者结构，来达到更新 ui 的目的。 这种方式相当消耗计算资源，因为每次查询 dom 几乎都需要遍历整颗 dom 树，如果建立一个与 dom 树对应的虚拟 dom 对象（ js 对象），以对象嵌套的方式来表示 dom 树，那么每次 dom 的更改就变成了 js 对象的属性的更改，这样一来就能查找 js 对象的属性变化要比查询 dom 树的性能开销小。 vue的生命周期 beforeCreate， created， beforeMount，mounted， beforeUpdate，updated， beforeDestroy destroyed 1: https://www.jianshu.com/p/672e967e201c \"简书\" vue如何监听键盘事件 vue 监听键盘回车事件 @keyup.enter || @keyup.enter.native 1: https://blog.csdn.net/fifteen718/article/details/80359844 \"c s d n\" 组合写法 按键组合 @keyup.alt.67=”function” Alt + C @click.ctrl=”function” Ctrl + Click Vue权限管理 菜单权限， 路由权限， 按钮权限 1: https://blog.csdn.net/weixin_44475093/article/details/112211198 \"csdn\" [按钮权限]: https://juejin.cn/post/6844903824704929799 \"掘金\" Vue3.0 为什么要用ProxyAPI替代definePropertyAPI 1: https://www.cnblogs.com/houxianzhou/p/14368906.html \"cnblog\" [2]: https://cloud.tencent.com/developer/article/1793759 \"cloud\" Vue3.0 编译做了哪些优化 静态Node不再作更新处理（hoistStatic -> SSR 优化） 静态绑定的class、id不再作更新处理 结合打包Hint，进行更新分析（动态绑定） 事件监听器Cache缓存处理（cacheHandles） 针对静态节点的优化： Virtual DOM机制调整 内存优化，更少的占用 按需加载，更灵活的组件化 1: https://www.jianshu.com/p/b87d532afeba \"简书\" [2]: https://www.jb51.net/article/197505.htm \"脚本之家\" Vue3 新特性 CompositionAPI与React.js中的Hooks的异同点 1: https://blog.csdn.net/weixin_39593460/article/details/111322828 \"csdn\" [2]: https://segmentfault.com/a/1190000023184981 \"segmentFault\" Vue请求初始化数据放在Created还是Mounted？ 生命周期 是否获取dom节点 是否可以获取data 是否获取methods beforeCreate 否 否 否 created 否 是 是 beforeMount 否 是 是 mounted 是 是 是 生命周期是否获取dom节点是否可以获取data是否获取methodsbeforeCreate否否否created否是是beforeMount否是是mounted是是是z created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。 mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。 说说你对proxy的理解 React redux中间键 Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-19 19:12:02 "},"前端面试/基础知识.html":{"url":"前端面试/基础知识.html","title":"基础","keywords":"","body":"前端基础 http https 基本概念 HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。 HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。 区别 https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 工作原理 客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。 Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。 客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。 Web服务器利用自己的私钥解密出会话密钥。 Web服务器利用会话密钥加密与客户端之间的通信。 优点 使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器； HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。 HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。 谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。 缺点 HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电； HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响； SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。 SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。 HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。 tcp三次握手 第一次握手：客户端尝试连接服务器，向服务器发送 syn 包（同步序列编号Synchronize Sequence Numbers），syn=j，客户端进入 SYN_SEND 状态等待服务器确认 第二次握手：服务器接收客户端syn包并确认（ack=j+1），同时向客户端发送一个 SYN包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态 第三次握手：第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手 客户端和服务端都需要直到各自可收发，因此需要三次握手 tcp和upd的区别 基于连接与无连接； 对系统资源的要求（TCP较多，UDP少）； UDP程序结构较简单； 流模式与数据报模式 ； TCP保证数据正确性，UDP可能丢包； TCP保证数据顺序，UDP不保证。 webSocket 的实现和应用 实时应用 http请求方式，Head方式 在HTTP1.1规定里8种请求方法，都必须大写的形式存在：(1)GET：获取资源，可以理解为读取或者下载数据； (2)HEAD：获取资源的元信息； (3)POST：向资源提交数据，相当于写入或上传数据； (4)PUT：类似POST； (5)DELETE：删除资源； (6)CONNECT：建立特殊的连接隧道； (7)OPTIONS：列出课对资源实行的方法； (8)TRACE：追踪请求-响应的传输路径。 HEAD方法与 GET 方法类似，也是请求从服务器获取资源，服务器的处理机制也是一样的，但服务器不会返回请求的实体数据，只会传回响应头，也就是资源的“元信息”。 HEAD 方法可以看做是 GET 方法的一个“简化版”或者“轻量版”。因为它的响应头与 GET 完全相同，所以可以用在很多并不真正需要资源的场合，避免传输 body 数据的浪费。 比如，想要检查一个文件是否存在，只要发个 HEAD 请求就可以了，没有必要用 GET 把整个文件都取下来。再比如，要检查文件是否有最新版本，同样也应该用 HEAD，服务器会在响应头里把文件的修改时间传回来。 一个图片url访问后直接下载怎样实现 downloadIamge(imgsrc, name) {//下载图片地址和图片名 let image = new Image(); // 解决跨域 Canvas 污染问题 image.setAttribute(\"crossOrigin\", \"anonymous\"); image.onload = function() { let canvas = document.createElement(\"canvas\"); canvas.width = image.width; canvas.height = image.height; let context = canvas.getContext(\"2d\"); context.drawImage(image, 0, 0, image.width, image.height); let url = canvas.toDataURL(\"image/png\"); //得到图片的base64编码数据 let a = document.createElement(\"a\"); // 生成一个a元素 let event = new MouseEvent(\"click\"); // 创建一个单击事件 a.download = name || \"photo\"; // 设置图片名称 a.href = url; // 将生成的URL设置为a.href属性 a.dispatchEvent(event); // 触发a的单击事件 }; image.src = imgsrc; }, 几个很实用的BOM属性对象方法 location对象 location.href-- 返回或设置当前文档的URL location.search -- 返回URL中的查询字符串部分。例如 http://www.dreamdu.com/dreamdu.php?id=5&name=dreamdu 返回包括(?)后面的内容?id=5&name=dreamdu location.hash -- 返回URL#后面的内容，如果没有#，返回空 location.host -- 返回URL中的域名部分，例如www.dreamdu.com location.hostname -- 返回URL中的主域名部分，例如dreamdu.com location.pathname -- 返回URL的域名后的部分。例如 http://www.dreamdu.com/xhtml/ 返回/xhtml/ location.port -- 返回URL中的端口部分。例如 http://www.dreamdu.com:8080/xhtml/ 返回8080 location.protocol -- 返回URL中的协议部分。例如 http://www.dreamdu.com:8080/xhtml/ 返回(//)前面的内容http: location.assign -- 设置当前文档的URL location.replace() -- 设置当前文档的URL，并且在history对象的地址列表中移除这个URL location.replace(url); location.reload() -- 重载当前页面 history对象 history.go() -- 前进或后退指定的页面数 history.go(num); history.back() -- 后退一页 history.forward() -- 前进一页 Navigator对象 navigator.userAgent -- 返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串) navigator.cookieEnabled -- 返回浏览器是否支持(启用)cookie HtmlDragApi 链接：https://www.nowcoder.com/questionTerminal/26489e6b98a44b3f869d765d9a3c661c?orderByHotValue=1&page=1&onlyReference=false 来源：牛客网 dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发，。 darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。 dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。 dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。 dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。 drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。 dragend：事件主体是被拖放元素，在整个拖放操作结束时触发。 http2.0 新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。 多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。 HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？ HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接； HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞； HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行； HTTP2.0多路复用有多好？ HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。 HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。 header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。 假定一个页面有100个资源需要加载（这个数量对于今天的Web而言还是挺保守的）, 而每一次请求都有1kb的消息头（这同样也并不少见，因为Cookie和引用等东西的存在）, 则至少需要多消耗100kb来获取这些消息头。HTTP2.0可以维护一个字典，差量更新HTTP头部，大大降低因头部传输产生的流量 服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。 服务器推送到底是什么？ 服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度 状态码 2XX 成功 · 200 OK，表示从客户端发来的请求在服务器端被正确处理 · 204 No content，表示请求成功，但响应报文不含实体的主体部分 · 206 Partial Content，进行范围请求 3XX 重定向 · 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL · 302 found，临时性重定向，表示资源临时被分配了新的 URL · 303 see other，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源 · 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况 · 307 temporary redirect，临时重定向，和302含义相同 4XX 客户端错误 · 400 bad request，请求报文存在语法错误 · 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息 · 403 forbidden，表示对请求资源的访问被服务器拒绝 · 404 not found，表示在服务器上没有找到请求的资源 5XX 服务器错误 · 500 internal sever error，表示服务器端在执行请求时发生了错误 · 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求 fetch发送两次请求 fetch发送post请求的时候，总是发送2次，第一次状态码是204，第二次才成功？ 原因很简单，因为你用fetch的post请求的时候，导致fetch 第一次发送了一个Options请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求。 划重点：如果被别人问到，其实这是在迷惑你，发送两次请求的情况确实存在，但这与你所使用的是不是http协议，所采用的是不是fetch真的没有任何关系！ 我们所说的发送2次请求，其实就是在跨域请求时，编写了带预检请求的代码导致多了一次名为OPTIONS的尝试请求 发送2次请求需要满足以下2个条件： 必须要在跨域的情况下 除GET、HEAD和POST(content-type： application/x-www-form-urlencoded, multipart/form-data, text/plain Content-Type)以外的跨域请求（我们可以称为预检(Preflighted)的跨域请求）。 总结： 之所以会发送2次请求，那是因为我们使用了带预检(Preflighted)的跨域请求。该请求会在发送真实的请求之前发送一个类型为OPTIONS的预检请求。预检请求会检测服务器是否支持我们的真实请求所需要的跨域资源，唯有资源满足条件才会发送真实的请求。比如我们在请求头部增加了authorization项，那么在服务器响应头中需要放入Access-Control-Allow-Headers，并且其值中必须要包含authorization，否则OPTIONS预检会失败，从而导致不会发送真实的请求 Cookie,sessionStorage,localStorage 区别 cookie在浏览器与服务器之间来回传递 sessionStorage和localStorage不会把数据发给服务器，仅在本地保存 数据有效期不同 cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 sessionStorage：仅在当前浏览器窗口关闭前有效 localStorage 始终有效，长期保存 cookie数据还有路径的概念，可以限制cookie只属于某个路径下 存储大小也不同，cookie数据不能超过4k，sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 作用域不用 sessionStorage不在不同的浏览器窗口中共享 localStorage在所有同源窗口中都是共享的 cookie也是在所有同源窗口中都是共享的 WebStorage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便 说一下web worker http://www.ruanyifeng.com/blog/2018/07/web-worker.html 在HTML页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker是运行在后台的js，独立于其他脚本，不会影响页面你的性能。并且通过postMessage将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。 html语义化标签的理解 ：页面主题内容 ：h1~h6分级标题，用于创建页面信息的层级关系。 ：呈现小号字体效果,指定细则，输入免责声明、注解、署名、版权。 ：表示内容重要性 ：标记内容着重点 ：突出显示文本（yellow），提醒读者。 ：创建图 ：figure的标题，必须是figure内嵌的第一个或者最后一个元素 ：指明引用或参考，如图书的标题，歌曲、电影、等的名称，演唱会、音乐会、规范、报纸、或法律文件等。 ：引述文本，默认新的一行显示 ：标记时间。datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式。 ：作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接） ：完成进度 Iframe是什么，缺点 iframe就是我们常用的iframe标签：。iframe标签是框架的一种形式，也比较常用到，iframe一般用来包含别的页面 优点 iframe能够原封不动的把嵌入的网页展现出来。 如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。 网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。 如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。 缺点 iframe会阻塞主页面的onload事件； iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。，会产生很多页面，不容易管理。 iframe框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差。 代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用iframe会不利于搜索引擎优化（SEO）。 很多的移动设备无法完全显示框架，设备兼容性差。 iframe框架页面会增加服务器的http请求，对于大型网站是不可取的。 Doctype作用？严格模式与混杂模式如何区分？它们有何差异？ 作用： 声明叫做文件类型定义（DTD），声明的作用为了告诉浏览器该文件的类型。让浏览器解析器知道应该用哪个规范来解析文档。声明必须在 HTML 文档的第一行，这并不是一个 HTML 标签。 严格模式：又称标准模式，是指浏览器按照 W3C 标准解析代码。 混杂模式：又称怪异模式或兼容模式，是指浏览器用自己的方式解析代码。 如何区分：浏览器解析时到底使用严格模式还是混杂模式，与网页中的 DTD 直接相关。 如果文档包含严格的 DOCTYPE ，那么它一般以严格模式呈现。（严格 DTD ——严格模式） 包含过渡 DTD 和 URI 的 DOCTYPE ，也以严格模式呈现，但有过渡 DTD 而没有 URI （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现。（有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式） DOCTYPE 不存在或形式不正确会导致文档以混杂模式呈现。（DTD不存在或者格式不正确——混杂模式） HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的语法，实现时，已经尽可能大的实现了向后兼容。（ HTML5 没有严格和混杂之分） 意义：严格模式与混杂模式存在的意义与其来源密切相关，如果说只存在严格模式，那么许多旧网站必然受到影响，如果只存在混杂模式，那么会回到当时浏览器大战时的混乱，每个浏览器都有自己的解析模式。 Cookie如何防范XXS攻击 简单总结 XSS（跨站脚本攻击）是指攻击者在返回的HTML中嵌入javascript脚本，为了减轻这些攻击，需要在HTTP头部配上，set-cookie：httponly-。这个属性可以防止XSS,它会禁止javascript脚本来访问cookie。 secure - 这个属性告诉浏览器仅在请求为https的时候发送cookie Cookie和Session的区别 由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。 思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。 Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。 所以，总结一下：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中； Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。 一句话概括RESTFUL。 一种软件架构风格，提供了一组设计原则和约束条件。 每一个对象都通过URL来表示，对象用户负责将状态信息打包进每一条信息内， 客户端的无状态请求在头部包含方法信息，即get post put delete。 viewport和移动端布局 click在移动端ios上有300ms的延迟的原因和解决方法 原因： 双击缩放 而这就是click在移动端ios会有300ms的缘由。 方法 粗暴型：禁用缩放 既然双击缩放是造成300ms延迟的原因，那么只要禁用缩放就可以了。禁用缩放，也就没有了双击产生缩放的操作，那么就不需要等待300ms，也就没有了300ms的延迟。 FastClick 原理：在检测到touched事件后，立即触发一个模拟click事件，并把浏览器300ms之后真正触发的click事件阻断掉。 使用： window.addEventListener( \"load\", function() { FastClick.attach( document.body ); }, false ); addEventListener element.addEventListener(event, function, useCapture) event 必须。字符串，指定事件名。 注意: 不要使用 \"on\" 前缀。 例如，使用 \"click\" ,而不是使用 \"onclick\"。 function 必须。指定要事件触发时执行的函数。 当事件对象会作为第一个参数传入函数。 事件对象的类型取决于特定的事件。例如， \"click\" 事件属于 MouseEvent(鼠标事件) 对象。 useCapture 可选。布尔值，指定事件是否在捕获或冒泡阶段执行。 可能值: true - 事件句柄在捕获阶段执行 false- false- 默认。事件句柄在冒泡阶段执行 http常用请求头 请求头 Accept 可接受的响应内容类型（Content-Types）。 Accept: text/plain 固定 Accept-Charset 可接受的字符集 Accept-Charset: utf-8 固定 Accept-Encoding 可接受的响应内容的编码方式。 Accept-Encoding: gzip, deflate 固定 Accept-Language 可接受的响应内容语言列表。 Accept-Language: en-US 固定 Accept-Datetime 可接受的按照时间来表示的响应内容版本 Accept-Datetime: Sat, 26 Dec 2015 17:30:00 GMT 临时 Authorization 用于表示HTTP协议中需要认证资源的认证信息 Authorization: Basic OSdjJGRpbjpvcGVuIANlc2SdDE== 固定 Cache-Control 用来指定当前的请求/回复中的，是否使用缓存机制。 Cache-Control: no-cache 固定 Connection 客户端（浏览器）想要优先使用的连接类型 Connection: keep-alive``Connection: Upgrade 固定 Cookie 由之前服务器通过Set-Cookie（见下文）设置的一个HTTP协议Cookie Cookie: $Version=1; Skin=new; 固定：标准 Content-Length 以8进制表示的请求体的长度 Content-Length: 348 固定 Content-MD5 请求体的内容的二进制 MD5 散列值（数字签名），以 Base64 编码的结果 Content-MD5: oD8dH2sgSW50ZWdyaIEd9D== 废弃 Content-Type 请求体的MIME类型 （用于POST和PUT请求中） Content-Type: application/x-www-form-urlencoded 固定 Date 发送该消息的日期和时间（以RFC 7231中定义的\"HTTP日期\"格式来发送） Date: Dec, 26 Dec 2015 17:30:00 GMT 固定 Expect 表示客户端要求服务器做出特定的行为 Expect: 100-continue 固定 From 发起此请求的用户的邮件地址 From: user@itbilu.com 固定 Host 表示服务器的域名以及服务器所监听的端口号。如果所请求的端口是对应的服务的标准端口（80），则端口号可以省略。 Host: www.itbilu.com:80``Host: www.itbilu.com 固定 If-Match 仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要用于像 PUT 这样的方法中，仅当从用户上次更新某个资源后，该资源未被修改的情况下，才更新该资源。 If-Match: \"9jd00cdj34pss9ejqiw39d82f20d0ikd\" 固定 If-Modified-Since 允许在对应的资源未被修改的情况下返回304未修改 If-Modified-Since: Dec, 26 Dec 2015 17:30:00 GMT 固定 If-None-Match 允许在对应的内容未被修改的情况下返回304未修改（ 304 Not Modified ），参考 超文本传输协议 的实体标记 If-None-Match: \"9jd00cdj34pss9ejqiw39d82f20d0ikd\" 固定 If-Range 如果该实体未被修改过，则向返回所缺少的那一个或多个部分。否则，返回整个新的实体 If-Range: \"9jd00cdj34pss9ejqiw39d82f20d0ikd\" 固定 If-Unmodified-Since 仅当该实体自某个特定时间以来未被修改的情况下，才发送回应。 If-Unmodified-Since: Dec, 26 Dec 2015 17:30:00 GMT 固定 Max-Forwards 限制该消息可被代理及网关转发的次数。 Max-Forwards: 10 固定 Origin 发起一个针对跨域资源共享的请求（该请求要求服务器在响应中加入一个Access-Control-Allow-Origin的消息头，表示访问控制所允许的来源）。 Origin: http://www.itbilu.com 固定: 标准 Pragma 与具体的实现相关，这些字段可能在请求/回应链中的任何时候产生。 Pragma: no-cache 固定 Proxy-Authorization 用于向代理进行认证的认证信息。 Proxy-Authorization: Basic IOoDZRgDOi0vcGVuIHNlNidJi2== 固定 Range 表示请求某个实体的一部分，字节偏移以0开始。 Range: bytes=500-999 固定 Referer 表示浏览器所访问的前一个页面，可以认为是之前访问页面的链接将浏览器带到了当前页面。Referer其实是Referrer这个单词，但RFC制作标准时给拼错了，后来也就将错就错使用Referer了。 Referer: http://itbilu.com/nodejs 固定 TE 浏览器预期接受的传输时的编码方式：可使用回应协议头Transfer-Encoding中的值（还可以使用\"trailers\"表示数据传输时的分块方式）用来表示浏览器希望在最后一个大小为0的块之后还接收到一些额外的字段。 TE: trailers,deflate 固定 User-Agent 浏览器的身份标识字符串 User-Agent: Mozilla/…… 固定 Upgrade 要求服务器升级到一个高版本协议。 Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11 固定 Via 告诉服务器，这个请求是由哪些代理发出的。 Via: 1.0 fred, 1.1 itbilu.com.com (Apache/1.1) 固定 Warning 一个一般性的警告，表示在实体内容体中可能存在错误。 Warning: 199 Miscellaneous warning 固定 响应头 | Accept | 可接受的响应内容类型（Content-Types）。 | Accept: text/plain | 固定 | | ------------------- | ------------------------------------------------------------ | ------------------------------------------------------- | ---------- | | Accept-Charset | 可接受的字符集 | Accept-Charset: utf-8 | 固定 | | Accept-Encoding | 可接受的响应内容的编码方式。 | Accept-Encoding: gzip, deflate | 固定 | | Accept-Language | 可接受的响应内容语言列表。 | Accept-Language: en-US | 固定 | | Accept-Datetime | 可接受的按照时间来表示的响应内容版本 | Accept-Datetime: Sat, 26 Dec 2015 17:30:00 GMT | 临时 | | Authorization | 用于表示HTTP协议中需要认证资源的认证信息 | Authorization: Basic OSdjJGRpbjpvcGVuIANlc2SdDE== | 固定 | | Cache-Control | 用来指定当前的请求/回复中的，是否使用缓存机制。 | Cache-Control: no-cache | 固定 | | Connection | 客户端（浏览器）想要优先使用的连接类型 | Connection: keep-alive``Connection: Upgrade | 固定 | | Cookie | 由之前服务器通过Set-Cookie（见下文）设置的一个HTTP协议Cookie | Cookie: $Version=1; Skin=new; | 固定：标准 | | Content-Length | 以8进制表示的请求体的长度 | Content-Length: 348 | 固定 | | Content-MD5 | 请求体的内容的二进制 MD5 散列值（数字签名），以 Base64 编码的结果 | Content-MD5: oD8dH2sgSW50ZWdyaIEd9D== | 废弃 | | Content-Type | 请求体的MIME类型 （用于POST和PUT请求中） | Content-Type: application/x-www-form-urlencoded | 固定 | | Date | 发送该消息的日期和时间（以RFC 7231中定义的\"HTTP日期\"格式来发送） | Date: Dec, 26 Dec 2015 17:30:00 GMT | 固定 | | Expect | 表示客户端要求服务器做出特定的行为 | Expect: 100-continue | 固定 | | From | 发起此请求的用户的邮件地址 | From: user@itbilu.com | 固定 | | Host | 表示服务器的域名以及服务器所监听的端口号。如果所请求的端口是对应的服务的标准端口（80），则端口号可以省略。 | Host: www.itbilu.com:80``Host: www.itbilu.com | 固定 | | If-Match | 仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要用于像 PUT 这样的方法中，仅当从用户上次更新某个资源后，该资源未被修改的情况下，才更新该资源。 | If-Match: \"9jd00cdj34pss9ejqiw39d82f20d0ikd\" | 固定 | | If-Modified-Since | 允许在对应的资源未被修改的情况下返回304未修改 | If-Modified-Since: Dec, 26 Dec 2015 17:30:00 GMT | 固定 | | If-None-Match | 允许在对应的内容未被修改的情况下返回304未修改（ 304 Not Modified ），参考 超文本传输协议 的实体标记 | If-None-Match: \"9jd00cdj34pss9ejqiw39d82f20d0ikd\" | 固定 | | If-Range | 如果该实体未被修改过，则向返回所缺少的那一个或多个部分。否则，返回整个新的实体 | If-Range: \"9jd00cdj34pss9ejqiw39d82f20d0ikd\" | 固定 | | If-Unmodified-Since | 仅当该实体自某个特定时间以来未被修改的情况下，才发送回应。 | If-Unmodified-Since: Dec, 26 Dec 2015 17:30:00 GMT | 固定 | | Max-Forwards | 限制该消息可被代理及网关转发的次数。 | Max-Forwards: 10 | 固定 | | Origin | 发起一个针对跨域资源共享的请求（该请求要求服务器在响应中加入一个Access-Control-Allow-Origin的消息头，表示访问控制所允许的来源）。 | Origin: http://www.itbilu.com | 固定: 标准 | | Pragma | 与具体的实现相关，这些字段可能在请求/回应链中的任何时候产生。 | Pragma: no-cache | 固定 | | Proxy-Authorization | 用于向代理进行认证的认证信息。 | Proxy-Authorization: Basic IOoDZRgDOi0vcGVuIHNlNidJi2== | 固定 | | Range | 表示请求某个实体的一部分，字节偏移以0开始。 | Range: bytes=500-999 | 固定 | | Referer | 表示浏览器所访问的前一个页面，可以认为是之前访问页面的链接将浏览器带到了当前页面。Referer其实是Referrer这个单词，但RFC制作标准时给拼错了，后来也就将错就错使用Referer了。 | Referer: http://itbilu.com/nodejs | 固定 | | TE | 浏览器预期接受的传输时的编码方式：可使用回应协议头Transfer-Encoding中的值（还可以使用\"trailers\"表示数据传输时的分块方式）用来表示浏览器希望在最后一个大小为0的块之后还接收到一些额外的字段。 | TE: trailers,deflate | 固定 | | User-Agent | 浏览器的身份标识字符串 | User-Agent: Mozilla/…… | 固定 | | Upgrade | 要求服务器升级到一个高版本协议。 | Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11 | 固定 | | Via | 告诉服务器，这个请求是由哪些代理发出的。 | Via: 1.0 fred, 1.1 itbilu.com.com (Apache/1.1) | 固定 | | Warning | 一个一般性的警告，表示在实体内容体中可能存在错误。 | Warning: 199 Miscellaneous warning | 固定 | 强,协商缓存 获取资源形式 状态码 发送请求到服务器 强缓存 从缓存取 200（from cache） 否，直接从缓存取 协商缓存 从缓存取 304（not modified） 是，正如其名，通过服务器来告知缓存是否可用 304 客户端在请求一个文件的时候，发现自己缓存的文件有 Last Modified ，那么在请求中会包含 If Modified Since ，这个时间就是缓存文件的 Last Modified 。因此，如果请求中包含 If Modified Since，就说明已经有缓存在客户端。服务端只要判断这个时间和当前请求的文件的修改时间就可以确定是返回 304 还是 200 。 对于静态文件，例如：CSS、图片，服务器会自动完成 Last Modified 和 If Modified Since 的比较，完成缓存或者更新。但是对于动态页面，就是动态产生的页面，往往没有包含 Last Modified 信息，这样浏览器、网关等都不会做缓存，也就是在每次请求的时候都完成一个 200 的请求。 因此，对于动态页面做缓存加速，首先要在 Response 的 HTTP Header 中增加 Last Modified 定义，其次根据 Request 中的 If Modified Since 和被请求内容的更新时间来返回 200 或者 304 。虽然在返回 304 的时候已经做了一次数据库查询，但是可以避免接下来更多的数据库查询，并且没有返回页面内容而只是一个 HTTP Header，从而大大的降低带宽的消耗，对于用户的感觉也是提高。 强缓存，协商缓存什么时候用哪个 总而言之，强缓存就是设置一个时间，浏览器在该时间内的资源访问都不会再向服务端发起请求，而是使用缓存中的资源文件 协商缓存则是每次请求资源都向服务端协商，询问服务端文件是否被修改，有改则改，没有改动就用缓存文件 优化 优化Dom 优化CSSOM 优化Javascript 减少重绘，回流 图片懒加载（可是区域再加载） 事件委托 防抖(页面滚动 )， function debounce(func， wait) { let timeout; return function() { let context = this; // 指向全局 let args = arguments; if (timeout) { clearTimeout(timeout); } timeout = setTimeout(() => { func.apply(context， args); // context.func(args) }， wait); }; } // 使用 window.onscroll = debounce(function() { console.log('debounce'); }， 1000); 节流(按钮操作) Vue性能优化 引入生产环境的 Vue 文件 使用单文件组件预编译模板 提取组件的 CSS 到单独到文件 利用Object.freeze()提升性能 扁平化 Store 数据结构 合理使用持久化 Store 数据 组件懒加载 其他 webpack模块打包和JavaScript 压缩（如gzip压缩） 利用CDN 按需加载资源 在使用 DOM 操作库时用上 array-ids 缓存优化 避免重定向 启用 HTTP/2 应用性能分析 使用负载均衡方案 为了更快的启动时间考虑一下同构 使用索引加速数据库查询 使用更快的转译方案 避免或最小化 JavaScript 和 CSS 的使用而阻塞渲染 用于未来的一个建议：使用 service workers + 流 图片编码优化，尽量使用svg和字体图标 GET和POST区别 区别 请求参数：GET请求参数是通过URL传递的，多个参数以&连接，POST请求放在request body中。 请求缓存：GET请求会被缓存，而POST请求不会，除非手动设置。 收藏为书签：GET请求支持，POST请求不支持。 安全性：POST比GET安全，GET请求在浏览器回退时是无害的，而POST会再次请求。 历史记录：GET请求参数会被完整保留在浏览历史记录里，而POST中的参数不会被保留。 编码方式：GET请求只能进行url编码，而POST支持多种编码方式。 对参数的数据类型：GET只接受ASCII字符，而POST没有限制。 误区 3.1 请求参数长度限制：GET请求长度最多1024kb，POST对请求数据没有限制 关于此点，在HTTP协议中没有对URL长度进行限制，这个限制是不同的浏览器及服务器由于有不同的规范而带来的限制。 3.2 GET请求一定不能用request body传输数据 GET可以带request body，但不能保证一定能被接收到。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你读出数据，有些服务器直接忽略。 3.3 POST比GET安全性要高 这里的安全是相对性，通过GET提交的数据都将显示到URL上，页面会被浏览器缓存，其他人查看历史记录会看到提交的数据，而POST不会。另外GET提交数据还可能会造成CSRF攻击。 3.4 GET产生一个TCP数据包，POST产生两个TCP数据包 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200 OK(返回数据); 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 OK(返回数据)。注意，尽管POST请求会分两次，但body 是紧随在 header 后面发送的，根本不存在『等待服务器响应』一说。 301,302 字面上的区别就是301是永久重定向，而302是临时重定向。 当然，他们之间也是有共同点的，就是用户都可以看到url替换为了一个新的，然后发出请求。 301适合永久重定向 301比较常用的场景是使用域名跳转。 302用来做临时跳转 比如未登陆的用户访问用户中心重定向到登录页面。 301重定向和302重定向的区别 302重定向只是暂时的重定向，搜索引擎会抓取新的内容而保留旧的地址，因为服务器返回302，所以，搜索搜索引擎认为新的网址是暂时的。 而301重定向是永久的重定向，搜索引擎在抓取新的内容的同时也将旧的网址替换为了重定向之后的网址。 Http支持的方法 1 GET 请求指定的页面信息，并返回实体主体。 2 HEAD 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 3 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 4 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 5 DELETE 请求服务器删除指定的页面。 6 CONNECT HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。 7 OPTIONS 允许客户端查看服务器的性能。 8 TRACE 回显服务器收到的请求，主要用于测试或诊断。 9 PATCH 是对 PUT 方法的补充，用来对已知资源进行局部更新 。 Css画三角形 .triangle{ width: 0px; /*设置宽高为0，所以div的内容为空，从才能形成三角形尖角*/ height: 0px; border-bottom: 200px solid #00a3af; border-left: 200px solid transparent; /*transparent 表示透明*/ border-right: 200px solid transparent; } 200/304 200 在嗅探抓包过程中，常见的有两种200和304。这两个状态码都关系到能否获取重要信息。当客户第一次请求服务器资源，服务器成功返回资源，这时状态码为200。所以，状态码为200的数据包往往包含用户从服务器获取的数据 状态码200：请求已成功，请求所希望的响应头或数据体将随此响应返回。即返回的数据为全量的数据，如果文件不通过GZIP压缩的话，文件是多大，则要有多大传输量。 304 每个资源请求完成后，通常会被缓存在客户端，并会记录资源的有效时间和修改时间。当客户再次请求该资源，客户端首先从缓存中查找该资源。如果该资源存在，并且在有效期，则不请求服务器，就不会产生对应的请求数据包。 如果不在有效期，客户端会请求服务器，重新获取。服务器会判断修改时间，如果没有修改过，就会返回状态码304，告诉客户端该资源仍然有效，客户端会直接使用缓存的资源。针对304的响应，渗透人员可以分析对应的请求包，获取资源路径。如果该资源不限制访问，就可以直接请求获取。否则，就需要进行Cookie劫持，进行获取。 状态码304：客户端和服务器端只需要传输很少的数据量来做文件的校验，如果文件没有修改过，则不需要返回全量的数据。 但发生了客户端强制刷新，如ctrl+f5这种情况下，所有的缓存策略就会失效，服务器端都会返回200；在客户端非强制刷新，如点击刷新按钮或按f5的情况下，服务器端会根据request头中：If-Modified-Since字段的时间与文件的实际修改时间进行比较，如果修改时间比If-Modified-Since时间要新，则服务器会认为文件已经修改过了，向客户端返回全量的数据，客户端本地的缓存失效，状态码为200。如果修改时间比If-Modified-Since时间要旧，则服务器会认为文件并未修改过，并且只会向客户端写回头文件，不返回文件数据，客户端使用本地缓存，状态码为304。 HTML5新增元素 在浏览器地址栏中输入URL后发生了什么 基本流程： ①查询ip地址 ②建立tcp连接，接入服务器 ③浏览器发起http请求 ④服务器后台操作并做出http响应 ⑤网页的解析与渲染 详细步骤如下： 查询ip地址 ①浏览器解析出url中的域名。 ②查询浏览器的DNS缓存。 ③浏览器中没有DNS缓存，则查找本地客户端hosts文件有无对应的ip地址。 ④hosts中无，则查找本地DNS服务器（运营商提供的DNS服务器）有无对应的DNS缓存。 ⑤若本地DNS没有DNS缓存，则向根服务器查询，进行递归查找。 ⑥递归查找从顶级域名开始（如.com）,一步步缩小范围，最终客户端取得ip地址。 tcp连接与http连接 ①http协议建立在tcp协议之上，http请求前，需先进行tcp连接，形成客户端到服务器的稳定的通道。俗称TCP的三次握手。 ②tcp连接完成后，http请求开始，请求有多种方式，常见的有get，post等。 ③http请求包含请求头，也可能包含请求体两部分，请求头中包含我们希望对请求文件的操作的信息，请求体中包含传递给后台的参数。 ④服务器收到http请求后，后台开始工作，如负载平衡，跨域等，这里就是后端的工作了。 ⑤文件处理完毕，生成响应数据包，响应也包含两部分，响应头和相应体，响应体就是我们所请求的文件。 ⑥经过网络传输，文件被下载到本地客户端，客户端开始加载。 html渲染 ①客户端浏览器加载了html文件后，由上到下解析html为DOM树（DOM Tree）。 ②遇到css文件，css中的url发起http请求。 ③这是第二次http请求，由于http1.1协议增加了Connection: keep-alive声明，故tcp连接不会关闭，可以复用。 ④http连接是无状态连接，客户端与服务器端需要重新发起请求--响应。 在请求css的过程中，解析器继续解析html，然后到了script标签。 ⑤由于script可能会改变DOM结构，故解析器停止生成DOM树，解析器被js阻塞，等待js文件发起http请求，然后加载。这是第三次http请求。js执行完成后解析器继续解析。 ⑥由于css文件可能会影响js文件的执行结果，因此需等css文件加载完成后再执行。 ⑦浏览器收到css文件后，开始解析css文件为CSSOM树（CSS Rule Tree）。 ⑧CSSOM树生成后，DOM Tree与CSS Rule Tree结合生成渲染树（Render Tree）。 ⑨Render Tree会被css文件阻塞，渲染树生成后，先布局，绘制渲染树中节点的属性(位置，宽度，大小等)，然后渲染，页面就会呈现信息。 ⑩继续边解析边渲染，遇到了另一个js文件，js文件执行后改变了DOM树，渲染树从被改变的dom开始再次渲染。 ⑪继续向下渲染，碰到一个img标签，浏览器发起http请求，不会等待img加载完成，继续向下渲染，之后再重新渲染此部分。 ⑫DOM树遇到html结束标签，停止解析，进而渲染结束。 从此可以得出网站的一些优化的方法: ①减少DNS查询:将服务器域名的ip信息加入本地host文件。 ②减少http请求数量，对于图片使用雪碧图,对于html文件和css文件，js文件分别进行合并操作。 ③减少下载时间：压缩图片，使用压缩应用压缩文档中的空格，删除文件多余的语句和注释，创造自己的js精简库和精简框架,使用本地浏览器缓存。 ④提前渲染开始时间：将css链接放在html头部。 ⑤减轻解析器的阻塞：将js链接放在body尾部。 Cache-Control 在请求中使用Cache-Control 时 在响应中使用Cache-Control 时 浏览器在生成页面的时候，会生成那两颗树？ ​ 构造两棵树，DOM树和CSSOM规则树，当浏览器接收到服务器相应来的HTML文档后，会遍历文档节点，生成DOM树，CSSOM规则树由浏览器解析CSS文件生成， 描述一下XSS和CRSF攻击，防御方法 哪些请求头是跟缓存相关的 缓存分为两种：强缓存和协商缓存，根据响应的header内容来决定。 强缓存相关字段有expires，cache-control。如果cache-control与expires同时存在的话，cache-control的优先级高于expires。 协商缓存相关字段有Last-Modified/If-Modified-Since，Etag/If-None-Match Cookie有哪些字段可以设置 name　　字段为一个cookie的名称。 value　　字段为一个cookie的值。 domain　　字段为可以访问此cookie的域名。 path　　字段为可以访问此cookie的页面路径。比如domain是abc.com,path是/test，那么只有/test路径下的页面可以读取此cookie。 expires/Max-Age 　　字段为此cookie超时时间。若设置其值为一个时间，那么当到达此时间后，此cookie失效。不设置的话默认值是Session，意思是cookie会和session一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。 Size　　字段 此cookie大小。 http　　字段 cookie的httponly属性。若此属性为true，则只有在http请求头中会带有此cookie的信息，而不能通过document.cookie来访问此cookie。 secure　　 字段 设置是否只能通过https来传递此条cookie 修改 cookie 要想修改一个cookie，只需要重新赋值就行，旧的值会被新的值覆盖。但要注意一点，在设置新cookie时，path/domain这几个选项一定要旧cookie 保持一样。否则不会修改旧值，而是添加了一个新的 cookie。 删除 cookie 删除一个cookie 也挺简单，也是重新赋值，只要将这个新cookie的expires 选项设置为一个过去的时间点就行了。但同样要注意，path/domain/这几个选项一定要旧cookie 保持一样。 cookie 编码 `` cookie其实是个字符串，但这个字符串中逗号、分号、空格被当做了特殊符号。所以当cookie的 key 和 value 中含有这3个特殊字符时，需要对其进行额外编码，一般会用escape进行编码，读取时用unescape进行解码；当然也可以用encodeURIComponent/decodeURIComponent或者`encodeURI/decodeURI 　　　 1、如果只是编码字符串，不和URL有半毛钱关系，那么用escape。 2、如果你需要编码整个URL，然后需要使用这个URL，那么用encodeURI。 3、当你需要编码URL中的参数的时候，那么encodeURIComponent是最好方法。 ```markdown #### [web性能优化](https://blog.csdn.net/daimomo000/article/details/72897436) - 页面 1. 减少 HTTP请求数(http2.0,缓存，资源合并压缩，Css sprites, inline Images, lazy load image) 2. 将外部脚本置底(外链脚本在加载时却会阻塞其他资源,简单可依赖的方法就是将脚本尽可能的往后挪，减少对并发下载的影响。) 3. Lazy Load Javascript 4. 将 CSS放在 HEAD中 5. . 异步请求 Callback（就是将一些行为样式提取出来，慢慢的加载信息的内容） 6. 减少不必要的 HTTP跳转 7. 避免重复的资源请求 8. [精简Javascript和CSS](http://developer.yahoo.com/performance/rules.html#minify) 9. 页面压缩(Gzip, HTML,JS,CSS,图片) 10. **CDN缓存** **DNS缓存** DNS查找流程：浏览器缓存 — 本地hosts文件 — 本地DNS解析器缓存 — 本地DNS服务器 — 本地DNS服务器设置（是否设置转发器）— 根DNS服务器（返回一个负责该域名服务器的一个IP。本地DNS服务器会根据这个IP继续查找服务器，如果查找到的服务器不能解析此域名，则它会找另一个管理此域名的DNS服务器给本地DNS服务器，重复上面的动作，直到找到域名对应的主机） 11. HTML **标签语义化**，即用合理、正确的标签来展示内容，比如 h1-h6 定义标题； **语义化的优点：**易于用户阅读，样式丢失的时候能让页面呈现清晰的结构；有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重；方便其它设备解析，如盲人阅读器根据语义渲染网页；有利于开发和维护，语义化更具可读性，代码更好维护，与CSS关系更和谐 12. CSS 1. **将CSS放在HTML的上面部分，**这个策略不能提高网站的加载速度，但它不会让访问者长时间看着空白屏幕或者无格式的文本（FOUT）等待。如果网页大部分可见元素已经加载出来了，访问者才更有可能等待加载整个页面，从而带来对前端的优化效果。这就是知觉性能。 2. **使用 link 而不是@import** 加载页面时，link标签引入的CSS被同时加载；@import引入的CSS将在页面加载完毕后被加载，也就是说，@import会组织浏览器的并行下载；link是HTML的元素，不存在兼容性问题；@import只有IE5+才能识别；有关link和@import的区别还有很多，推荐一篇文章 https://www.cnblogs.com/my--sunshine/p/6872224.html总之，link标签才是最好的选择，它也能提高网站的前端性能。 3. **合并CSS代码**，比如用 margin 来代替 margin-top、margin-bottom、margin-left、margin-right； 4. **减少重排，**重排会导致浏览器重新计算整个文档，重新构建渲染树，这一过程会降低浏览器的渲染速度。我们应该避免发生重排，下面是触发重排的例子:改变 font-size 和 font-family；改变元素的内外边距；通过JS改变CSS类；通过JS获取DOM元素的位置相关属性（如width、height、left等）；CSS伪类激活；滚动滚动条或者改变窗口大小； 5. **减少重绘，**当元素的外观（如color、background、visibility等属性）发生改变时，会触发重绘。在网站的使用过程中，重绘是无法避免的。不过，浏览器对此做了优化，它会将多次的重排、重绘操作合并为一次执行。不过我们仍需要避免不必要的重绘，如页面滚动时触发的hover事件，可以在滚动的时候禁用 hover 事件，这样页面在滚动时会更加流畅； 6. **减少使用昂贵的属性，**在浏览器绘制屏幕时，所有需要浏览器进行操作或计算的属性相对而言都需要花费更大的代价。如 box-shadow、border-radius、filter、opacity、:nth-child等； 7. **合并、压缩CSS文件** 13. JS 1. **注意作用域，避免全局查找，**访问全局变量比访问局部变量慢，是因为需要遍历作用域链，查找作用域链需要额外的时间。所以在一个函数中，将访问多次的全局对象或者域外变量存储为局部变量来使用。如某个方法需引用全局变量的值，则在该方法所在的对象的作用域中定义一个局部变量等于全局变量的值。避免不必要的属性查找，将属性设置为全局变量。 2. **优化循环，**当 if-else 较多时，建议使用 switch 语句。当分支较多时，用 switch 的效率是很高的，因为 switch 是随机访问的，就是确定了值之后直接跳转到那个特定的分支，而 if-else 是遍历所有可能值，直到找到合适的分支；当循环的数量不多时，展开循环； 3. **最小化语句数，**声明多个变量时，可以使用一个 var 关键字来声明，变量之间用逗号表示；使用数组或对象字面量来新建数组或对象，如 var arr = [1,2,3] ；var obj = {a:1,b:2}； 4. **JS的执行尽量脱离DOM树，限制DOM操作的次数优化DOM交互，**在《JavaScript高级程序设计》一书有这样一段话：在更新少量节点的时候可以直接向 document.body 节点中添加，但是要向 document 中添加大量数据时，如果直接添加这些新节点，这个过程非常缓慢，因为每添加一个节点都会调用父节点的 appendChild() 方法，为了解决这个问题，可以创建一个文档碎片，把所有新节点附加其上，然后把文档碎片一次性添加到 document 中 5. 　**使用事件代理，**页面上的事件处理程序的数量和页面响应用户交互的速度之间有个负相关。所以为了减少事件处理程序，尽量使用事件委托技术。 6. **提高代码的可阅读性，**比如正确标记变量，封装某个重复的行为，合理的注释等。 7. **使用cssText、className一次性改变属性；** 8. **JS定义行为，html定义内容，CSS定义外观；** 14. CDN web性能优化 页面 减少 HTTP请求数(http2.0,缓存，资源合并压缩，Css sprites, inline Images, lazy load image) 将外部脚本置底(外链脚本在加载时却会阻塞其他资源,简单可依赖的方法就是将脚本尽可能的往后挪，减少对并发下载的影响。) Lazy Load Javascript 将 CSS放在 HEAD中 . 异步请求 Callback（就是将一些行为样式提取出来，慢慢的加载信息的内容） 减少不必要的 HTTP跳转 避免重复的资源请求 精简Javascript和CSS 页面压缩(Gzip, HTML,JS,CSS,图片) CDN缓存 DNS缓存 DNS查找流程：浏览器缓存 — 本地hosts文件 — 本地DNS解析器缓存 — 本地DNS服务器 — 本地DNS服务器设置（是否设置转发器）— 根DNS服务器（返回一个负责该域名服务器的一个IP。本地DNS服务器会根据这个IP继续查找服务器，如果查找到的服务器不能解析此域名，则它会找另一个管理此域名的DNS服务器给本地DNS服务器，重复上面的动作，直到找到域名对应的主机） HTML 标签语义化，即用合理、正确的标签来展示内容，比如 h1-h6 定义标题； 语义化的优点：易于用户阅读，样式丢失的时候能让页面呈现清晰的结构；有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重；方便其它设备解析，如盲人阅读器根据语义渲染网页；有利于开发和维护，语义化更具可读性，代码更好维护，与CSS关系更和谐 CSS 将CSS放在HTML的上面部分，这个策略不能提高网站的加载速度，但它不会让访问者长时间看着空白屏幕或者无格式的文本（FOUT）等待。如果网页大部分可见元素已经加载出来了，访问者才更有可能等待加载整个页面，从而带来对前端的优化效果。这就是知觉性能。 使用 link 而不是@import 加载页面时，link标签引入的CSS被同时加载；@import引入的CSS将在页面加载完毕后被加载，也就是说，@import会组织浏览器的并行下载；link是HTML的元素，不存在兼容性问题；@import只有IE5+才能识别；有关link和@import的区别还有很多，推荐一篇文章 https://www.cnblogs.com/my--sunshine/p/6872224.html总之，link标签才是最好的选择，它也能提高网站的前端性能。 合并CSS代码，比如用 margin 来代替 margin-top、margin-bottom、margin-left、margin-right； 减少重排，重排会导致浏览器重新计算整个文档，重新构建渲染树，这一过程会降低浏览器的渲染速度。我们应该避免发生重排，下面是触发重排的例子:改变 font-size 和 font-family；改变元素的内外边距；通过JS改变CSS类；通过JS获取DOM元素的位置相关属性（如width、height、left等）；CSS伪类激活；滚动滚动条或者改变窗口大小； 减少重绘，当元素的外观（如color、background、visibility等属性）发生改变时，会触发重绘。在网站的使用过程中，重绘是无法避免的。不过，浏览器对此做了优化，它会将多次的重排、重绘操作合并为一次执行。不过我们仍需要避免不必要的重绘，如页面滚动时触发的hover事件，可以在滚动的时候禁用 hover 事件，这样页面在滚动时会更加流畅； 减少使用昂贵的属性，在浏览器绘制屏幕时，所有需要浏览器进行操作或计算的属性相对而言都需要花费更大的代价。如 box-shadow、border-radius、filter、opacity、:nth-child等； 合并、压缩CSS文件 JS 注意作用域，避免全局查找，访问全局变量比访问局部变量慢，是因为需要遍历作用域链，查找作用域链需要额外的时间。所以在一个函数中，将访问多次的全局对象或者域外变量存储为局部变量来使用。如某个方法需引用全局变量的值，则在该方法所在的对象的作用域中定义一个局部变量等于全局变量的值。避免不必要的属性查找，将属性设置为全局变量。 优化循环，当 if-else 较多时，建议使用 switch 语句。当分支较多时，用 switch 的效率是很高的，因为 switch 是随机访问的，就是确定了值之后直接跳转到那个特定的分支，而 if-else 是遍历所有可能值，直到找到合适的分支；当循环的数量不多时，展开循环； 最小化语句数，声明多个变量时，可以使用一个 var 关键字来声明，变量之间用逗号表示；使用数组或对象字面量来新建数组或对象，如 var arr = [1,2,3] ；var obj = {a:1,b:2}； JS的执行尽量脱离DOM树，限制DOM操作的次数优化DOM交互，在《JavaScript高级程序设计》一书有这样一段话：在更新少量节点的时候可以直接向 document.body 节点中添加，但是要向 document 中添加大量数据时，如果直接添加这些新节点，这个过程非常缓慢，因为每添加一个节点都会调用父节点的 appendChild() 方法，为了解决这个问题，可以创建一个文档碎片，把所有新节点附加其上，然后把文档碎片一次性添加到 document 中 　使用事件代理，页面上的事件处理程序的数量和页面响应用户交互的速度之间有个负相关。所以为了减少事件处理程序，尽量使用事件委托技术。 提高代码的可阅读性，比如正确标记变量，封装某个重复的行为，合理的注释等。 使用cssText、className一次性改变属性； JS定义行为，html定义内容，CSS定义外观； CDN Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-19 19:12:02 "},"Linux/命令.html":{"url":"Linux/命令.html","title":"命令","keywords":"","body":"基本操作 Linux 关机, 重启 # 关机 shutdown -h now # 重启 shutdown -r now 查看系统, CPU 信息 # 查看系统内核信息 uname -a # 查看系统内核版本 cat /proc/version # 查看当前用户环境变量 env cat /proc/cpuinfo # 查看有几个逻辑cpu, 包括cpu型号 cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c # 查看有几颗cpu,每颗分别是几核 cat /proc/cpuinfo | grep physical | uniq -c # 查看当前CPU运行在32bit还是64bit模式下, 如果是运行在32bit下也不代表CPU不支持64bit getconf LONG_BIT # 结果大于0, 说明支持64bit计算. lm指long mode, 支持lm则是64bit cat /proc/cpuinfo | grep flags | grep ' lm ' | wc -l 建立软连接 ln -s /usr/local/jdk1.8/ jdk rpm 相关 # 查看是否通过rpm安装了该软件 rpm -qa | grep 软件名 sshkey # 创建sshkey ssh-keygen -t rsa -C your_email@example.com #id_rsa.pub 的内容拷贝到要控制的服务器的 home/username/.ssh/authorized_keys 中,如果没有则新建(.ssh权限为700, authorized_keys权限为600) 命令重命名 # 在各个用户的.bash_profile中添加重命名配置 alias ll='ls -alF' 同步服务器时间 sudo ntpdate -u ntp.api.bz 后台运行命令 # 后台运行,并且有nohup.out输出 nohup xxx & # 后台运行, 不输出任何日志 nohup xxx > /dev/null & # 后台运行, 并将错误信息做标准输出到日志中 nohup xxx >out.log 2>&1 & 强制活动用户退出 # 命令来完成强制活动用户退出.其中TTY表示终端名称 pkill -kill -t [TTY] 查看命令路径 which 查看进程所有打开最大 fd 数 ulimit -n 配置 dns vim /etc/resolv.conf nslookup, 查看域名路由表 nslookup google.com last, 最近登录信息列表 # 最近登录的5个账号 last -n 5 设置固定 ip ifconfig em1 192.168.5.177 netmask 255.255.255.0 查看进程内加载的环境变量 # 也可以去 cd /proc 目录下, 查看进程内存中加载的东西 ps eww -p XXXXX(进程号) 查看进程树找到服务器进程 ps auwxf 查看进程启动路径 cd /proc/xxx(进程号) ls -all # cwd对应的是启动路径 添加用户, 配置 sudo 权限 # 新增用户 useradd 用户名 passwd 用户名 #增加sudo权限 vim /etc/sudoers # 修改文件里面的 # root ALL=(ALL) ALL # 用户名 ALL=(ALL) ALL 强制关闭进程名包含 xxx 的所有进程 ps aux|grep xxx | grep -v grep | awk '{print $2}' | xargs kill -9 磁盘, 文件, 目录相关操作 vim 操作 #normal模式下 g表示全局, x表示查找的内容, y表示替换后的内容 :%s/x/y/g #normal模式下 0 # 光标移到行首(数字0) $ # 光标移至行尾 shift + g # 跳到文件最后 gg # 跳到文件头 # 显示行号 :set nu # 去除行号 :set nonu # 检索 /xxx(检索内容) # 从头检索, 按n查找下一个 ?xxx(检索内容) # 从尾部检索 打开只读文件, 修改后需要保存时 (不用切换用户即可保存的方式) # 在normal模式下 :w !sudo tee % 查看磁盘, 文件目录基本信息 # 查看磁盘挂载情况 mount # 查看磁盘分区信息 df # 查看目录及子目录大小 du -H -h # 查看当前目录下各个文件, 文件夹占了多少空间, 不会递归 du -sh * wc 命令 # 查看文件里有多少行 wc -l filename # 看文件里有多少个word wc -w filename # 文件里最长的那一行是多少个字 wc -L filename # 统计字节数 wc -c 常用压缩, 解压缩命令 压缩命令 tar czvf xxx.tar 压缩目录 zip -r xxx.zip 压缩目录 解压缩命令 tar zxvf xxx.tar # 解压到指定文件夹 tar zxvf xxx.tar -C /xxx/yyy/ unzip xxx.zip 变更文件所属用户, 用户组 chown eagleye.eagleye xxx.log cp, scp, mkdir #复制 cp xxx.log # 复制并强制覆盖同名文件 cp -f xxx.log # 复制文件夹 cp -r xxx(源文件夹) yyy(目标文件夹) # 远程复制 scp -P ssh端口 username@10.10.10.101:/home/username/xxx /home/xxx # 级联创建目录 mkdir -p /xxx/yyy/zzz # 批量创建文件夹, 会在test,main下都创建java, resources文件夹 mkdir -p src/{test,main}/{java,resources} 比较两个文件 diff -u 1.txt 2.txt 日志输出的字节数, 可以用作性能测试 # 如果做性能测试, 可以每执行一次, 往日志里面输出 “.” , 这样日志中的字节数就是实际的性能测试运行的次数, 还可以看见实时速率. tail -f xxx.log | pv -bt 查看, 去除特殊字符 # 查看特殊字符 cat -v xxx.sh # 去除特殊字符 sed -i 's/^M//g’ env.sh 去除文件的特殊字符, 比如^M: 需要这样输入: ctrl+v+enter 处理因系统原因引起的文件中特殊字符的问题 # 可以转换为该系统下的文件格式 cat file.sh > file.sh_bak # 先将file.sh中文件内容复制下来然后运行, 然后粘贴内容, 最后ctrl + d 保存退出 cat > file1.sh # 在vim中通过如下设置文件编码和文件格式 :set fileencodings=utf-8 ，然后 w （存盘）一下即可转化为 utf8 格式， :set fileformat=unix # 在mac下使用dos2unix进行文件格式化 find . -name \"*.sh\" | xargs dos2unix tee, 重定向的同时输出到屏幕 awk ‘{print $0}’ xxx.log | tee test.log 检索相关 grep # 反向匹配, 查找不包含xxx的内容 grep -v xxx # 排除所有空行 grep -v '^/pre> # 返回结果 2,则说明第二行是空行 grep -n “^$” 111.txt # 查询以abc开头的行 grep -n “^abc” 111.txt # 同时列出该词语出现在文章的第几行 grep 'xxx' -n xxx.log # 计算一下该字串出现的次数 grep 'xxx' -c xxx.log # 比对的时候，不计较大小写的不同 grep 'xxx' -i xxx.log awk # 以':' 为分隔符,如果第五域有user则输出该行 awk -F ':' '{if ($5 ~ /user/) print $0}' /etc/passwd # 统计单个文件中某个字符（串）(中文无效)出现的次数 awk -v RS='character' 'END {print --NR}' xxx.txt find 检索命令 # 在目录下找后缀是.mysql的文件 find /home/eagleye -name '*.mysql' -print # 会从 /usr 目录开始往下找，找最近3天之内存取过的文件。 find /usr -atime 3 –print # 会从 /usr 目录开始往下找，找最近5天之内修改过的文件。 find /usr -ctime 5 –print # 会从 /doc 目录开始往下找，找jacky 的、文件名开头是 j的文件。 find /doc -user jacky -name 'j*' –print # 会从 /doc 目录开始往下找，找寻文件名是 ja 开头或者 ma开头的文件。 find /doc \\( -name 'ja*' -o- -name 'ma*' \\) –print # 会从 /doc 目录开始往下找，找到凡是文件名结尾为 bak的文件，把它删除掉。-exec 选项是执行的意思，rm 是删除命令，{ } 表示文件名，“\\;”是规定的命令结尾。 find /doc -name '*bak' -exec rm {} \\; 网络相关 查看什么进程使用了该端口 lsof -i:port 获取本机 ip 地址 /sbin/ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk '{print $2}'|tr -d \"addr:\" iptables # 查看iptables状态 service iptables status # 要封停一个ip iptables -I INPUT -s ***.***.***.*** -j DROP # 要解封一个IP，使用下面这条命令： iptables -D INPUT -s ***.***.***.*** -j DROP 备注: 参数-I是表示Insert（添加），-D表示Delete（删除）。后面跟的是规则，INPUT表示入站，***.***.***.***表示要封停的IP，DROP表示放弃连接。 #开启9090端口的访问 /sbin/iptables -I INPUT -p tcp --dport 9090 -j ACCEPT # 防火墙开启、关闭、重启 /etc/init.d/iptables status /etc/init.d/iptables start /etc/init.d/iptables stop /etc/init.d/iptables restart nc 命令, tcp 调试利器 #给某一个endpoint发送TCP请求,就将data的内容发送到对端 nc 192.168.0.11 8000 received_data #上边只监听一次，如果多次可以加上-k参数 nc -lk 8000 tcpdump # dump出本机12301端口的tcp包 tcpdump -i em1 tcp port 12301 -s 1500 -w abc.pcap 跟踪网络路由路径 # traceroute默认使用udp方式, 如果是-I则改成icmp方式 traceroute -I www.163.com # 从ttl第3跳跟踪 traceroute -M 3 www.163.com # 加上端口跟踪 traceroute -p 8080 192.168.10.11 ss # 显示本地打开的所有端口 ss -l # 显示每个进程具体打开的socket ss -pl # 显示所有tcp socket ss -t -a # 显示所有的UDP Socekt ss -u -a # 显示所有已建立的SMTP连接 ss -o state established '( dport = :smtp or sport = :smtp )' # 显示所有已建立的HTTP连接 ss -o state established '( dport = :http or sport = :http )' 找出所有连接X服务器的进程 ss -x src /tmp/.X11-unix/* 列出当前socket统计信息 ss -s 解释：netstat是遍历/proc下面每个PID目录，ss直接读/proc/net下面的统计信息。所以ss执行的时候消耗资源以及消耗的时间都比netstat少很多 netstat # 输出每个ip的连接数，以及总的各个状态的连接数 netstat -n | awk '/^tcp/ {n=split($(NF-1),array,\":\");if(n监控 linux 性能命令 top 按大写的 F 或 O 键，然后按 a-z 可以将进程按照相应的列进行排序, 然后回车。而大写的 R 键可以将当前的排序倒转 列名含义 dmesg, 查看系统日志 dmesg iostat, 磁盘 IO 情况监控 iostat -xz 1 # r/s, w/s, rkB/s, wkB/s：分别表示每秒读写次数和每秒读写数据量（千字节）。读写量过大，可能会引起性能问题。 # await：IO操作的平均等待时间，单位是毫秒。这是应用程序在和磁盘交互时，需要消耗的时间，包括IO等待和实际操作的耗时。如果这个数值过大，可能是硬件设备遇到了瓶颈或者出现故障。 # avgqu-sz：向设备发出的请求平均数量。如果这个数值大于1，可能是硬件设备已经饱和（部分前端硬件设备支持并行写入）。 # %util：设备利用率。这个数值表示设备的繁忙程度，经验值是如果超过60，可能会影响IO性能（可以参照IO操作平均等待时间）。如果到达100%，说明硬件设备已经饱和。 # 如果显示的是逻辑设备的数据，那么设备利用率不代表后端实际的硬件设备已经饱和。值得注意的是，即使IO性能不理想，也不一定意味这应用程序性能会不好，可以利用诸如预读取、写缓存等策略提升应用性能。 free, 内存使用情况 free -m eg: total used free shared buffers cached Mem: 1002 769 232 0 62 421 -/+ buffers/cache: 286 715 Swap: 1153 0 1153 第一部分Mem行: total 内存总数: 1002M used 已经使用的内存数: 769M free 空闲的内存数: 232M shared 当前已经废弃不用,总是0 buffers Buffer 缓存内存数: 62M cached Page 缓存内存数:421M 关系：total(1002M) = used(769M) + free(232M) 第二部分(-/+ buffers/cache): (-buffers/cache) used内存数：286M (指的第一部分Mem行中的used – buffers – cached) (+buffers/cache) free内存数: 715M (指的第一部分Mem行中的free + buffers + cached) 可见-buffers/cache反映的是被程序实实在在吃掉的内存,而+buffers/cache反映的是可以挪用的内存总数. 第三部分是指交换分区 sar, 查看网络吞吐状态 # sar命令在这里可以查看网络设备的吞吐率。在排查性能问题时，可以通过网络设备的吞吐量，判断网络设备是否已经饱和 sar -n DEV 1 # # sar命令在这里用于查看TCP连接状态，其中包括： # active/s：每秒本地发起的TCP连接数，既通过connect调用创建的TCP连接； # passive/s：每秒远程发起的TCP连接数，即通过accept调用创建的TCP连接； # retrans/s：每秒TCP重传数量； # TCP连接数可以用来判断性能问题是否由于建立了过多的连接，进一步可以判断是主动发起的连接，还是被动接受的连接。TCP重传可能是因为网络环境恶劣，或者服务器压力过大导致丢包 sar -n TCP,ETCP 1 vmstat, 给定时间监控 CPU 使用率, 内存使用, 虚拟内存交互, IO 读写 # 2表示每2秒采集一次状态信息, 1表示只采集一次(忽略既是一直采集) vmstat 2 1 eg: r b swpd free buff cache si so bi bo in cs us sy id wa 1 0 0 3499840 315836 3819660 0 0 0 1 2 0 0 0 100 0 0 0 0 3499584 315836 3819660 0 0 0 0 88 158 0 0 100 0 0 0 0 3499708 315836 3819660 0 0 0 2 86 162 0 0 100 0 0 0 0 3499708 315836 3819660 0 0 0 10 81 151 0 0 100 0 1 0 0 3499732 315836 3819660 0 0 0 2 83 154 0 0 100 0 r 表示运行队列 (就是说多少个进程真的分配到 CPU)，我测试的服务器目前 CPU 比较空闲，没什么程序在跑，当这个值超过了 CPU 数目，就会出现 CPU 瓶颈了。这个也和 top 的负载有关系，一般负载超过了 3 就比较高，超过了 5 就高，超过了 10 就不正常了，服务器的状态很危险。top 的负载类似每秒的运行队列。如果运行队列过大，表示你的 CPU 很繁忙，一般会造成 CPU 使用率很高。 b 表示阻塞的进程, 这个不多说，进程阻塞，大家懂的。 swpd 虚拟内存已使用的大小，如果大于 0，表示你的机器物理内存不足了，如果不是程序内存泄露的原因，那么你该升级内存了或者把耗内存的任务迁移到其他机器。 free 空闲的物理内存的大小，我的机器内存总共 8G，剩余 3415M。 buff Linux/Unix 系统是用来存储，目录里面有什么内容，权限等的缓存，我本机大概占用 300 多 M cache cache 直接用来记忆我们打开的文件, 给文件做缓冲，我本机大概占用 300 多 M(这里是 Linux/Unix 的聪明之处，把空闲的物理内存的一部分拿来做文件和目录的缓存，是为了提高 程序执行的性能，当程序使用内存时，buffer/cached 会很快地被使用。) si 每秒从磁盘读入虚拟内存的大小，如果这个值大于 0，表示物理内存不够用或者内存泄露了，要查找耗内存进程解决掉。我的机器内存充裕，一切正常。 so 每秒虚拟内存写入磁盘的大小，如果这个值大于 0，同上。 bi 块设备每秒接收的块数量，这里的块设备是指系统上所有的磁盘和其他块设备，默认块大小是 1024byte，我本机上没什么 IO 操作，所以一直是 0，但是我曾在处理拷贝大量数据 (2-3T) 的机器上看过可以达到 140000/s，磁盘写入速度差不多 140M 每秒 bo 块设备每秒发送的块数量，例如我们读取文件，bo 就要大于 0。bi 和 bo 一般都要接近 0，不然就是 IO 过于频繁，需要调整。 in 每秒 CPU 的中断次数，包括时间中断 cs 每秒上下文切换次数，例如我们调用系统函数，就要进行上下文切换，线程的切换，也要进程上下文切换，这个值要越小越好，太大了，要考虑调低线程或者进程的数目, 例如在 apache 和 nginx 这种 web 服务器中，我们一般做性能测试时会进行几千并发甚至几万并发的测试，选择 web 服务器的进程可以由进程或者线程的峰值一直下调，压测，直到 cs 到一个比较小的值，这个进程和线程数就是比较合适的值了。系统调用也是，每次调用系统函数，我们的代码就会进入内核空间，导致上下文切换，这个是很耗资源，也要尽量避免频繁调用系统函数。上下文切换次数过多表示你的 CPU 大部分浪费在上下文切换，导致 CPU 干正经事的时间少了，CPU 没有充分利用，是不可取的。 us 用户 CPU 时间，我曾经在一个做加密解密很频繁的服务器上，可以看到 us 接近 100,r 运行队列达到 80(机器在做压力测试，性能表现不佳)。 sy 系统 CPU 时间，如果太高，表示系统调用时间长，例如是 IO 操作频繁。 id 空闲 CPU 时间，一般来说，id + us + sy = 100, 一般我认为 id 是空闲 CPU 使用率，us 是用户 CPU 使用率，sy 是系统 CPU 使用率。 wt 等待 IO CPU 时间。 Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-20 16:56:28 "},"树/二叉树入门.html":{"url":"树/二叉树入门.html","title":"二叉树入门","keywords":"","body":"二叉树入门 之前我们实现的符号表中,不难看出,符号表的增删查操作,随着元素个数N的增多,其耗时也是线性增多的,时间复杂度都是0(n), 为了提高运算效率,接下来我们学习树这种数据结构。 场景 java中的HashMap 数据库索引 1.1树的基本定义 树是我们计算机中非常重要的一种数据结构,同时使用树这种数据结构,可以描述现实生活中的很多事物,例如家谱、单位的组织架 构、等等。 树是由n ( n>=1 )个有限结点组成一个具有层次关系的集合。 把它叫做”树”是因为它看起来像一棵倒挂的树,也就是说它是根朝上,而 叶朝下的。 树具有以下特点: 每个结点有零个或多个子结点; 没有父结点的结点为根结点; 每一个非根结点只有一个父结点 ; 每个结点及其后代结点整体上可以看做是一棵树,称为当前结点的父结点的一个子树; 1.2树的相关术语 结点的度: 一个结点含有的子树的个数称为该结点的度; 叶结点: 度为0的结点称为叶结点,也可以叫做终端结点； 分支结点: 度不为0的结点称为分支结点,也可以叫做非终端结点； 结点的层次: 从根结点开始,根结点的层次为1 ,根的直接后继层次为2 ,以此类推； 结点的层序编号: 将树中的结点,按照从上层到下层,同层从左到右的次序排成一个线性序列,把他们编成连续的自然数。 树的度: 树中所有结点的度的最大值 树的高度(深度) : 树中结点的最大层次 森林: m ( m>=0 )个互不相交的树的集合,将一颗非空树的根结点删去,树就变成一个森林;给森林增加一个统- -的根结点,森林就变 成一棵树 1.3二叉树的基本定义 二叉树就是度不超过2的树(每个结点最多有两个子结点) 满二叉树 一个二叉树,如果每一个层的结点树都达到最大值,则这个二叉树就是满二叉树。 完全二叉树: 叶节点只能出现在最下层和次下层,并且最下面一层的结点都集中在该层最左边的若干位置的二_叉树 1.4二叉树的创建 根据对图的观察,我们发现二叉树其实就是由一个-一个的结点及其之间的关系组成的,按照面向对象的思想,我们设计一个结点类来描述结点事物。 结合类API设计： //树结点 public class Node,Value> { //比较Key public Key key; //左节点 public Node left; //右节点 public Node right; //值 public Value value; public Node(Key key, Value value) { this.key = key; this.value = value; } 插入方法put实现思想: 1.如果当前树中没有任何一个结点,则直接把新结点当做根结点使用 2.如果当前树不为空,则从根结点开始: 2.1如果新结点的key小于当前结点的key ,则继续找当前结点的左子结点; 2.2如果新结点的key大于当前结点的key ,则继续找当前结点的右子结点; 2.3如果新结点的key等于当前结点的key ,则树中已经存在这样的结点,替换该结点的value值即可。 //插入 public void put(Key key,Value value){ root = put(root,key,value); } private Node put(Node node,Key key,Value value){ if(node == null){ //创建新节点 node = new Node<>(key,value); N++; return node; } int compareResult = key.compareTo(node.key); //如果小于当前结点，向继续向子左结点查找并插入 if(compareResult0){ node.right = put(node.right,key,value); }else{ //替换Value node.value = value; } return node; } 查询方法Get实现思想: 从根节点开始: 1.如果要查询的key小于当前结点的key ,则继续找当前结点的左子结点; 2.如果要查询的key大于当前结点的key ,则继续找当前结点的右子结点; 3.如果要查询的key等于当前结点的key ,则树中返回当前结点的value。 2.3如果新结点的key等于当前结点的key ,则树中已经存在这样的结点,替换该结点的value值即可。 //查询 public Value get(Key key){ return get(root,key); } private Value get(Node node,Key key){ if( node == null){ return null; } int compareResult = key.compareTo(node.getKey()); //如果小于当前结点，向继续向子左结点查找 if(compareResult 0){ return get(node.right,key); }else{ return node.value; } } 删除方法delete实现思想: 1.找到被删除结点; 2.找到被删除结点右子树中的最小结点minNode 3.删除右子树中的最小结点 4.让被删除结点的左子树称为最小结点minNode的左子树,让被删除结点的右子树称为最小结点minNode的右子树 5.让被删除结点的父节点指向最小结点minNode //删除 public void delete(Key key){ delete(root,key); } private Node delete(Node node,Key key){ if(node == null){ return null; } int compareResult = key.compareTo(node.getKey()); if(compareResult 0){ //向右查找 重新挂载右节点 node.right = delete(node.right,key); }else{ //找到了删除结点 N--; //如果左右结点有为空的，则直接将左或右结点返回 if(node.left == null){ return node.right; } if(node.right == null){ return node.left; } Node minNode = node.right; //查找到12结点 while (minNode.left != null){ minNode = minNode.left; } Node n = node.right; //查找到14结点，并清除左12结点 while (n.left != null){ //判断左节点的左节点是否为空，找到了14结点了 if(n.left.left == null){ n.left = null; }else{ //继续查找 n = n.left; } } //12结点左右结点挂载node 10左右结点 minNode.left = node.left; minNode.right = node.right; //返回12结点挂载到20结点上去 node = minNode; } return node; } 1.5二叉树的基本遍历（深度优先） 很多情况下,我们可能需要像遍历数组数组-样,遍历树,从而拿出树中存储的每一个元素 ,由于树状结构和线性结构不一-样,它没 有办法从头开始依次向后遍历,所以存在如何遍历,也就是按照什么样的搜索路径进行遍历的问题。 我们把树简单的画作上图中的样子,由一个根节点、一个左子树、 一个右子树组成 ,那么按照根节点什么时候被访问,我们可以把二 叉树的遍历分为以下三种方式: 1.前序遍历; 先访问根结点,然后再访问左子树,最后访问右子树 实现步骤: 把当前结点的key放入到队列中; 找到当前结点的左子树,如果不为空,递归遍历左子树 找到当前结点的右子树,如果不为空,递归遍历右子树 2.2如果当前结点的左子结点不为空,则把左子结点放入到队列中 2.3如果当前结点的右子结点不为空,则把右子结点放入到队列中 //前序遍历 public Queue perErgodic(){ Queue queue = new LinkedList<>(); perErgodic(root,queue); return queue; } //前序遍历 private void perErgodic(Node node, Queue queue){ if(node == null){ return; } queue.add(node.key); perErgodic(node.left,queue); perErgodic(node.right,queue); } 实现结果：EBADCGFH 2.中序遍历; 先访问左子树,中间访问根节点,最后访问右子树 实现步骤: 找到当前结点的左子树,如果不为空,递归遍历左子树 把当前结点的key放入到队列中; 找到当前结点的右子树,如果不为空,递归遍历右子树 2.2如果当前结点的左子结点不为空,则把左子结点放入到队列中 2.3如果当前结点的右子结点不为空,则把右子结点放入到队列中 //中序遍历 public Queue midErgodic(){ Queue queue = new LinkedList<>(); midErgodic(root,queue); return queue; } //中序遍历 private void midErgodic(Node node, Queue queue){ if(node == null){ return; } midErgodic(node.left,queue); queue.add(node.key); midErgodic(node.right,queue); } 实现结果：ABCDEFGH 3.后序遍历; 先访问左子树,再访问右子树,最后访问根节点 实现步骤: 找到当前结点的左子树,如果不为空,递归遍历左子树 找到当前结点的右子树,如果不为空,递归遍历右子树 把当前结点的key放入到队列中; 2.2如果当前结点的左子结点不为空,则把左子结点放入到队列中 2.3如果当前结点的右子结点不为空,则把右子结点放入到队列中 //后序遍历 public Queue afterErgodic(){ Queue queue = new LinkedList<>(); afterErgodic(root,queue); return queue; } //后序遍历 private void afterErgodic(Node node, Queue queue){ if(node == null){ return; } afterErgodic(node.left,queue); afterErgodic(node.right,queue); queue.add(node.key); } 运行结果：ACDBFHGE 1.6二叉树的层序遍历（广度优先） 实现步骤: 创建队列,存储每一层的结点; 使用循环从队列中弹出一个结点: 2.1 获取当前结点的key ; 2.2 如果当前结点的左子结点不为空,则把左子结点放入到队列中 2.3 如果当前结点的右子结点不为空,则把右子结点放入到队列中 代码编写： //层序遍历 public Queue layerErgodic(){ Queue keys= new LinkedList<>(); Queue> nodes = new LinkedList<>(); nodes.add(root); while (!nodes.isEmpty()){ Node n = nodes.poll(); keys.add(n.key); //添加了左节点放到队列中 if(n.left != null){ nodes.add(n.left); } //添加了右节点放到队列中 if(n.right != null){ nodes.add(n.right); } } return keys; } 运行结果：EBGADFHC 1.7二叉树的最大深度问题 需求： 给定一棵树,请计算树的最大深度(树的根节点到最远叶子结点的最长路径上的结点数); 实现步骤: 如果根结点为空,则最大深度为0 ; 计算左子树的最大深度; 计算右子树的最大深度; 当前树的最大深度=左子树的最大深度和右子树的最大深度中的较大者+1 public int getMaxDepth(){ return getMaxDepth(root); } private int getMaxDepth(Node node){ if(node == null){ return 0; } int max = 0; int leftMax = 0; int rightMax =0; if(node.left != null){ leftMax = getMaxDepth(node.left); }if(node.right != null){ rightMax = getMaxDepth(node.right); } max = Math.max(leftMax,rightMax)+1; return max; } 1.8.源码 //二叉树 public class BinaryTree,Value> { //根节点 private Node root; private int N; public int getSize() { return N; } //插入 public void put(Key key,Value value){ root = put(root,key,value); } private Node put(Node node,Key key,Value value){ if(node == null){ node = new Node<>(key,value); N++; return node; } int compareResult = key.compareTo(node.key); if(compareResult0){ node.right = put(node.right,key,value); }else{ node.value = value; } return node; } //查询 public Value get(Key key){ return get(root,key); } private Value get(Node node,Key key){ if( node == null){ return null; } int compareResult = key.compareTo(node.key); if(compareResult 0){ return get(node.right,key); }else{ return node.value; } } //删除 public void delete(Key key){ delete(root,key); } private Node delete(Node node,Key key){ if(node == null){ return null; } int compareResult = key.compareTo(node.key); if(compareResult 0){ node.right = delete(node.right,key); }else{ N--; if(node.left == null){ return node.right; } if(node.right == null){ return node.left; } Node minNode = node.right; while (minNode.left != null){ minNode = minNode.left; } Node n = node.right; while (n.left != null){ if(n.left.left == null){ n.left = null; }else{ n = n.left; } } minNode.left = node.left; minNode.right = node.right; node = minNode; } return node; } public Node min(){ return min(root); } private Node min(Node node){ if(node == null){ return null; } if(node.left != null){ return min(node.left); } return node; } public Node max(){ return max(root); } private Node max(Node node){ if(node == null){ return null; } if(node.right != null){ return max(node.left); } return node; } //前序遍历 public Queue perErgodic(){ Queue queue = new LinkedList<>(); perErgodic(root,queue); return queue; } //前序遍历 private void perErgodic(Node node, Queue queue){ if(node == null){ return; } queue.add(node.key); perErgodic(node.left,queue); perErgodic(node.right,queue); } //中序遍历 public Queue midErgodic(){ Queue queue = new LinkedList<>(); midErgodic(root,queue); return queue; } //中序遍历 private void midErgodic(Node node, Queue queue){ if(node == null){ return; } midErgodic(node.left,queue); queue.add(node.key); midErgodic(node.right,queue); } //后序遍历 public Queue afterErgodic(){ Queue queue = new LinkedList<>(); afterErgodic(root,queue); return queue; } //后序遍历 private void afterErgodic(Node node, Queue queue){ if(node == null){ return; } afterErgodic(node.left,queue); afterErgodic(node.right,queue); queue.add(node.key); } //层序遍历 public Queue layerErgodic(){ Queue keys= new LinkedList<>(); Queue> nodes = new LinkedList<>(); nodes.add(root); while (!nodes.isEmpty()){ Node n = nodes.poll(); keys.add(n.key); //添加了左节点放到队列中 if(n.left != null){ nodes.add(n.left); } //添加了右节点放到队列中 if(n.right != null){ nodes.add(n.right); } } return keys; } public int getMaxDepth(){ return getMaxDepth(root); } private int getMaxDepth(Node node){ if(node == null){ return 0; } int max = 0; int leftMax = 0; int rightMax =0; if(node.left != null){ leftMax = getMaxDepth(node.left); }if(node.right != null){ rightMax = getMaxDepth(node.right); } max = Math.max(leftMax,rightMax)+1; return max; } } Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-19 19:14:07 "},"树/平衡树.html":{"url":"树/平衡树.html","title":"平衡树","keywords":"","body":"平衡树 之前我们学习过二叉查找树,发现它的查询效率比单纯的链表和数组的查询效率要高很多,大部分情况下,确实是这样的,不幸的是,在最坏情况下,二叉查找树的性能还是很糟糕。 例如我们依次往二叉查找树中插入9,8,7,6,5,4,3,2,1这9个数据,那么最终构造出来的树是长得下面这个样子: 我们会发现,如果我们要查找1这个元素,查找的效率依旧会很低。效率低的原因在于这个树并不平衡,全部是向左边分支,如果我们有一种方法,能够不受插入数据的影响,让生成的树都像完全: -叉树那样,那么即使在最坏情况下,查找的效率依旧会很好。 1.1 2-3查找树 为了保证查找树的平衡性,我们需要一些灵活性 ,因此在这里我们允许树中的一个结点保存多个键。确切的说,我们将一棵标准的二 二叉查找树中的结点称为2结点(含有一个 键和两条链) ,而现在我们引入3-结点,它含有两个键和三E条链。2-结点和3结点中的每条链都对应着其中保存的键所分割产生的一个区间。 1.1.1 2-3查找树的定义 一棵2-3查找树要么为空 ,要么满足满足下面两个要求: 结点: 含有一个键(及其对应的值)和两条链,左链接指向2-3树中的键都小于该结点,右链接指向的2-3树中的键都大于该结点。 含有两个键(及其对应的值)和三条链,左链接指向的2-3树中的键都小于该结点,中链接指向的2-3树中的键都位于该结点的两个键之间,右链接指向的2 3树中的键都大于该结点。 1.1.2 2-3查找 将二叉查找树的查找算法一般化我们就能够 直接得到2-3树的查找算法。要判断一个键是否在树中,我们先将它和根结点中的键比较。如果它和其中任意一个相等， 查找命中 ;否则我们就根据比较的结果找到指向相应区间的连接,并在其指向的子树中递归地继续查找如里这个旦空链接查找未命中. 1.1.3 2-3插入 1.1.3.1向2-结点中插入新键 往2-3树中插入元素和往二=叉查找树中插入元素-样,首先要进行查找,然后将节点挂到未找到的节点上。2-3树之 所以能够保证在最差的情况下的效率的原因在于其插入之后仍然能够保持平衡状态。如果查找后未找到的节点是一个2.结点 ,那么很容易,我们只需要将新的元素放到这个2-结点里面使其变成一个3-结点即可。 但是如果查找的节点结束于-个3-结点 ,那么可能有点麻烦。 1.1.3.2向棵只含有一一个3-结点的树中插入新键 假设2-3树只包含一个3-结点 ,这个结点有两个键,没有空间来插入第三个键了,最自然的方式是我们假设这个结点能存放三个元素,暂时使其变成一个4 结点,同时他包含四条链接。然后,我们将这个4结点的中间元素提升,左边的键作为其左子结点,右边的键作为其右子结点。插入完成,变为平衡2-3查找树,树的高度从0变为1。 1.1.3.3向个父结点为2-结点的3结点中插入新键 和上面的情况一样一样,我们也可以将新的元素插入到3-结点中,使其成为一个临时的4结点,然后,将该结点中的中间元素提升到父结点即2-结点中,使其父结点成为一个3-结点 ,然后将左右结点分别挂在这个3结点的恰当位置。 1.3.1.4向一个父结点为3-结点的3-结点中插入新键 当我们插入的结点是3-结点的时候,我们将该结点拆分,中间元素提升至父结点,但是此时父结点是一个3-结点 ,插入之后,父结点变成了4结点，然后继续将中间元素提升至其父结点,直至遇到一个父结点是2-结点，然后将其变为3-结点,不需要继续进行拆分。 1.3.1.5分解根结点 当插入结点到根结点的路径上全部是3-结点的时候,最终我们的根结点会编程一个临时的4-结点 ,此时,就需要将根结点拆分为两个2-结点,树的高度加1。 1.3.4 2-3树的性质 通过对2-3树插入操作的分析,我们发现在插入的时候, 2-3树需要做一些局部的变换来保持2-3树的平衡。一 棵完全平衡的2-3树具有以下性质: ​ 1.任意空链接到根结点的路径长度都是相等的。 ​ 2.4-结点变换为3-结点时,树的高度不会发生变化,只有当根结点是临时的4结点,分解根结点时,树高+1。 ​ 3.2-3树与普通二叉查找树最大的区别在于,普通的二叉查找树是自顶向下生长,而2-3树是自底向上生长。 1.3.5 2-3树的实现 直接实现2-3树比较复杂,因为: 需要处理不同的结点类型,非常繁琐; 需要多次比较操作来将结点下移; 需要上移来拆分4-结点; 拆分4.结点的情况有很多种; 2-3查找树实现起来比较复杂,在某些情况插入后的平衡操作可能会使得效率降低。但是2-3查找树作为一 种比较重要的概念和思路对于我们后面要讲到的红黑树、B树和B+树非常重要。 1.2红黑树 我们前面介绍了2-3树,可以看到2 -3树能保证在插入元素之后,树依然保持平衡状态,它的最坏情况下所有子结点都是2-结点,树的高度为IgN,相比于我们普通的二叉查找树,最坏情况下树的高度为N ,确实保证了最坏情况下的时间复杂度,但是2-3树实现起来过于复杂,所以我们介绍一种2 3树思想的简单实现:红黑树。 红黑树主要是对2-3树进行编码,红黑树背后的基本思想是用标准的二叉查找树(完全由2-结点构成)和一些额外的信息(替换3-结点)来表示2-3树。我们将树中的链接分为两种类型: 红链接:将两个2结点连接起来构成一个3-结点 ; 黑链接:则是2-3树中的普通链接。 确切的说,我们将3结点表示为由由一条左斜的红色链接(两个2结点其中之一是另一 个的左子结点)相连的两个2结点。这种表示法的一个优点是 ,我们无需修改就可以直接使用标准的二二又查找树的get方法。 1.2.1红黑树的定义 红黑树是含有红黑链接并满足下列条件的二叉查找树: ​ 1.红链接均为左链接; ​ 2.没有任何一个结点同时和两条红链接相连; ​ 3.该树是完美黑色平衡的,即任意空链接到根结点的路径上的黑链接数量相同; 下面是红黑树与2-3树的对应关系: 1.2.2红黑树结点API 因为每个结点都只会有-条指向自己的链接(从它的父结点指向它) , 我们可以在之前的Node结点中添加一个布尔类型的变量color来表示链接的颜色。如果指向它的链接是红色的,那么该变量的值为true ,如果链接是黑色的,那么该变量的值为false. API设计 1.2.3平衡化 在对红黑树进行一些增删改 查的操作后,很有可能会出现红色的右链接或者两条连续红色的链接,而这些都不满足红黑树的定义,所以我们需要对这些情况通过旋转进行修复,让红黑树保持平衡。 1.2.3.1左旋 当某个结点的左子结点为黑色,右子结点为红色,此时需要左旋。 前提:当前结点为h ,它的右子结点为x ; 左旋过程: 让x的左子结点变为h的右子结点: h.right=x.left; 让h成为x的左子结点: x.left=h; 让h的color属性变为x的color属性值: x.]color=h.color; 让h的color属性变为RED : h.color=true; 1.2.3.2右旋 当某个结点的左子结点是红色,且左子结点的左子结点也是红色,需要右旋 前提:当前结点为h ,它的左子结点为x ; 右旋过程: 1.让x的右子结点成为h的左子结点: h.left = x.right; 2.让h成为x的右子结点: x.right=h; 3.让x的color变为h的color属性值: x.color = h.color; 4.让h的color为RED ; 1.2.4向单个2-结点中插入新键 一棵只含有一个键的红黑树只含有一个2结点。插入另一个键后,我们马上就需要将他们旋转。 如果新键小于当前结点的键,我们只需要新增一个红色结点即可 ,新的红黑树和单个3-结点完全等价。 如果新键大于当前结点的键,那么新增的红色结点将会产生-条红色的右链接 ,此时我们需要通过左旋,把红色右链接变成左链接,插入操作才算完成。形成的新的红黑树依然和3-结点等价,其中含有两个键, 一条红色链接。 1.2.5向底部的2-结点插入新键 用和二又查找树相同的方式向一棵红黑树中插入一 个新键,会在树的底部新增一个结点(可以保证有序性) , 唯一区别的地方是我们会用红链接将新结点和它的父结点相连。如果它的父结点是一个2结点 ,那么刚才讨论的两种方式仍然适用。 1.2.6颜色反转 当一个结点的左子结点和右子结点的color都为RED时,也就是出现了临时的4-结点,此时只需要把左子结点和右子结点的颜色变为BLACK ,同时让当前结点的颜色变为RED即可。 1.2.7向一棵双键树(即一个3-结点)中插入新键 这种情况有可以分为三种子情况: 1.新键大于原树中的两个键 2.新键小于原树中的两个键 3.新键介于原数中两个键之间 1.2.8根结点的颜色总是黑色 之前我们介绍结点API的时候,在结点Node对象中Color属性表示的是父结点指向当前结点的连接的颜色,由于根结点不存在父结点,所以每次插入操作后,我们都需要把根结点的颜色设置为黑色。 1.2.9向树底部的3-结点插入新键 假设在树的底部的一个3-结点下加入一个新的结点。前面我们所讲的3种情况都会出现。指向新结点的链接可能是3-结点的右链接(此时我们只需要转换颜色即可)，或是左链接(此时我们需要进行右旋转然后再转换)，或是中链接(此时需要先左旋转然后再右旋转，最后转换颜色)。颜色转换会使中间结点的颜色变红，相当于将它送入了父结点。这意味着父结点中继续插入一个新键，我们只需要使用相同的方法解决即可,直到遇到一个2-结点或者根结点为止。 1.2.10红黑树的API设计 //树结点 public class Node,Value> { //鍵 public Key key; //左节点 public Node left; //右节点 public Node right; //值 public Value value; //颜色 红色true 黑色false public boolean color; public Node(Key key, Value value,boolean color) { this.key = key; this.value = value; this.color = color; } } 1.2.11红黑树的实现 //红黑树 public class RedBlackTree,Value> { private static final boolean RED = true; private static final boolean BLACK = false; //根节点 private Node root; private int N; //判断当前结点的父指向链接是否是红色 private boolean isRed(Node node){ if(node == null){ return BLACK; } return node.color; } //获取树中元素个数 public int size(){ return N; } //左旋调整 private Node rotateLeft(Node h){ //获取右节点x Node x = h.right; //h的右结点指向x的左结点 h.right = x.left; //x节点左结点指向h x.left = h; //x颜色变化h颜色 x.color = h.color; //h颜色变成红色 h.color = RED; return x; } //右旋调整 private Node rotateRight(Node h){ //获取左节点x Node x = h.left; //h的左结点指向x的右结点 h.left = x.right; //x节点右结点指向h x.right = h; //x颜色变化h颜色 x.color = BLACK; //h颜色变成红色 h.color = RED; return x; } //颜色反转 相当完成拆分4-结点 private void flipColors(Node h ){ h.color = RED; h.left.color = BLACK; h.right.color = BLACK; } //在整个树插入操作 public void put(Key key,Value val){ put(root,key,val); root.color = BLACK; } //在指定结点完成插入操作 private Node put(Node h ,Key key,Value val){ //判断H是否为空，如果为空,创建一个新结点红色结点 if(h == null){ N++; return new Node<>(key,val,RED); } int compareResult = key.compareTo(h.key); if(compareResult0){ h.right = put(h.right,key,val); }else{ h.value = val; } //左旋 左结点黑色 右结点是红色 if(isRed(h.right) && !isRed(h.left)){ h = rotateLeft(h); } //右旋 左结点红色 左结点的左结点是红色 if(isRed(h.left) && !isRed(h.left.left)){ h = rotateRight(h); } if(isRed(h.left) && isRed(h.right)){ flipColors(h); } return h; } //根据Key在整个树查询 public Value get(Key key){ return get(root,key); } //根据Key在指定结点查询(和二叉树一样) private Value get(Node h ,Key key){ if(h == null){ return null; } int compareResult = key.compareTo(h.key); if(compareResult 0){ return get(h.right,key); }else{ return h.value; } } } Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-19 19:14:07 "},"相关开发文档/相关库 开发文档链接.html":{"url":"相关开发文档/相关库 开发文档链接.html","title":"链接","keywords":"","body":"相关库 开发文档链接 请求 axios axios 请求库 tests 动画 ant motion Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-22 09:38:54 "},"规范/前端使用 Commitizen 规范 git commit 全中文汉化.html":{"url":"规范/前端使用 Commitizen 规范 git commit 全中文汉化.html","title":"规范","keywords":"","body":"安装 commitizen sudo npm install -g commitizen或sudo cnpm install -g commitizen package.json 如果没有 package.json 文件, 先生成 package.json 文件 ：npm init --yes 初始化 commitizen init cz-conventional-changelog --save --save-exact 提交 git add .git commit 改为 git cz执行后出现这个界面表示已经安装成功了 安装中文包 执行命令npm i cz-conventional-changelog-zh或cnpm i cz-conventional-changelog-zh 修改 package.json 配置 \"config\": { \"commitizen\": { \"path\": \"./node_modules/cz-conventional-changelog\" } } \"config\": { \"commitizen\": { \"path\": \"./node_modules/cz-conventional-changelog-zh\" } } 将 path 的./node_modules/cz-conventional-changelog修改为./node_modules/cz-conventional-changelog-zh 再次执行提交 git cz 界面将会变成这个样子 添加中文标签 修改 package.json 文件添加配置 \"defaultType\":\"[新增功能]\", \"types\": { \"[新增功能]\": { \"description\": \"新增功能点、新增需求\", \"title\": \"Features\" }, \"[Bug修复]\": { \"description\": \"修复Bug,线上，测试，验收阶段的bug\", \"title\": \"Bug Fixes\" }, \"[文档修改]\": { \"description\": \"文档增删改\", \"title\": \"Documentation\" }, \"[样式修改]\": { \"description\": \"样式修改(空白、格式、缺少分号等)\", \"title\": \"Styles\" }, \"[代码重构]\": { \"description\": \"既不修复bug也不添加新功能的更改\", \"title\": \"Code Refactoring\" }, \"[性能优化]\": { \"description\": \"性能优化\", \"title\": \"Performance Improvements\" }, \"[测试代码]\": { \"description\": \"增加测试\", \"title\": \"Tests\" }, \"[编译代码]\": { \"description\": \"影响构建系统或外部依赖项的更改(示例范围:gulp、broccoli、npm)\", \"title\": \"Builds\" }, \"[持续集成]\": { \"description\": \"对CI配置文件和脚本的更改(示例范围:Travis, Circle, BrowserStack, SauceLabs)\", \"title\": \"Continuous Integrations\" }, \"[其他提交]\": { \"description\": \"除src目录或测试文件以外的修改\", \"title\": \"Chores\" }, \"[回退更改]\": { \"description\": \"回退历史版本\", \"title\": \"Reverts\" }, \"[修改冲突]\": { \"description\": \"修改冲突\", \"title\": \"Conflict\" }, \"[字体修改]\": { \"description\": \"字体文件更新\", \"title\": \"Fonts\" }, \"[删除文件]\": { \"description\": \"删除文件\", \"title\": \"Delete Files\" }, \"[暂存文件]\": { \"description\": \"暂存文件\", \"title\": \"Stash Files\" } } 添加后的 package.json 为 { \"name\": \"gitcommittest\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": { \"cz-conventional-changelog\": \"^3.3.0\" }, \"config\": { \"commitizen\": { \"path\": \"./node_modules/cz-conventional-changelog-zh\", \"defaultType\":\"[新增功能]\", \"types\": { \"[新增功能]\": { \"description\": \"新增功能点、新增需求\", \"title\": \"Features\" }, \"[Bug修复]\": { \"description\": \"修复Bug,线上，测试，验收阶段的bug\", \"title\": \"Bug Fixes\" }, \"[文档修改]\": { \"description\": \"文档增删改\", \"title\": \"Documentation\" }, \"[样式修改]\": { \"description\": \"样式修改(空白、格式、缺少分号等)\", \"title\": \"Styles\" }, \"[代码重构]\": { \"description\": \"既不修复bug也不添加新功能的更改\", \"title\": \"Code Refactoring\" }, \"[性能优化]\": { \"description\": \"性能优化\", \"title\": \"Performance Improvements\" }, \"[测试代码]\": { \"description\": \"增加测试\", \"title\": \"Tests\" }, \"[编译代码]\": { \"description\": \"影响构建系统或外部依赖项的更改(示例范围:gulp、broccoli、npm)\", \"title\": \"Builds\" }, \"[持续集成]\": { \"description\": \"对CI配置文件和脚本的更改(示例范围:Travis, Circle, BrowserStack, SauceLabs)\", \"title\": \"Continuous Integrations\" }, \"[其他提交]\": { \"description\": \"除src目录或测试文件以外的修改\", \"title\": \"Chores\" }, \"[回退更改]\": { \"description\": \"回退历史版本\", \"title\": \"Reverts\" }, \"[修改冲突]\": { \"description\": \"修改冲突\", \"title\": \"Conflict\" }, \"[字体修改]\": { \"description\": \"字体文件更新\", \"title\": \"Fonts\" }, \"[删除文件]\": { \"description\": \"删除文件\", \"title\": \"Delete Files\" }, \"[暂存文件]\": { \"description\": \"暂存文件\", \"title\": \"Stash Files\" } } } } } 再次运行 git cz 显示的界面 Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-19 19:15:19 "},"前端杂项/方法封装.html":{"url":"前端杂项/方法封装.html","title":"方法封装","keywords":"","body":"各种方法 1、数据类型 function type(para) { return Object.prototype.toString.call(para) // [object ?] } 2、数组去重 function unique1(arr) { return [...new Set(arr)] } function unique2(arr) { var obj = {}; return arr.filter(ele => { if (!obj[ele]) { obj[ele] = true; return true; } }) } function unique3(arr) { var result = []; arr.forEach(ele => { if (result.indexOf(ele) == -1) { result.push(ele) } }) return result; } 3、 字符串去重 String.prototype.unique = function () { var obj = {}, str = '', len = this.length; for (var i = 0; i 4、深拷贝 浅拷贝 //深克隆（深克隆不考虑函数） function deepClone(obj, result) { var result = result || {}; for (var prop in obj) { if (obj.hasOwnProperty(prop)) { if (typeof obj[prop] == 'object' && obj[prop] !== null) { // 引用值(obj/array)且不为null if (Object.prototype.toString.call(obj[prop]) == '[object Object]') { // 对象 result[prop] = {}; } else { // 数组 result[prop] = []; } deepClone(obj[prop], result[prop]) } else { // 原始值或func result[prop] = obj[prop] } } } return result; } // 深浅克隆是针对引用值 function deepClone(target) { if (typeof (target) !== 'object') { return target; } var result; if (Object.prototype.toString.call(target) == '[object Array]') { // 数组 result = [] } else { // 对象 result = {}; } for (var prop in target) { if (target.hasOwnProperty(prop)) { result[prop] = deepClone(target[prop]) } } return result; } // 无法复制函数 var o1 = jsON.parse(jsON.stringify(obj1)); function deepClone(obj, cache = new WeakMap()) { if (typeof obj !== 'object') return obj // 普通类型，直接返回 if (obj === null) return obj if (cache.get(obj)) return cache.get(obj) // 防止循环引用，程序进入死循环 if (obj instanceof Date) return new Date(obj) if (obj instanceof RegExp) return new RegExp(obj) // 找到所属原型上的constructor，所属原型上的constructor指向当前对象的构造函数 let cloneObj = new obj.constructor() cache.set(obj, cloneObj) // 缓存拷贝的对象，用于处理循环引用的情况 for (let key in obj) { if (obj.hasOwnProperty(key)) { cloneObj[key] = deepClone(obj[key], cache) // 递归拷贝 } } return cloneObj } // 测试 const obj = { name: 'Jack', address: { x: 100, y: 200 } } obj.a = obj // 循环引用 const newObj = deepClone(obj) console.log(newObj.address === obj.address) // false 5、reverse 底层原理和扩展 // 改变原数组 Array.prototype.myReverse = function () { var len = this.length; for (var i = 0; i 6、圣杯模式的继承 function inherit(Target, Origin) { function F() {}; F.prototype = Origin.prototype; Target.prototype = new F(); Target.prototype.constructor = Target; // 最终的原型指向 Target.prop.uber = Origin.prototype; } 7、找出字符串中第一次只出现一次的字母 String.prototype.firstAppear = function () { var obj = {}, len = this.length; for (var i = 0; i 8、找元素的第 n 级父元素 function parents(ele, n) { while (ele && n) { ele = ele.parentElement ? ele.parentElement : ele.parentNode; n--; } return ele; } 9、 返回元素的第 n 个兄弟节点 function retSibling(e, n) { while (e && n) { if (n > 0) { if (e.nextElementSibling) { e = e.nextElementSibling; } else { for (e = e.nextSibling; e && e.nodeType !== 1; e = e.nextSibling); } n--; } else { if (e.previousElementSibling) { e = e.previousElementSibling; } else { for (e = e.previousElementSibling; e && e.nodeType !== 1; e = e.previousElementSibling); } n++; } } return e; } 10、封装 mychildren，解决浏览器的兼容问题 function myChildren(e) { var children = e.childNodes, arr = [], len = children.length; for (var i = 0; i 11、判断元素有没有子元素 function hasChildren(e) { var children = e.childNodes, len = children.length; for (var i = 0; i 12、我一个元素插入到另一个元素的后面 Element.prototype.insertAfter = function (target, elen) { var nextElen = elen.nextElenmentSibling; if (nextElen == null) { this.appendChild(target); } else { this.insertBefore(target, nextElen); } } 13、返回当前的时间（年月日时分秒） function getDateTime() { var date = new Date(), year = date.getFullYear(), month = date.getMonth() + 1, day = date.getDate(), hour = date.getHours() + 1, minute = date.getMinutes(), second = date.getSeconds(); month = checkTime(month); day = checkTime(day); hour = checkTime(hour); minute = checkTime(minute); second = checkTime(second); function checkTime(i) { if (i 14、获得滚动条的滚动距离 function getScrollOffset() { if (window.pageXOffset) { return { x: window.pageXOffset, y: window.pageYOffset } } else { return { x: document.body.scrollLeft + document.documentElement.scrollLeft, y: document.body.scrollTop + document.documentElement.scrollTop } } } 15、获得视口的尺寸 function getViewportOffset() { if (window.innerWidth) { return { w: window.innerWidth, h: window.innerHeight } } else { // ie8及其以下 if (document.compatMode === \"BackCompat\") { // 怪异模式 return { w: document.body.clientWidth, h: document.body.clientHeight } } else { // 标准模式 return { w: document.documentElement.clientWidth, h: document.documentElement.clientHeight } } } } 16、获取任一元素的任意属性 function getStyle(elem, prop) { return window.getComputedStyle ? window.getComputedStyle(elem, null)[prop] : elem.currentStyle[prop] } 17、绑定事件的兼容代码 function addEvent(elem, type, handle) { if (elem.addEventListener) { //非ie和非ie9 elem.addEventListener(type, handle, false); } else if (elem.attachEvent) { //ie6到ie8 elem.attachEvent('on' + type, function () { handle.call(elem); }) } else { elem['on' + type] = handle; } } 18、解绑事件 function removeEvent(elem, type, handle) { if (elem.removeEventListener) { //非ie和非ie9 elem.removeEventListener(type, handle, false); } else if (elem.detachEvent) { //ie6到ie8 elem.detachEvent('on' + type, handle); } else { elem['on' + type] = null; } } 19、取消冒泡的兼容代码 function stopBubble(e) { if (e && e.stopPropagation) { e.stopPropagation(); } else { window.event.cancelBubble = true; } } 20、检验字符串是否是回文 function isPalina(str) { if (Object.prototype.toString.call(str) !== '[object String]') { return false; } var len = str.length; for (var i = 0; i 21、检验字符串是否是回文 function isPalindrome(str) { str = str.replace(/\\W/g, '').toLowerCase(); console.log(str) return (str == str.split('').reverse().join('')) } 22、兼容 getElementsByClassName 方法 Element.prototype.getElementsByClassName = Document.prototype.getElementsByClassName = function (_className) { var allDomArray = document.getElementsByTagName('*'); var lastDomArray = []; function trimSpace(strClass) { var reg = /\\s+/g; return strClass.replace(reg, ' ').trim() } for (var i = 0; i 23、运动函数 function animate(obj, json, callback) { clearInterval(obj.timer); var speed, current; obj.timer = setInterval(function () { var lock = true; for (var prop in json) { if (prop == 'opacity') { current = parseFloat(window.getComputedStyle(obj, null)[prop]) * 100; } else { current = parseInt(window.getComputedStyle(obj, null)[prop]); } speed = (json[prop] - current) / 7; speed = speed > 0 ? Math.ceil(speed) : Math.floor(speed); if (prop == 'opacity') { obj.style[prop] = (current + speed) / 100; } else { obj.style[prop] = current + speed + 'px'; } if (current != json[prop]) { lock = false; } } if (lock) { clearInterval(obj.timer); typeof callback == 'function' ? callback() : ''; } }, 30) } 24、弹性运动 function ElasticMovement(obj, target) { clearInterval(obj.timer); var iSpeed = 40, a, u = 0.8; obj.timer = setInterval(function () { a = (target - obj.offsetLeft) / 8; iSpeed = iSpeed + a; iSpeed = iSpeed * u; if (Math.abs(iSpeed) 25、封装自己的 forEach 方法 Array.prototype.myForEach = function (func, obj) { var len = this.length; var _this = arguments[1] ? arguments[1] : window; // var _this=arguments[1]||window; for (var i = 0; i 26、封装自己的 filter 方法 Array.prototype.myFilter = function (func, obj) { var len = this.length; var arr = []; var _this = arguments[1] || window; for (var i = 0; i 27、数组 map 方法 Array.prototype.myMap = function (func) { var arr = []; var len = this.length; var _this = arguments[1] || window; for (var i = 0; i 28、数组 every 方法 Array.prototype.myEvery = function (func) { var flag = true; var len = this.length; var _this = arguments[1] || window; for (var i = 0; i 29、数组 reduce 方法 Array.prototype.myReduce = function (func, initialValue) { var len = this.length, nextValue, i; if (!initialValue) { // 没有传第二个参数 nextValue = this[0]; i = 1; } else { // 传了第二个参数 nextValue = initialValue; i = 0; } for (; i 30、获取 url 中的参数 function getWindonHref() { var sHref = window.location.href; var args = sHref.split('?'); if (args[0] === sHref) { return ''; } var hrefarr = args[1].split('#')[0].split('&'); var obj = {}; for (var i = 0; i { const key = item.split('=')[0] const val = item.split('=')[1] res[key] = decodeURIComponent(val) // 解码 }) } return res } // 定位某一个参数 const getUrlParam = function(name) { // 获取url参数 let reg = new RegExp('(^|&?)' + name + '=([^&]*)(&|$)', 'i') let r = window.location.href.substr(1).match(reg) if (r != null) { return decodeURI(r[2]) } return undefined } // 测试 const user = getParams('http://www.baidu.com?user=%E9%98%BF%E9%A3%9E&age=16') console.log(user) // { user: '阿飞', age: '16' } 31、数组排序 // 快排 [left] + min + [right] function quickArr(arr) { if (arr.length arr[j]) { var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } } return arr; } function bubbleSort(arr) { var len = arr.length; for (var i = 0; i arr[j + 1]) { var temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } return arr; } 32、遍历 Dom 树 // 给定页面上的DOM元素,将访问元素本身及其所有后代(不仅仅是它的直接子元素) // 对于每个访问的元素，函数讲元素传递给提供的回调函数 function traverse(element, callback) { callback(element); var list = element.children; for (var i = 0; i 33、原生 js 封装 ajax function ajax(method, url, callback, data, flag) { var xhr; flag = flag || true; method = method.toUpperCase(); if (window.XMLHttpRequest) { xhr = new XMLHttpRequest(); } else { xhr = new ActiveXObject('Microsoft.XMLHttp'); } xhr.onreadystatechange = function () { if (xhr.readyState == 4 && xhr.status == 200) { console.log(2) callback(xhr.responseText); } } if (method == 'GET') { var date = new Date(), timer = date.getTime(); xhr.open('GET', url + '?' + data + '&timer' + timer, flag); xhr.send() } else if (method == 'POST') { xhr.open('POST', url, flag); xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); xhr.send(data); } } const ajax = function(conf) { // ajax操作 let url = conf.url, data = conf.data, senData = [], // 封装后的数据 async = conf.async !== undefined ? conf.async : true, // ture为异步请求 type = conf.type || 'get', // 默认请求方式get dataType = conf.dataType || 'json', contenType = conf.contenType || 'application/x-www-form-urlencoded', success = conf.success, error = conf.error, isForm = conf.isForm || false, // 是否formdata header = conf.header || {}, // 头部信息 xhr = '' // 创建ajax引擎对象 if (data == null) { senData = '' } else if (typeof data === 'object' && !isForm) { // 如果data是对象，转换为字符串 for (var k in data) { senData.push(encodeURIComponent(k) + '=' + encodeURIComponent(data[k])) } senData = senData.join('&') } else { senData = data } try { xhr = new ActiveXObject('microsoft.xmlhttp') // IE内核系列浏览器 } catch (e1) { try { xhr = new XMLHttpRequest() // 非IE内核浏览器 } catch (e2) { if (error != null) { error('不支持ajax请求') } } }; xhr.open(type, type !== 'get' ? url : url + '?' + senData, async) if (type !== 'get' && !isForm) { xhr.setRequestHeader('content-type', contenType) } for (var h in header) { xhr.setRequestHeader(h, header[h]) } xhr.send(type !== 'get' ? senData : null) xhr.onreadystatechange = function() { if (xhr.readyState === 4) { if (xhr.status >= 200 && xhr.status 34、异步加载 script function loadScript(url, callback) { var oscript = document.createElement('script'); if (oscript.readyState) { // ie8及以下版本 oscript.onreadystatechange = function () { if (oscript.readyState === 'complete' || oscript.readyState === 'loaded') { callback(); } } } else { oscript.onload = function () { callback() }; } oscript.src = url; document.body.appendChild(oscript); } 35、cookie 管理 var cookie = { set: function (name, value, time) { document.cookie = name + '=' + value + '; max-age=' + time; return this; }, remove: function (name) { return this.setCookie(name, '', -1); }, get: function (name, callback) { var allCookieArr = document.cookie.split('; '); for (var i = 0; i 36、实现 bind() 方法 Function.prototype.myBind = function (target) { var target = target || window; var _args1 = [].slice.call(arguments, 1); var self = this; var temp = function () {}; var F = function () { var _args2 = [].slice.call(arguments, 0); var parasArr = _args1.concat(_args2); return self.apply(this instanceof temp ? this : target, parasArr) } temp.prototype = self.prototype; F.prototype = new temp(); return F; } 37、实现 call() 方法 Function.prototype.myCall = function () { var ctx = arguments[0] || window; ctx.fn = this; var args = []; for (var i = 1; i 38、实现 apply() 方法 Function.prototype.myApply = function () { var ctx = arguments[0] || window; ctx.fn = this; if (!arguments[1]) { var result = ctx.fn(); delete ctx.fn; return result; } var result = ctx.fn(...arguments[1]); delete ctx.fn; return result; } 39、防抖 function debounce(handle, delay) { var timer = null; return function () { var _self = this, _args = arguments; clearTimeout(timer); timer = setTimeout(function () { handle.apply(_self, _args) }, delay) } } 40、节流 function throttle(handler, wait) { var lastTime = 0; return function (e) { var nowTime = new Date().getTime(); if (nowTime - lastTime > wait) { handler.apply(this, arguments); lastTime = nowTime; } } } 41、requestAnimFrame 兼容性方法 window.requestAnimFrame = (function () { return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (callback) { window.setTimeout(callback, 1000 / 60); }; })(); 42、cancelAnimFrame 兼容性方法 window.cancelAnimFrame = (function () { return window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function (id) { window.clearTimeout(id); }; })(); 43、jsonp 底层方法 function jsonp(url, callback) { var oscript = document.createElement('script'); if (oscript.readyState) { // ie8及以下版本 oscript.onreadystatechange = function () { if (oscript.readyState === 'complete' || oscript.readyState === 'loaded') { callback(); } } } else { oscript.onload = function () { callback() }; } oscript.src = url; document.body.appendChild(oscript); } 44、获取 url 上的参数 function getUrlParam(sUrl, sKey) { var result = {}; sUrl.replace(/(\\w+)=(\\w+)(?=[&|#])/g, function (ele, key, val) { if (!result[key]) { result[key] = val; } else { var temp = result[key]; result[key] = [].concat(temp, val); } }) if (!sKey) { return result; } else { return result[sKey] || ''; } } const getParameters = (URL) => { URL = JSON.parse('{\"' + decodeURI(URL.split(\"?\")[1]).replace(/\"/g, '\\\"').replace(/&/g, '\",\"').replace( /=/g, '\":\"') + '\"}'); return JSON.stringify(URL); }; 45、格式化时间 function formatDate(t, str) { var obj = { yyyy: t.getFullYear(), yy: (\"\" + t.getFullYear()).slice(-2), M: t.getMonth() + 1, MM: (\"0\" + (t.getMonth() + 1)).slice(-2), d: t.getDate(), dd: (\"0\" + t.getDate()).slice(-2), H: t.getHours(), HH: (\"0\" + t.getHours()).slice(-2), h: t.getHours() % 12, hh: (\"0\" + t.getHours() % 12).slice(-2), m: t.getMinutes(), mm: (\"0\" + t.getMinutes()).slice(-2), s: t.getSeconds(), ss: (\"0\" + t.getSeconds()).slice(-2), w: ['日', '一', '二', '三', '四', '五', '六'][t.getDay()] }; return str.replace(/([a-z]+)/ig, function ($1) { return obj[$1] }); } 46、验证邮箱的正则表达式 function isAvailableEmail(sEmail) { var reg = /^([\\w+\\.])+@\\w+([.]\\w+)+$/ return reg.test(sEmail) } 47、函数柯里化 //是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术 function curryIt(fn) { var length = fn.length, args = []; var result = function (arg) { args.push(arg); length--; if (length 48、大数相加 function sumBigNumber(a, b) { var res = '', //结果 temp = 0; //按位加的结果及进位 a = a.split(''); b = b.split(''); while (a.length || b.length || temp) { //~~按位非 1.类型转换，转换成数字 2.~~undefined==0 temp += ~~a.pop() + ~~b.pop(); res = (temp % 10) + res; temp = temp > 9; } return res.replace(/^0+/, ''); } 49、单例模式 function getSingle(func) { var result; return function () { if (!result) { result = new func(arguments); } return result; } } 50、实现promise class MyPromise { constructor(executor) { // executor执行器 this.status = 'pending' // 等待状态 this.value = null // 成功或失败的参数 this.fulfilledCallbacks = [] // 成功的函数队列 this.rejectedCallbacks = [] // 失败的函数队列 const that = this function resolve(value) { // 成功的方法 if (that.status === 'pending') { that.status = 'resolved' that.value = value that.fulfilledCallbacks.forEach(myFn => myFn(that.value)) //执行回调方法 } } function reject(value) { //失败的方法 if (that.status === 'pending') { that.status = 'rejected' that.value = value that.rejectedCallbacks.forEach(myFn => myFn(that.value)) //执行回调方法 } } try { executor(resolve, reject) } catch (err) { reject(err) } } then(onFulfilled, onRejected) { if (this.status === 'pending') { // 等待状态，添加回调函数到成功的函数队列 this.fulfilledCallbacks.push(() => { onFulfilled(this.value) }) // 等待状态，添加回调函数到失败的函数队列 this.rejectedCallbacks.push(() => { onRejected(this.value) }) } if (this.status === 'resolved') { // 支持同步调用 console.log('this', this) onFulfilled(this.value) } if (this.status === 'rejected') { // 支持同步调用 onRejected(this.value) } } } 51、组合继承 function Parent(name) { this.name = name } Parent.prototype.eat = function () { console.log(this.name + ' is eating') } function Child(name, age) { Parent.call(this, name) // 构造函数继承 this.age = age } Child.prototype = new Parent() // 原型链继承 Child.prototype.contructor = Child Child.prototype.study = function () { console.log(this.name + ' is studying') } // 测试 let child = new Child('xiaoming', 16) console.log(child.name) // xiaoming child.eat() // xiaoming is eating child.study() // xiaoming is studying 52、事件总线｜发布订阅模式 class EventEmitter { constructor() { this.cache = {} } on(name, fn) { if (this.cache[name]) { this.cache[name].push(fn) } else { this.cache[name] = [fn] } } off(name, fn) { const tasks = this.cache[name] if (tasks) { const index = tasks.findIndex((f) => f === fn || f.callback === fn) if (index >= 0) { tasks.splice(index, 1) } } } emit(name, once = false) { if (this.cache[name]) { // 创建副本，如果回调函数内继续注册相同事件，会造成死循环 const tasks = this.cache[name].slice() for (let fn of tasks) { fn(); } if (once) { delete this.cache[name] } } } } // 测试 const eventBus = new EventEmitter() const task1 = () => { console.log('task1'); } const task2 = () => { console.log('task2'); } eventBus.on('task', task1) eventBus.on('task', task2) eventBus.off('task', task1) setTimeout(() => { eventBus.emit('task') // task2 }, 1000) 53、复制剪切板 const copyToClipboard = (text) => navigator.clipboard.writeText(text); 54、检查日期是否有效 const isDateValid = (...val) => !Number.isNaN(new Date(...val).valueOf()); 55、找出一年中的哪一天 const dayOfYear = (date) => Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 1000 / 60 / 60 / 24); 56、字符串 大小写 //首字母大写 const capitalize = str => str.charAt(0).toUpperCase() + str.slice(1) capitalize(\"follow for more\") const changeCase = function(str, type) { // 字符串大小写转换 type: 1:首字母大写 2：首页母小写 3：大小写转换 4：全部大写 5：全部小写 type = type || 4 switch (type) { case 1: return str.replace(/\\b\\w+\\b/g, function(word) { return word.substring(0, 1).toUpperCase() + word.substring(1).toLowerCase() }) case 2: return str.replace(/\\b\\w+\\b/g, function(word) { return word.substring(0, 1).toLowerCase() + word.substring(1).toUpperCase() }) case 3: return str.split('').map(function(word) { if (/[a-z]/.test(word)) { return word.toUpperCase() } else { return word.toLowerCase() } }).join('') case 4: return str.toUpperCase() case 5: return str.toLowerCase() default: return str } } 57、两日期之间的天数 const dayDif = (date1, date2) => Math.ceil(Math.abs(date1.getTime() - date2.getTime()) / 86400000)dayDif(new Date(\"2020-10-21\"), new Date(\"2021-10-22\")) 58、清除所有 Cookie const clearCookies = document.cookie.split(';').forEach(cookie => document.cookie = cookie.replace(/^ +/, '') .replace(/=.*/, `=;expires=${new Date(0).toUTCString()}; path=/`)); 59、随机16进制 const randomHex = () => `#${Math.floor(Math.random() * 0xffffff).toString(16).padEnd(6, \"0\")}` 60、选定文本 const getSelectedText = () => window.getSelection().toString(); 61、外部加载js｜css｜风格 const loadRes = function(name, type, fn) { // 加载js || css || style let ref if (type === 'js') { // 外部js ref = document.createElement('script') ref.setAttribute('type', 'text/JavaScript') ref.setAttribute('src', name) } else if (type === 'css') { // 外部css ref = document.createElement('link') ref.setAttribute('rel', 'stylesheet') ref.setAttribute('type', 'text/css') ref.setAttribute('href', name) } else if (type === 'style') { // style ref = document.createElement('style') ref.innerhtml = name } if (typeof ref !== 'undefined') { document.getElementsByTagName('head')[0].appendChild(ref) ref.onload = function() { // 加载完成执行 typeof fn === 'function' && fn() } } } 62、 存储(缓存) const store = { // 本地存储 set: function(name, value, day) { // 设置 let d = new Date() let time = 0 day = (typeof(day) === 'undefined' || !day) ? 1 : day // 时间,默认存储1天 time = d.setHours(d.getHours() + (24 * day)) // 毫秒 localStorage.setItem(name, JSON.stringify({ data: value, time: time })) }, get: function(name) { // 获取 let data = localStorage.getItem(name) if (!data) { return null } let obj = JSON.parse(data) if (new Date().getTime() > obj.time) { // 过期 localStorage.removeItem(name) return null } else { return obj.data } }, clear: function(name) { // 清空 if (name) { // 删除键为name的缓存 localStorage.removeItem(name) } else { // 清空全部 localStorage.clear() } } } 63、 JS获取元素样式 const getRealStyle = function(obj, styleName) { // Js获取元素样式【支持内联】 var realStyle = null if (obj.currentStyle) { realStyle = obj.currentStyle[styleName] } else if (window.getComputedStyle) { realStyle = window.getComputedStyle(obj, null)[styleName] } return realStyle } 64、 时间格式化 const formatDate = function(fmt, date) { // 时间格式化 【'yyyy-MM-dd hh:mm:ss',时间】 if (typeof date !== 'object') { date = !date ? new Date() : new Date(date) } var o = { 'M+': date.getMonth() + 1, // 月份 'd+': date.getDate(), // 日 'h+': date.getHours(), // 小时 'm+': date.getMinutes(), // 分 's+': date.getSeconds(), // 秒 'q+': Math.floor((date.getMonth() + 3) / 3), // 季度 'S': date.getMilliseconds() // 毫秒 } if (/(y+)/.test(fmt)) { fmt = fmt.replace(RegExp.$1, (date.getFullYear() + '').substr(4 - RegExp.$1.length)) } for (var k in o) { if (new RegExp('(' + k + ')').test(fmt)) { fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1) ? (o[k]) : (('00' + o[k]).substr(('' + o[k]).length))) } } return fmt } 65、 fetch 请求封装 const fetch = function(url, setting) { // fetch请求的封装 let opts = { // 设置参数的初始值 method: (setting.method || 'GET').toUpperCase(), // 请求方式 headers: setting.headers || {}, // 请求头设置 credentials: setting.credentials || true, // 设置cookie是否一起发送 body: setting.body || {}, mode: setting.mode || 'no-cors', // 可以设置 cors, no-cors, same-origin redirect: setting.redirect || 'follow', // follow, error, manual cache: setting.cache || 'default' // 设置 cache 模式 (default, reload, no-cache) } let dataType = setting.dataType || 'json' // 解析方式 let data = setting.data || '' // 参数 let paramsFormat = function(obj) { // 参数格式 var str = '' for (var i in obj) { str += `${i}=${obj[i]}&` } return str.split('').slice(0, -1).join('') } if (opts.method === 'GET') { url = url + (data ? `?${paramsFormat(data)}` : '') } else { setting.body = data || {} } return new Promise((resolve, reject) => { fetch(url, opts).then(async res => { let data = dataType === 'text' ? await res.text() : dataType === 'blob' ? await res.blob() : await res.json() resolve(data) }).catch(e => { reject(e) }) }) } 66、判断设备（ios, android, web） const isDevice = function() { // 判断是android还是ios还是web var ua = navigator.userAgent.toLowerCase() if (ua.match(/iPhone\\sOS/i) === 'iphone os' || ua.match(/iPad/i) === 'ipad') { // ios return 'iOS' } if (ua.match(/Android/i) === 'android') { return 'Android' } return 'Web' } 67、判断是否为微信 const isWx = function() { // 判断是否为微信 var ua = window.navigator.userAgent.toLowerCase() if (ua.match(/MicroMessenger/i) === 'micromessenger') { return true } return false } 68、文本复制 const copyTxt = function(text, fn) { // 复制功能 if (typeof document.execCommand !== 'function') { console.log('复制失败，请长按复制') return } var dom = document.createElement('textarea') dom.value = text dom.setAttribute('style', 'display: block;width: 1px;height: 1px;') document.body.appendChild(dom) dom.select() var result = document.execCommand('copy') document.body.removeChild(dom) if (result) { console.log('复制成功') typeof fn === 'function' && fn() return } if (typeof document.createRange !== 'function') { console.log('复制失败，请长按复制') return } var range = document.createRange() var div = document.createElement('div') div.innerhtml = text div.setAttribute('style', 'height: 1px;fontSize: 1px;overflow: hidden;') document.body.appendChild(div) range.selectNode(div) var selection = window.getSelection() console.log(selection) if (selection.rangeCount > 0) { selection.removeAllRanges() } selection.addRange(range) document.execCommand('copy') typeof fn === 'function' && fn() console.log('复制成功') } 69、判断是否是数组 const isArray = function(arr) { // 判断是否是一个数组 return Object.prototype.toString.call(arr) === '[object Array]' } 70、判断两个数组是否相等 const arrayEqual = function(arr1, arr2) { //判断两个数组是否相等 if (arr1 === arr2) return true; if (arr1.length != arr2.length) return false; for (let i = 0; i 71、时间转换 (有问题) const stamp = { // 时间，时间戳转换 getTime: function(time) { // 时间转10位时间戳 let date = time ? new Date(time) : new Date() return Math.round(date.getTime() / 1000) }, timeToStr: function(time, fmt) { // 10位时间戳转时间 return new Date(time * 1000).pattern(fmt || 'yyyy-MM-dd') } } 72、是否PC端 const isPC = function() { // 是否为PC端 let userAgentInfo = navigator.userAgent let Agents = ['Android', 'iPhone', 'SymbianOS', 'Windows Phone', 'iPad', 'iPod'] let flag = true for (let v = 0; v 0) { flag = false break } } return flag } 73、去掉空格 const trim = function(str, type) { // 去除空格， type: 1-所有空格 2-前后空格 3-前空格 4-后空格 type = type || 1 switch (type) { case 1: return str.replace(/\\s+/g, '') case 2: return str.replace(/(^\\s*)|(\\s*$)/g, '') case 3: return str.replace(/(^\\s*)/g, '') case 4: return str.replace(/(\\s*$)/g, '') default: return str } } 74、HTML过滤 const filterTag = function(str) { // 过滤html代码(把<>转换) str = str.replace(/&/ig, '&') str = str.replace(//ig, '>') str = str.replace(' ', ' ') return str } 75、生成随机数范围 const random = function(min, max) { // 生成随机数范围 if (arguments.length === 2) { return Math.floor(min + Math.random() * ((max + 1) - min)) } else { return null } } const random = (min=10,max=null)=>{ return max? Math.floor(max - min)+min:Math.floor(min) } 76、数字转中文大写 const numberToChinese = function(num) { // 将阿拉伯数字翻译成中文的大写数字 let AA = new Array('零', '一', '二', '三', '四', '五', '六', '七', '八', '九', '十') let BB = new Array('', '十', '百', '仟', '萬', '億', '点', '') let a = ('' + num).replace(/(^0*)/g, '').split('.') let k = 0 let re = '' for (let i = a[0].length - 1; i >= 0; i--) { switch (k) { case 0: re = BB[7] + re break case 4: if (!new RegExp('0{4}//d{' + (a[0].length - i - 1) + '}$').test(a[0])) { re = BB[4] + re } break case 8: re = BB[5] + re BB[7] = BB[5] k = 0 break } if (k % 4 === 2 && a[0].charAt(i + 2) !== 0 && a[0].charAt(i + 1) === 0) { re = AA[0] + re } if (a[0].charAt(i) !== 0) { re = AA[a[0].charAt(i)] + BB[k % 4] + re } k++ } if (a.length > 1) { // 加上小数部分(如果有小数部分) re += BB[6] for (let i = 0; i 77、原生事件操作 const dom = { $: function(selector) { let type = selector.substring(0, 1) if (type === '#') { if (document.querySelecotor) return document.querySelector(selector) return document.getElementById(selector.substring(1)) } else if (type === '.') { if (document.querySelecotorAll) return document.querySelectorAll(selector) return document.getElementsByClassName(selector.substring(1)) } else { return document['querySelectorAll' ? 'querySelectorAll' : 'getElementsByTagName'](selector) } }, hasClass: function(ele, name) { /* 检测类名 */ return ele.className.match(new RegExp('(\\\\s|^)' + name + '(\\\\s|$)')) }, addClass: function(ele, name) { /* 添加类名 */ if (!this.hasClass(ele, name)) ele.className += ' ' + name }, removeClass: function(ele, name) { /* 删除类名 */ if (this.hasClass(ele, name)) { let reg = new RegExp('(\\\\s|^)' + name + '(\\\\s|$)') ele.className = ele.className.replace(reg, '') } }, replaceClass: function(ele, newName, oldName) { /* 替换类名 */ this.removeClass(ele, oldName) this.addClass(ele, newName) }, siblings: function(ele) { /* 获取兄弟节点 */ console.log(ele.parentNode) let chid = ele.parentNode.children, eleMatch = [] for (let i = 0, len = chid.length; i 78、图片加载完成 const imgLoadAll = function(arr, callback) { // 图片加载 let arrImg = [] for (let i = 0; i 79、音频加载完成操作 const loadAudio = function(src, callback) { // 音频加载 var audio = new Audio(src) audio.onloadedmetadata = callback audio.src = src } 80、不同位置字符字符 const insertAtCursor = function(dom, val) { // 光标所在位置插入字符 if (document.selection) { dom.focus() let sel = document.selection.createRange() sel.text = val sel.select() } else if (dom.selectionStart || dom.selectionStart == '0') { let startPos = dom.selectionStart let endPos = dom.selectionEnd let restoreTop = dom.scrollTop dom.value = dom.value.substring(0, startPos) + val + dom.value.substring(endPos, dom.value.length) if (restoreTop > 0) { dom.scrollTop = restoreTop } dom.focus() dom.selectionStart = startPos + val.length dom.selectionEnd = startPos + val.length } else { dom.value += val dom.focus() } } 81、图片地址转换base64 const getBase64 = function(img) { //传入图片路径，返回base64，使用getBase64(url).then(function(base64){},function(err){}); let getBase64Image = function(img, width, height) { //width、height调用时传入具体像素值，控制大小,不传则默认图像大小 let canvas = document.createElement(\"canvas\"); canvas.width = width ? width : img.width; canvas.height = height ? height : img.height; let ctx = canvas.getContext(\"2d\"); ctx.drawImage(img, 0, 0, canvas.width, canvas.height); let dataURL = canvas.toDataURL(); return dataURL; } let image = new Image(); image.crossOrigin = ''; image.src = img; return new Promise((resolve, reject)=>{ if(img) { image.onload = function() { resolve(getBase64Image(image)); } resolve('') } }) } 82、 base64 图片下载 const downloadFile = function(base64, fileName) { //base64图片下载功能 let base64ToBlob = function(code) { let parts = code.split(';base64,'); let contentType = parts[0].split(':')[1]; let raw = window.atob(parts[1]); let rawLength = raw.length; let uInt8Array = new Uint8Array(rawLength); for (let i = 0; i 83、浏览器是否支持webp const isSupportWebP = function() { //判断浏览器是否支持webP格式图片 return !![].map && document.createElement('canvas').toDataURL('image/webp').indexOf('data:image/webp') == 0; } 84、H5键盘缩回，弹起 const h5Resize = function(downCb, upCb) { //当软件键盘弹起会改变当前 window.innerHeight，监听这个值变化 [downCb 当软键盘弹起后，缩回的回调,upCb 当软键盘弹起的回调] var clientHeight = window.innerHeight; downCb = typeof downCb === 'function' ? downCb : function() {} upCb = typeof upCb === 'function' ? upCb : function() {} window.addEventListener('resize', () => { var height = window.innerHeight; if (height === clientHeight) { downCb(); } if (height Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-22 16:41:52 "},"前端杂项/数组去重.html":{"url":"前端杂项/数组去重.html","title":"数组去重","keywords":"","body":"数组去重的方法 一、利用ES6 Set去重（ES6中最常用） function unique (arr) { return Array.from(new Set(arr)) } var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}]; console.log(unique(arr)) //[1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", {}, {}] 不考虑兼容性，这种去重的方法代码最少。这种方法还无法去掉“{}”空对象，后面的高阶方法会添加去掉重复“{}”的方法。 二、利用for嵌套for，然后splice去重（ES5中最常用） function unique(arr){ for(var i=0; i双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值。想快速学习更多常用的ES6语法，可以看我之前的文章《学习ES6笔记──工作中常用到的ES6语法》。 三、利用indexOf去重 function unique(arr) { if (!Array.isArray(arr)) { console.log('type error!') return } var array = []; for (var i = 0; i 新建一个空的结果数组，for 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则push进数组。 四、利用sort() function unique(arr) { if (!Array.isArray(arr)) { console.log('type error!') return; } arr = arr.sort() var arrry= [arr[0]]; for (var i = 1; i 利用sort()排序方法，然后根据排序后的结果进行遍历及相邻元素比对。 五、利用对象的属性不能相同的特点进行去重（这种数组去重的方法有问题，不建议用，有待改进） function unique(arr) { if (!Array.isArray(arr)) { console.log('type error!') return } var arrry= []; var obj = {}; for (var i = 0; i 六、利用includes function unique(arr) { if (!Array.isArray(arr)) { console.log('type error!') return } var array =[]; for(var i = 0; i 七、利用hasOwnProperty function unique(arr) { var obj = {}; return arr.filter(function(item, index, arr){ return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true) }) } var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}]; console.log(unique(arr)) //[1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", {…}] //所有的都去重了 利用hasOwnProperty 判断是否存在对象属性 八、利用filter function unique(arr) { return arr.filter(function(item, index, arr) { //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素 return arr.indexOf(item, 0) === index; }); } var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}]; console.log(unique(arr)) //[1, \"true\", true, 15, false, undefined, null, \"NaN\", 0, \"a\", {…}, {…}] 九、利用递归去重 function unique(arr) { var array= arr; var len = array.length; array.sort(function(a,b){ //排序后更加方便去重 return a - b; }) function loop(index){ if(index >= 1){ if(array[index] === array[index-1]){ array.splice(index,1); } loop(index - 1); //递归loop，然后数组去重 } } loop(len-1); return array; } var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}]; console.log(unique(arr)) //[1, \"a\", \"true\", true, 15, false, 1, {…}, null, NaN, NaN, \"NaN\", 0, \"a\", {…}, undefined] 十、利用Map数据结构去重 function arrayNonRepeatfy(arr) { let map = new Map(); let array = new Array(); // 数组用于返回结果 for (let i = 0; i 创建一个空Map数据结构，遍历需要去重的数组，把数组的每一个元素作为key存到Map中。由于Map中不会出现相同的key值，所以最终得到的就是去重后的结果。 十一、利用reduce+includes function unique(arr){ return arr.reduce((prev,cur) => prev.includes(cur) ? prev : [...prev,cur],[]); } var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}]; console.log(unique(arr)); // [1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", {…}, {…}] 十二、[...new Set(arr)] [...new Set(arr)] //代码就是这么少----（其实，严格来说并不算是一种，相对于第一种方法来说只是简化了代码） PS：有些文章提到了foreach+indexOf数组去重的方法，个人觉得都是大同小异，所以没有写上去。 Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-22 16:43:09 "},"前端杂项/前端性能优化.html":{"url":"前端杂项/前端性能优化.html","title":"前端性能优化","keywords":"","body":" 本文由 简悦 SimpRead 转码， 原文地址 mp.weixin.qq.com 性能优化是把双刃剑，有好的一面也有坏的一面。好的一面就是能提升网站性能，坏的一面就是配置麻烦，或者要遵守的规则太多。并且某些性能优化规则并不适用所有场景，需要谨慎使用，请读者带着批判性的眼光来阅读本文。 1. 减少 HTTP 请求 一个完整的 HTTP 请求需要经历 DNS 查找，TCP 握手，浏览器发出 HTTP 请求，服务器接收请求，服务器处理请求并发回响应，浏览器接收响应等过程。接下来看一个具体的例子帮助理解 HTTP ： 这是一个 HTTP 请求，请求的文件大小为 28.4KB。 名词解释： Queueing: 在请求队列中的时间。 Stalled: 从TCP 连接建立完成，到真正可以传输数据之间的时间差，此时间包括代理协商时间。 Proxy negotiation: 与代理服务器连接进行协商所花费的时间。 DNS Lookup: 执行DNS查找所花费的时间，页面上的每个不同的域都需要进行DNS查找。 Initial Connection / Connecting: 建立连接所花费的时间，包括TCP握手/重试和协商SSL。 SSL: 完成SSL握手所花费的时间。 Request sent: 发出网络请求所花费的时间，通常为一毫秒的时间。 Waiting(TFFB): TFFB 是发出页面请求到接收到应答数据第一个字节的时间。 Content Download: 接收响应数据所花费的时间。 从这个例子可以看出，真正下载数据的时间占比为 13.05 / 204.16 = 6.39%，文件越小，这个比例越小，文件越大，比例就越高。这就是为什么要建议将多个小文件合并为一个大文件，从而减少 HTTP 请求次数的原因。 2. 使用 HTTP2 HTTP2 相比 HTTP1.1 有如下几个优点： 解析速度快 服务器解析 HTTP1.1 的请求时，必须不断地读入字节，直到遇到分隔符 CRLF 为止。而解析 HTTP2 的请求就不用这么麻烦，因为 HTTP2 是基于帧的协议，每个帧都有表示帧长度的字段。 多路复用 HTTP1.1 如果要同时发起多个请求，就得建立多个 TCP 连接，因为一个 TCP 连接同时只能处理一个 HTTP1.1 的请求。 在 HTTP2 上，多个请求可以共用一个 TCP 连接，这称为多路复用。同一个请求和响应用一个流来表示，并有唯一的流 ID 来标识。多个请求和响应在 TCP 连接中可以乱序发送，到达目的地后再通过流 ID 重新组建。 首部压缩 HTTP2 提供了首部压缩功能。 例如有如下两个请求： :authority: unpkg.zhimg.com :method: GET :path: /za-js-sdk@2.16.0/dist/zap.js :scheme: https accept: */* accept-encoding: gzip, deflate, br accept-language: zh-CN,zh;q=0.9 cache-control: no-cache pragma: no-cache referer: https://www.zhihu.com/ sec-fetch-dest: script sec-fetch-mode: no-cors sec-fetch-site: cross-site user-agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36 :authority: zz.bdstatic.com :method: GET :path: /linksubmit/push.js :scheme: https accept: */* accept-encoding: gzip, deflate, br accept-language: zh-CN,zh;q=0.9 cache-control: no-cache pragma: no-cache referer: https://www.zhihu.com/ sec-fetch-dest: script sec-fetch-mode: no-cors sec-fetch-site: cross-site user-agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36 从上面两个请求可以看出来，有很多数据都是重复的。如果可以把相同的首部存储起来，仅发送它们之间不同的部分，就可以节省不少的流量，加快请求的时间。 HTTP/2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送。 下面再来看一个简化的例子，假设客户端按顺序发送如下请求首部： Header1:foo Header2:bar Header3:bat 当客户端发送请求时，它会根据首部值创建一张表： 索引首部名称值62Header1foo63Header2bar64Header3bat 如果服务器收到了请求，它会照样创建一张表。当客户端发送下一个请求的时候，如果首部相同，它可以直接发送这样的首部块： 62 63 64 服务器会查找先前建立的表格，并把这些数字还原成索引对应的完整首部。 优先级 HTTP2 可以对比较紧急的请求设置一个较高的优先级，服务器在收到这样的请求后，可以优先处理。 流量控制 由于一个 TCP 连接流量带宽（根据客户端到服务器的网络带宽而定）是固定的，当有多个请求并发时，一个请求占的流量多，另一个请求占的流量就会少。流量控制可以对不同的流的流量进行精确控制。 服务器推送 HTTP2 新增的一个强大的新功能，就是服务器可以对一个客户端请求发送多个响应。换句话说，除了对最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确地请求。 例如当浏览器请求一个网站时，除了返回 HTML 页面外，服务器还可以根据 HTML 页面中的资源的 URL，来提前推送资源。 现在有很多网站已经开始使用 HTTP2 了，例如知乎： 其中 h2 是指 HTTP2 协议，http/1.1 则是指 HTTP1.1 协议。 3. 使用服务端渲染 客户端渲染: 获取 HTML 文件，根据需要下载 JavaScript 文件，运行文件，生成 DOM，再渲染。 服务端渲染：服务端返回 HTML 文件，客户端只需解析 HTML。 优点：首屏渲染快，SEO 好。 缺点：配置麻烦，增加了服务器的计算压力。 下面我用 Vue SSR 做示例，简单的描述一下 SSR 过程。 客户端渲染过程 访问客户端渲染的网站。 服务器返回一个包含了引入资源语句和 的 HTML 文件。 客户端通过 HTTP 向服务器请求资源，当必要的资源都加载完毕后，执行 new Vue() 开始实例化并渲染页面。 服务端渲染过程 访问服务端渲染的网站。 服务器会查看当前路由组件需要哪些资源文件，然后将这些文件的内容填充到 HTML 文件。如果有 ajax 请求，就会执行它进行数据预取并填充到 HTML 文件里，最后返回这个 HTML 页面。 当客户端接收到这个 HTML 页面时，可以马上就开始渲染页面。与此同时，页面也会加载资源，当必要的资源都加载完毕后，开始执行 new Vue() 开始实例化并接管页面。 从上述两个过程中可以看出，区别就在于第二步。客户端渲染的网站会直接返回 HTML 文件，而服务端渲染的网站则会渲染完页面再返回这个 HTML 文件。 这样做的好处是什么？是更快的内容到达时间 (time-to-content)。 假设你的网站需要加载完 abcd 四个文件才能渲染完毕。并且每个文件大小为 1 M。 这样一算：客户端渲染的网站需要加载 4 个文件和 HTML 文件才能完成首页渲染，总计大小为 4M（忽略 HTML 文件大小）。而服务端渲染的网站只需要加载一个渲染完毕的 HTML 文件就能完成首页渲染，总计大小为已经渲染完毕的 HTML 文件（这种文件不会太大，一般为几百K，我的个人博客网站（SSR）加载的 HTML 文件为 400K）。这就是服务端渲染更快的原因。 4. 静态资源使用 CDN 内容分发网络（CDN）是一组分布在多个不同地理位置的 Web 服务器。我们都知道，当服务器离用户越远时，延迟越高。CDN 就是为了解决这一问题，在多个位置部署服务器，让用户离服务器更近，从而缩短请求时间。 CDN 原理 当用户访问一个网站时，如果没有 CDN，过程是这样的： 浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。 本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到网站服务器的 IP 地址。 本地 DNS 将 IP 地址发回给浏览器，浏览器向网站服务器 IP 地址发出请求并得到资源。 如果用户访问的网站部署了 CDN，过程是这样的： 浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。 本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到全局负载均衡系统（GSLB）的 IP 地址。 本地 DNS 再向 GSLB 发出请求，GSLB 的主要功能是根据本地 DNS 的 IP 地址判断用户的位置，筛选出距离用户较近的本地负载均衡系统（SLB），并将该 SLB 的 IP 地址作为结果返回给本地 DNS。 本地 DNS 将 SLB 的 IP 地址发回给浏览器，浏览器向 SLB 发出请求。 SLB 根据浏览器请求的资源和地址，选出最优的缓存服务器发回给浏览器。 浏览器再根据 SLB 发回的地址重定向到缓存服务器。 如果缓存服务器有浏览器需要的资源，就将资源发回给浏览器。如果没有，就向源服务器请求资源，再发给浏览器并缓存在本地。 将 CSS 放在文件头部，JavaScript 文件放在底部 所有放在 head 标签里的 CSS 和 JS 文件都会堵塞渲染（CSS 不会阻塞 DOM 解析）。如果这些 CSS 和 JS 需要加载和解析很久的话，那么页面就空白了。所以 JS 文件要放在底部，等 HTML 解析完了再加载 JS 文件。 那为什么 CSS 文件还要放在头部呢？ 因为先加载 HTML 再加载 CSS，会让用户第一时间看到的页面是没有样式的、“丑陋”的，为了避免这种情况发生，就要将 CSS 文件放在头部了。 另外，JS 文件也不是不可以放在头部，只要给 script 标签加上 defer 属性就可以了，异步下载，延迟执行。 6. 使用字体图标 iconfont 代替图片图标 字体图标就是将图标制作成一个字体，使用时就跟字体一样，可以设置属性，例如 font-size、color 等等，非常方便。并且字体图标是矢量图，不会失真。还有一个优点是生成的文件特别小。 压缩字体文件 使用 fontmin-webpack 插件对字体文件进行压缩。 善用缓存，不重复加载相同的资源 为了避免用户每次访问网站都得请求文件，我们可以通过添加 Expires 或 max-age 来控制这一行为。Expires 设置了一个时间，只要在这个时间之前，浏览器都不会请求文件，而是直接使用缓存。而 max-age 是一个相对时间，建议使用 max-age 代替 Expires 。 不过这样会产生一个问题，当文件更新了怎么办？怎么通知浏览器重新请求文件？ 可以通过更新页面中引用的资源链接地址，让浏览器主动放弃缓存，加载新资源。 具体做法是把资源地址 URL 的修改与文件内容关联起来，也就是说，只有文件内容变化，才会导致相应 URL 的变更，从而实现文件级别的精确缓存控制。什么东西与文件内容相关呢？我们会很自然的联想到利用数据摘要要算法对文件求摘要信息，摘要信息与文件内容一一对应，就有了一种可以精确到单个文件粒度的缓存控制依据了。 压缩文件 压缩文件可以减少文件下载时间，让用户体验性更好。 得益于 webpack 和 node 的发展，现在压缩文件已经非常方便了。 在 webpack 可以使用如下插件进行压缩： JavaScript：UglifyPlugin CSS ：MiniCssExtractPlugin HTML：HtmlWebpackPlugin 其实，我们还可以做得更好。那就是使用 gzip 压缩。可以通过向 HTTP 请求头中的 Accept-Encoding 头添加 gzip 标识来开启这一功能。当然，服务器也得支持这一功能。 gzip 是目前最流行和最有效的压缩方法。举个例子，我用 Vue 开发的项目构建后生成的 app.js 文件大小为 1.4MB，使用 gzip 压缩后只有 573KB，体积减少了将近 60%。 附上 webpack 和 node 配置 gzip 的使用方法。 下载插件 npm install compression-webpack-plugin --save-dev npm install compression webpack 配置 const CompressionPlugin = require('compression-webpack-plugin'); module.exports = { plugins: [new CompressionPlugin()], } node 配置 const compression = require('compression') // 在其他中间件前使用 app.use(compression()) 9. 图片优化 (1). 图片延迟加载 在页面中，先不给图片设置路径，只有当图片出现在浏览器的可视区域时，才去加载真正的图片，这就是延迟加载。对于图片很多的网站来说，一次性加载全部图片，会对用户体验造成很大的影响，所以需要使用图片延迟加载。 首先可以将图片这样设置，在页面不可见时图片不会加载： 等页面可见时，使用 JS 加载图片： const img = document.querySelector('img') img.src = img.dataset.src 这样图片就加载出来了。 (2). 响应式图片 响应式图片的优点是浏览器能够根据屏幕大小自动加载合适的图片。 通过 picture 实现 通过 @media 实现 @media (min-width: 769px) { .bg { background-image: url(bg1080.jpg); } } @media (max-width: 768px) { .bg { background-image: url(bg768.jpg); } } (3). 调整图片大小 例如，你有一个 1920 * 1080 大小的图片，用缩略图的方式展示给用户，并且当用户鼠标悬停在上面时才展示全图。如果用户从未真正将鼠标悬停在缩略图上，则浪费了下载图片的时间。 所以，我们可以用两张图片来实行优化。一开始，只加载缩略图，当用户悬停在图片上时，才加载大图。还有一种办法，即对大图进行延迟加载，在所有元素都加载完成后手动更改大图的 src 进行下载。 (4). 降低图片质量 例如 JPG 格式的图片，100% 的质量和 90% 质量的通常看不出来区别，尤其是用来当背景图的时候。我经常用 PS 切背景图时， 将图片切成 JPG 格式，并且将它压缩到 60% 的质量，基本上看不出来区别。 压缩方法有两种，一是通过 webpack 插件 image-webpack-loader，二是通过在线网站进行压缩。 以下附上 webpack 插件 image-webpack-loader 的用法。 npm i -D image-webpack-loader webpack 配置 { test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, use:[ { loader: 'url-loader', options: { limit: 10000, /* 图片大小小于1000字节限制时会自动转成 base64 码引用*/ name: utils.assetsPath('img/[name].[hash:7].[ext]') } }, /*对图片进行压缩*/ { loader: 'image-webpack-loader', options: { bypassOnDebug: true, } } ] } (5). 尽可能利用 CSS3 效果代替图片 有很多图片使用 CSS 效果（渐变、阴影等）就能画出来，这种情况选择 CSS3 效果更好。因为代码大小通常是图片大小的几分之一甚至几十分之一。 (6). 使用 webp 格式的图片 WebP 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都相当优秀、稳定和统一。 参考资料： WebP 相对于 PNG、JPG 有什么优势？ https://www.zhihu.com/question/27201061 10. 通过 webpack 按需加载代码，提取第三库代码，减少 ES6 转为 ES5 的冗余代码 懒加载或者按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把你的代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载。 根据文件内容生成文件名，结合 import 动态引入组件实现按需加载 通过配置 output 的 filename 属性可以实现这个需求。filename 属性的值选项中有一个 [contenthash]，它将根据文件内容创建出唯一 hash。当文件内容发生变化时，[contenthash] 也会发生变化。 output: { filename: '[name].[contenthash].js', chunkFilename: '[name].[contenthash].js', path: path.resolve(__dirname, '../dist'), }, 提取第三方库 由于引入的第三方库一般都比较稳定，不会经常改变。所以将它们单独提取出来，作为长期缓存是一个更好的选择。这里需要使用 webpack4 的 splitChunk 插件 cacheGroups 选项。 optimization: { runtimeChunk: { name: 'manifest' // 将 webpack 的 runtime 代码拆分为一个单独的 chunk。 }, splitChunks: { cacheGroups: { vendor: { name: 'chunk-vendors', test: /[\\\\/]node_modules[\\\\/]/, priority: -10, chunks: 'initial' }, common: { name: 'chunk-common', minChunks: 2, priority: -20, chunks: 'initial', reuseExistingChunk: true } }, } }, test: 用于控制哪些模块被这个缓存组匹配到。原封不动传递出去的话，它默认会选择所有的模块。可以传递的值类型：RegExp、String和Function; priority：表示抽取权重，数字越大表示优先级越高。因为一个 module 可能会满足多个 cacheGroups 的条件，那么抽取到哪个就由权重最高的说了算； reuseExistingChunk：表示是否使用已有的 chunk，如果为 true 则表示如果当前的 chunk 包含的模块已经被抽取出去了，那么将不会重新生成新的。 minChunks（默认是1）：在分割之前，这个代码块最小应该被引用的次数（译注：保证代码块复用性，默认配置的策略是不需要多次引用也可以被分割） chunks (默认是async) ：initial、async和all name(打包的chunks的名字)：字符串或者函数(函数可以根据条件自定义名字) 减少 ES6 转为 ES5 的冗余代码 Babel 转化后的代码想要实现和原来代码一样的功能需要借助一些帮助函数，比如： class Person {} 会被转换为： \"use strict\"; function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } var Person = function Person() { _classCallCheck(this, Person); }; 这里 _classCallCheck 就是一个 helper 函数，如果在很多文件里都声明了类，那么就会产生很多个这样的 helper 函数。 这里的 @babel/runtime 包就声明了所有需要用到的帮助函数，而 @babel/plugin-transform-runtime 的作用就是将所有需要 helper 函数的文件，从 @babel/runtime包 引进来： \"use strict\"; var _classCallCheck2 = require(\"@babel/runtime/helpers/classCallCheck\"); var _classCallCheck3 = _interopRequireDefault(_classCallCheck2); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } var Person = function Person() { (0, _classCallCheck3.default)(this, Person); }; 这里就没有再编译出 helper 函数 classCallCheck 了，而是直接引用了 @babel/runtime 中的 helpers/classCallCheck。 安装 npm i -D @babel/plugin-transform-runtime @babel/runtime 使用 在 .babelrc 文件中 \"plugins\": [ \"@babel/plugin-transform-runtime\" ] 减少重绘重排 浏览器渲染过程 解析HTML生成DOM树。 解析CSS生成CSSOM规则树。 解析JS，操作 DOM 树和 CSSOM 规则树。 将DOM树与CSSOM规则树合并在一起生成渲染树。 遍历渲染树开始布局，计算每个节点的位置大小信息。 浏览器将所有图层的数据发送给GPU，GPU将图层合成并显示在屏幕上。 重排 当改变 DOM 元素位置或大小时，会导致浏览器重新生成渲染树，这个过程叫重排。 重绘 当重新生成渲染树后，就要将渲染树每个节点绘制到屏幕，这个过程叫重绘。不是所有的动作都会导致重排，例如改变字体颜色，只会导致重绘。记住，重排会导致重绘，重绘不会导致重排 。 重排和重绘这两个操作都是非常昂贵的，因为 JavaScript 引擎线程与 GUI 渲染线程是互斥，它们同时只能一个在工作。 什么操作会导致重排？ 添加或删除可见的 DOM 元素 元素位置改变 元素尺寸改变 内容改变 浏览器窗口尺寸改变 如何减少重排重绘？ 用 JavaScript 修改样式时，最好不要直接写样式，而是替换 class 来改变样式。 如果要对 DOM 元素执行一系列操作，可以将 DOM 元素脱离文档流，修改完成后，再将它带回文档。推荐使用隐藏元素（display:none）或文档碎片（DocumentFragement），都能很好的实现这个方案。 12. 使用事件委托 事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。所有用到按钮的事件（多数鼠标事件和键盘事件）都适合采用事件委托技术， 使用事件委托可以节省内存。 苹果 香蕉 凤梨 // good document.querySelector('ul').onclick = (event) => { const target = event.target if (target.nodeName === 'LI') { console.log(target.innerHTML) } } // bad document.querySelectorAll('li').forEach((e) => { e.onclick = function() { console.log(this.innerHTML) } }) 13. 注意程序的局部性 一个编写良好的计算机程序常常具有良好的局部性，它们倾向于引用最近引用过的数据项附近的数据项，或者最近引用过的数据项本身，这种倾向性，被称为局部性原理。有良好局部性的程序比局部性差的程序运行得更快。 局部性通常有两种不同的形式： 时间局部性：在一个具有良好时间局部性的程序中，被引用过一次的内存位置很可能在不远的将来被多次引用。 空间局部性 ：在一个具有良好空间局部性的程序中，如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用附近的一个内存位置。 时间局部性示例 function sum(arry) { let i, sum = 0 let len = arry.length for (i = 0; i 在这个例子中，变量sum在每次循环迭代中被引用一次，因此，对于sum来说，具有良好的时间局部性 空间局部性示例 具有良好空间局部性的程序 // 二维数组 function sum1(arry, rows, cols) { let i, j, sum = 0 for (i = 0; i 空间局部性差的程序 // 二维数组 function sum2(arry, rows, cols) { let i, j, sum = 0 for (j = 0; j 看一下上面的两个空间局部性示例，像示例中从每行开始按顺序访问数组每个元素的方式，称为具有步长为1的引用模式。如果在数组中，每隔k个元素进行访问，就称为步长为k的引用模式。一般而言，随着步长的增加，空间局部性下降。 这两个例子有什么区别？区别在于第一个示例是按行扫描数组，每扫描完一行再去扫下一行；第二个示例是按列来扫描数组，扫完一行中的一个元素，马上就去扫下一行中的同一列元素。 数组在内存中是按照行顺序来存放的，结果就是逐行扫描数组的示例得到了步长为 1 引用模式，具有良好的空间局部性；而另一个示例步长为 rows，空间局部性极差。 性能测试 运行环境： cpu: i5-7400 浏览器: chrome 70.0.3538.110 对一个长度为9000的二维数组（子数组长度也为9000）进行10次空间局部性测试，时间（毫秒）取平均值，结果如下： 所用示例为上述两个空间局部性示例 步长为 1步长为 90001242316 从以上测试结果来看，步长为 1 的数组执行时间比步长为 9000 的数组快了一个数量级。 总结： 重复引用相同变量的程序具有良好的时间局部性 对于具有步长为 k 的引用模式的程序，步长越小，空间局部性越好；而在内存中以大步长跳来跳去的程序空间局部性会很差 14. if-else 对比 switch 当判断条件数量越来越多时，越倾向于使用 switch 而不是 if-else。 if (color == 'blue') { } else if (color == 'yellow') { } else if (color == 'white') { } else if (color == 'black') { } else if (color == 'green') { } else if (color == 'orange') { } else if (color == 'pink') { } switch (color) { case 'blue': break case 'yellow': break case 'white': break case 'black': break case 'green': break case 'orange': break case 'pink': break } 像以上这种情况，使用 switch 是最好的。假设 color 的值为 pink，则 if-else 语句要进行 7 次判断，switch 只需要进行一次判断。从可读性来说，switch 语句也更好。 从使用时机来说，当条件值大于两个的时候，使用 switch 更好。不过 if-else 也有 switch 无法做到的事情，例如有多个判断条件的情况下，无法使用 switch。 15. 查找表 当条件语句特别多时，使用 switch 和 if-else 不是最佳的选择，这时不妨试一下查找表。查找表可以使用数组和对象来构建。 switch (index) { case '0': return result0 case '1': return result1 case '2': return result2 case '3': return result3 case '4': return result4 case '5': return result5 case '6': return result6 case '7': return result7 case '8': return result8 case '9': return result9 case '10': return result10 case '11': return result11 } 可以将这个 switch 语句转换为查找表 const results = [result0,result1,result2,result3,result4,result5,result6,result7,result8,result9,result10,result11] return results[index] 如果条件语句不是数值而是字符串，可以用对象来建立查找表 const map = { red: result0, green: result1, } return map[color] 16. 避免页面卡顿 60fps 与设备刷新率 目前大多数设备的屏幕刷新率为 60 次/秒。因此，如果在页面中有一个动画或渐变效果，或者用户正在滚动页面，那么浏览器渲染动画或页面的每一帧的速率也需要跟设备屏幕的刷新率保持一致。 其中每个帧的预算时间仅比 16 毫秒多一点 (1 秒/ 60 = 16.66 毫秒)。但实际上，浏览器有整理工作要做，因此您的所有工作需要在 10 毫秒内完成。如果无法符合此预算，帧率将下降，并且内容会在屏幕上抖动。此现象通常称为卡顿，会对用户体验产生负面影响。 假如你用 JavaScript 修改了 DOM，并触发样式修改，经历重排重绘最后画到屏幕上。如果这其中任意一项的执行时间过长，都会导致渲染这一帧的时间过长，平均帧率就会下降。假设这一帧花了 50 ms，那么此时的帧率为 1s / 50ms = 20fps，页面看起来就像卡顿了一样。 对于一些长时间运行的 JavaScript，我们可以使用定时器进行切分，延迟执行。 for (let i = 0, len = arry.length; i 假设上面的循环结构由于 process() 复杂度过高或数组元素太多，甚至两者都有，可以尝试一下切分。 const todo = arry.concat() setTimeout(function() { process(todo.shift()) if (todo.length) { setTimeout(arguments.callee, 25) } else { callback(arry) } }, 25) 如果有兴趣了解更多，可以查看一下高性能JavaScript第 6 章和高效前端：Web高效编程与优化实践第 3 章。 17. 使用 requestAnimationFrame 来实现视觉变化 从第 16 点我们可以知道，大多数设备屏幕刷新率为 60 次/秒，也就是说每一帧的平均时间为 16.66 毫秒。在使用 JavaScript 实现动画效果的时候，最好的情况就是每次代码都是在帧的开头开始执行。而保证 JavaScript 在帧开始时运行的唯一方式是使用 requestAnimationFrame。 /** * If run as a requestAnimationFrame callback, this * will be run at the start of the frame. */ function updateScreen(time) { // Make visual updates here. } requestAnimationFrame(updateScreen); 如果采取 setTimeout 或 setInterval 来实现动画的话，回调函数将在帧中的某个时点运行，可能刚好在末尾，而这可能经常会使我们丢失帧，导致卡顿。 18. 使用 Web Workers Web Worker 使用其他工作线程从而独立于主线程之外，它可以执行任务而不干扰用户界面。一个 worker 可以将消息发送到创建它的 JavaScript 代码, 通过将消息发送到该代码指定的事件处理程序（反之亦然）。 Web Worker 适用于那些处理纯数据，或者与浏览器 UI 无关的长时间运行脚本。 创建一个新的 worker 很简单，指定一个脚本的 URI 来执行 worker 线程（main.js）： var myWorker = new Worker('worker.js'); // 你可以通过postMessage() 方法和onmessage事件向worker发送消息。 first.onchange = function() { myWorker.postMessage([first.value,second.value]); console.log('Message posted to worker'); } second.onchange = function() { myWorker.postMessage([first.value,second.value]); console.log('Message posted to worker'); } 在 worker 中接收到消息后，我们可以写一个事件处理函数代码作为响应（worker.js）： onmessage = function(e) { console.log('Message received from main script'); var workerResult = 'Result: ' + (e.data[0] * e.data[1]); console.log('Posting message back to main script'); postMessage(workerResult); } onmessage处理函数在接收到消息后马上执行，代码中消息本身作为事件的data属性进行使用。这里我们简单的对这2个数字作乘法处理并再次使用postMessage()方法，将结果回传给主线程。 回到主线程，我们再次使用onmessage以响应worker回传的消息： myWorker.onmessage = function(e) { result.textContent = e.data; console.log('Message received from worker'); } 在这里我们获取消息事件的data，并且将它设置为result的textContent，所以用户可以直接看到运算的结果。 不过在worker内，不能直接操作DOM节点，也不能使用window对象的默认方法和属性。然而你可以使用大量window对象之下的东西，包括WebSockets，IndexedDB以及FireFox OS专用的Data Store API等数据存储机制。 19. 使用位操作 JavaScript 中的数字都使用 IEEE-754 标准以 64 位格式存储。但是在位操作中，数字被转换为有符号的 32 位格式。即使需要转换，位操作也比其他数学运算和布尔操作快得多。 取模 由于偶数的最低位为 0，奇数为 1，所以取模运算可以用位操作来代替。 if (value % 2) { // 奇数 } else { // 偶数 } // 位操作 if (value & 1) { // 奇数 } else { // 偶数 } 取整 ~~10.12 // 10 ~~10 // 10 ~~'1.5' // 1 ~~undefined // 0 ~~null // 0 位掩码 const a = 1 const b = 2 const c = 4 const options = a | b | c 通过定义这些选项，可以用按位与操作来判断 a/b/c 是否在 options 中。 // 选项 b 是否在选项中 if (b & options) { ... } 20. 不要覆盖原生方法 无论你的 JavaScript 代码如何优化，都比不上原生方法。因为原生方法是用低级语言写的（C/C++），并且被编译成机器码，成为浏览器的一部分。当原生方法可用时，尽量使用它们，特别是数学运算和 DOM 操作。 21. 降低 CSS 选择器的复杂性 (1). 浏览器读取选择器，遵循的原则是从选择器的右边到左边读取。 看个示例 #block .text p { color: red; } 查找所有 P 元素。 查找结果 1 中的元素是否有类名为 text 的父元素 查找结果 2 中的元素是否有 id 为 block 的父元素 (2). CSS 选择器优先级 内联 > ID选择器 > 类选择器 > 标签选择器 根据以上两个信息可以得出结论。 选择器越短越好。 尽量使用高优先级的选择器，例如 ID 和类选择器。 避免使用通配符 *。 最后要说一句，据我查找的资料所得，CSS 选择器没有优化的必要，因为最慢和慢快的选择器性能差别非常小。 22. 使用 flexbox 而不是较早的布局模型 在早期的 CSS 布局方式中我们能对元素实行绝对定位、相对定位或浮动定位。而现在，我们有了新的布局方式 flexbox，它比起早期的布局方式来说有个优势，那就是性能比较好。 下面的截图显示了在 1300 个框上使用浮动的布局开销： 然后我们用 flexbox 来重现这个例子： 现在，对于相同数量的元素和相同的视觉外观，布局的时间要少得多（本例中为分别 3.5 毫秒和 14 毫秒）。 不过 flexbox 兼容性还是有点问题，不是所有浏览器都支持它，所以要谨慎使用。 各浏览器兼容性： Chrome 29+ Firefox 28+ Internet Explorer 11 Opera 17+ Safari 6.1+ (prefixed with -webkit-) Android 4.4+ iOS 7.1+ (prefixed with -webkit-) 23. 使用 transform 和 opacity 属性更改来实现动画 在 CSS 中，transforms 和 opacity 这两个属性更改不会触发重排与重绘，它们是可以由合成器（composite）单独处理的属性。 参考资料： 使用 transform 和 opacity 属性更改来实现动画 24. 合理使用规则，避免过度优化 性能优化主要分为两类： 加载时优化 运行时优化 上述 23 条建议中，属于加载时优化的是前面 10 条建议，属于运行时优化的是后面 13 条建议。通常来说，没有必要 23 条性能优化规则都用上，根据网站用户群体来做针对性的调整是最好的，节省精力，节省时间。 在解决问题之前，得先找出问题，否则无从下手。所以在做性能优化之前，最好先调查一下网站的加载性能和运行性能。 检查加载性能 一个网站加载性能如何主要看白屏时间和首屏时间。 白屏时间：指从输入网址，到页面开始显示内容的时间。 首屏时间：指从输入网址，到页面完全渲染的时间。 将以下脚本放在 前面就能获取白屏时间。 new Date() - performance.timing.navigationStart 在 window.onload 事件里执行 new Date() \\- performance.timing.navigationStart 即可获取首屏时间。 检查运行性能 配合 chrome 的开发者工具，我们可以查看网站在运行时的性能。 打开网站，按 F12 选择 performance，点击左上角的灰色圆点，变成红色就代表开始记录了。这时可以模仿用户使用网站，在使用完毕后，点击 stop，然后你就能看到网站运行期间的性能报告。如果有红色的块，代表有掉帧的情况；如果是绿色，则代表 FPS 很好。performance 的具体使用方法请用搜索引擎搜索一下，毕竟篇幅有限。 通过检查加载和运行性能，相信你对网站性能已经有了大概了解。所以这时候要做的事情，就是使用上述 23 条建议尽情地去优化你的网站，加油！ EOF - 推荐阅读 点击标题可跳转 1、Vue实现原理+前端性能优化 2、从 12.67s 到 1.06s 的网站性能优化实战 3、你必须懂的前端性能优化 觉得本文对你有帮助？请分享给更多人 推荐关注「前端大全」，提升前端技能 点赞和在看就是最大的支持❤️ Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-22 16:44:51 "},"前端杂项/常用正则.html":{"url":"前端杂项/常用正则.html","title":"常用正则","keywords":"","body":"常用正则 const phoneReg = /^1[3|4|5|6|7|8|9][0-9]{9}$/ const telReg = /^(0\\d{2,3}-\\d{7,8})(-\\d{1,4})?$/ const cardReg = /(^\\d{15}$)|(^\\d{18}$)|(^\\d{17}(\\d|X|x)$)/ const pwdReg = /^[a-zA-Z]\\w{5,17}$/ const postalReg = /[1-9]\\d{5}(?!\\d)/ const QQReg = /^[1-9][0-9]{4,9}$/ const checkStr = function(str, type) { // 常用正则验证，注意type大小写 switch (type) { case 'phone': // 手机号码 return /^1[3|4|5|6|7|8|9][0-9]{9}$/.test(str) case 'tel': // 座机 return /^(0\\d{2,3}-\\d{7,8})(-\\d{1,4})?$/.test(str) case 'card': // 身份证 return /(^\\d{15}$)|(^\\d{18}$)|(^\\d{17}(\\d|X|x)$)/.test(str) case 'pwd': // 密码以字母开头，长度在6~18之间，只能包含字母、数字和下划线 return /^[a-zA-Z]\\w{5,17}$/.test(str) case 'postal': // 邮政编码 return /[1-9]\\d{5}(?!\\d)/.test(str) case 'QQ': // QQ号 return /^[1-9][0-9]{4,9}$/.test(str) case 'email': // 邮箱 return /^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$/.test(str) case 'money': // 金额(小数点2位) return /^\\d*(?:\\.\\d{0,2})?$/.test(str) case 'URL': // 网址 return /(http|ftp|https):\\/\\/[\\w\\-_]+(\\.[\\w\\-_]+)+([\\w\\-\\.,@?^=%&:/~\\+#]*[\\w\\-\\@?^=%&/~\\+#])?/.test(str) case 'IP': // IP return /((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))/.test(str) case 'date': // 日期时间 return /^(\\d{4})\\-(\\d{2})\\-(\\d{2}) (\\d{2})(?:\\:\\d{2}|:(\\d{2}):(\\d{2}))$/.test(str) || /^(\\d{4})\\-(\\d{2})\\-(\\d{2})$/.test(str) case 'number': // 数字 return /^[0-9]$/.test(str) case 'english': // 英文 return /^[a-zA-Z]+$/.test(str) case 'chinese': // 中文 return /^[\\u4E00-\\u9FA5]+$/.test(str) case 'lower': // 小写 return /^[a-z]+$/.test(str) case 'upper': // 大写 return /^[A-Z]+$/.test(str) case 'HTML': // HTML标记 return /])*>/.test(str) default: return true } } Copyright all right reserved，powered by Gitbook该文件修订时间： 2021-11-22 15:51:03 "}}